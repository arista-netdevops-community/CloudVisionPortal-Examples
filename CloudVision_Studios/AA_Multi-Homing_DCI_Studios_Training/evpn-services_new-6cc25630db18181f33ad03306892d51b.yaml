- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: studio-evpn-services
        workspace_id: &workspace_id ws-evpn-services
      display_name: EVPN Services
      description: Define and configure EVPN services for an L3 network fabric, including configuration of VRFs, VLANs, VNIs and associated IPv4/v6 addressing
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import hashlib
          import ipaddress
          import json
          import os
          import re
          import time
          from itertools import count, groupby
          from cloudvision.cvlib.iputils import (
              is_ipv4,
              is_ipv6,
              first_usable_address,
              last_usable_address,
              get_subnet_by_index,
              get_ip_from_subnet,
          )


          veos_regex = r'(v|c)EOS(-)*(Lab)*'


          fabric_variables = {
              "bgp_peer_groups": {
                  "EVPN_OVERLAY_CORE": {
                      "name": "EVPN-OVERLAY-CORE",
                      "password": None,
                      'evpn_ebgp_gateway_multihop': 15
                  }
              },
              "pruneVlans": None,
              "loopback_settings": {},
          }

          # Dictionary of per tenant vlans assigned to lowest tier devices
          vlans_devs = dict(dict(set()))

          # Turning on DEBUG_LEVEL will impact performance
          DEBUG_LEVEL = 0
          if DEBUG_LEVEL:
              ctx.benchmarkingOn()


          def dump_my_switch_facts(stage):
              if DEBUG_LEVEL > 2:
                  ctx.info(f"{my_device_id} FACTS Stage {stage}:\n"
                           f"{json.dumps(my_switch_facts, sort_keys=True, indent=4, default=str)}")


          def dump_my_config(stage):
              if DEBUG_LEVEL > 2:
                  ctx.info(f"{my_device.id} CONFIG Stage {stage}:\n"
                           f"{json.dumps(my_config, sort_keys=True, indent=4, default=str)}")


          @ctx.benchmark
          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]


          @ctx.benchmark
          def convert(text):
              return int(text) if text.isdigit() else text.lower()


          @ctx.benchmark
          def natural_sort(iterable, sort_key=None):
              if iterable is None:
                  return []

              def alphanum_key(key):
                  if sort_key is not None and isinstance(key, dict):
                      return [convert(c) for c in re.split("([0-9]+)", str(key.get(sort_key, key)))]
                  else:
                      return [convert(c) for c in re.split("([0-9]+)", str(key))]

              return sorted(iterable, key=alphanum_key)


          @ctx.benchmark
          def string_to_list(string_to_convert):
              numbers = []
              if not string_to_convert:
                  return numbers
              segments = [segment.strip() for segment in string_to_convert.split(",")]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          numbers.append(i)
                  else:
                      numbers.append(int(segment))
              return numbers


          @ctx.benchmark
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))


          @ctx.benchmark
          def convert_dicts(dictionary, primary_key="name", secondary_key=None):
              """
              The `arista.avd.convert_dicts` filter will convert a dictionary containing nested dictionaries to a list of
              dictionaries. It inserts the outer dictionary keys into each list item using the primary_key `name` (key name is
              configurable) and if there is a non-dictionary value,it inserts this value to
              secondary key (key name is configurable), if secondary key is provided.
              This filter is intended for:
              - Seemless data model migration from dictionaries to lists.
              - Improve Ansible's processing performance when dealing with large dictionaries by converting them to lists of dictionaries.
              Note: If there is a non-dictionary value with no secondary key provided, it will pass through untouched
              To use this filter:
              ```jinja
              {# convert list of dictionary with default `name:` as the primary key and None secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.name }}
              {% endfor %}
              {# convert list of dictionary with `id:` set as the primary key and `types:` set as the secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts('id','types') %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.id }}
              item secondary key is {{ example_item.types }}
              {% endfor %}
              ```
              Parameters
              ----------
              dictionary : any
                  Nested Dictionary to convert - returned untouched if not a nested dictionary and list
              primary_key : str, optional
                  Name of primary key used when inserting outer dictionary keys into items.
              secondary_key : str, optional
                  Name of secondary key used when inserting dictionary values which are list into items.
              Returns
              -------
              any
                  Returns list of dictionaries or input variable untouched if not a nested dictionary/list.
              """
              if not isinstance(dictionary, (dict, list)) or os.environ.get("AVD_DISABLE_CONVERT_DICTS"):
                  # Not a dictionary/list, return the original
                  return dictionary
              elif isinstance(dictionary, list):
                  output = []
                  for element in dictionary:
                      if not isinstance(element, dict):
                          item = {}
                          item.update({primary_key: element})
                          output.append(item)
                      elif primary_key not in element and secondary_key is not None:
                          # if element of nested dictionary is a dictionary but primary key is missing, insert primary and secondary keys.
                          for key in element:
                              output.append(
                                  {
                                      primary_key: key,
                                      secondary_key: element[key],
                                  }
                              )
                      else:
                          output.append(element)
                  return output
              else:
                  output = []
                  for key in dictionary:
                      if secondary_key is not None:
                          # Add secondary key for the values if secondary key is provided
                          item = {}
                          item.update({primary_key: key})
                          item.update({secondary_key: dictionary[key]})
                          output.append(item)
                      else:
                          if not isinstance(dictionary[key], dict):
                              # Not a nested dictionary
                              output.append({primary_key: key})
                          else:
                              # Nested dictionary
                              item = dictionary[key].copy()
                              item.update({primary_key: key})
                              output.append(item)
                  return output


          @ctx.benchmark
          def get(dictionary, key, default=None, required=False, org_key=None, separator="."):
              """
              Get a value from a dictionary or nested dictionaries.
              Key supports dot-notation like "foo.bar" to do deeper lookups.
              Returns the supplied default value or None if the key is not found and required is False.
              Parameters
              ----------
              dictionary : dict
                  Dictionary to get key from
              key : str
                  Dictionary Key - supporting dot-notation for nested dictionaries
              default : any
                  Default value returned if the key is not found
              required : bool
                  Fail if the key is not found
              org_key : str
                  Internal variable used for raising exception with the full key name even when called recursively
              separator: str
                  String to use as the separator parameter in the split function. Useful in cases when the key
                  can contain variables with "." inside (e.g. hostnames)
              Returns
              -------
              any
                  Value or default value
              Raises
              ------
              AristaAvdMissingVariableError
                  If the key is not found and required == True
              """

              if org_key is None:
                  org_key = key
              keys = str(key).split(separator)
              value = dictionary.get(keys[0])
              if value is None:
                  if required is True:
                      raise TypeError(org_key)
                  return default
              else:
                  if len(keys) > 1:
                      return get(value, separator.join(keys[1:]), default=default, required=required, org_key=org_key, separator=separator)
                  else:
                      return value


          @ctx.benchmark
          def default(*values):
              """
              Accepts any number of arguments. Return the first value which is not None
              Last resort is to return None.
              Parameters
              ----------
              *values : any
                  One or more values to test
              Returns
              -------
              any
                  First value which is not None
              """

              for value in values:
                  if value is not None:
                      return value
              return None


          @ctx.benchmark
          def hash_value(value, vkeys_to_consider = None):
              """
              Return a hash for the value.
              If the value is a dictionary, can limit the keys,
              to consider in the hash.
              """
              value_to_hash = value
              if vkeys_to_consider and isinstance(value, dict):
                  value_to_hash = {key: value.get(key) for key in vkeys_to_consider}
              return hashlib.sha256(str(value_to_hash).encode()).hexdigest()


          @ctx.benchmark
          def get_ip(pool: str, prefixlen: int, subnet_offset: int, ip_offset: int) -> str:
              pool_network = ipaddress.ip_network(pool, strict=False)
              prefixlen_diff = prefixlen - pool_network.prefixlen
              subnet_size = (int(pool_network.hostmask) + 1) >> prefixlen_diff
              if (subnet_offset + 1) * subnet_size > pool_network.num_addresses:
                  raise Exception(f"Unable to get {subnet_offset + 1} /{prefixlen} subnets from pool {pool}")
              subnet = ipaddress.ip_network((int(pool_network.network_address) + subnet_offset * subnet_size, prefixlen))
              try:
                  ip = subnet[ip_offset]
              except IndexError as e:
                  raise Exception(f"Unable to get {ip_offset+1} hosts in subnet {subnet} taken from pool {pool}") from e
              return str(ip)


          @ctx.benchmark
          def check_vni_overlap(tenants):
              '''
              Summary:
                  Asserts errors if vlans or vnis use overlapping vni numbers
              Returns
                  None
              '''
              for tenant in convert_dicts(tenants):
                  vnis_seen = {}
                  for vrf in convert_dicts(tenant["vrfs"]):
                      if vrf.get("vni") is not None:
                          assert vnis_seen.get(vrf['vni']) is None, f"VNI {vrf['vni']} found in multiple places -> " \
                                                                    f"{vnis_seen[vrf['vni']]['name']} " \
                                                                    f"and {vrf['name']} in tenant {tenant['name']}. " \
                                                                    f"Please correct the VNI " \
                                                                    f"conflict before moving forward."
                          vnis_seen[vrf['vni']] = vrf
                      for svi in convert_dicts(vrf["svis"], primary_key='id'):
                          if svi.get("vni") is not None:
                              assert vnis_seen.get(svi['vni']) is None, f"VNI {svi['vni']} found in multiple places -> " \
                                                                        f"{vnis_seen[svi['vni']].get('name')} and " \
                                                                        f"{svi['id']} in tenant {tenant['name']}. " \
                                                                        f"Please correct the VNI " \
                                                                        f"conflict before moving forward."
                              vnis_seen[svi['vni']] = svi

                  for l2vlan in convert_dicts(tenant["l2vlans"], primary_key='id'):
                      if l2vlan.get("vni") is not None:
                          assert vnis_seen.get(l2vlan['vni']) is None, f"VNI {l2vlan['vni']} found in multiple places -> " \
                                                                       f"{vnis_seen[l2vlan['vni']].get('name')} and " \
                                                                       f"{l2vlan['id']} in tenant {tenant['name']}. " \
                                                                       f"Please correct the VNI " \
                                                                       f"conflict before moving forward."
                          vnis_seen[l2vlan['vni']] = l2vlan


          @ctx.benchmark
          def get_mlag_ip(switch_facts, mlag_peer_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, (
                  "MLAG Subnet mask length must be longer than "
                  "the mask of the mlag subnet" )
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  index = int(switch_facts['mlag_primary_id']) - 1
                  mlag_subnet = get_subnet_by_index(
                      mlag_peer_pool, mlag_subnet_mask, index,
                      switch_facts.get('hostname'))
              if mlag_role == "primary":
                  return get_ip_from_subnet(
                             mlag_subnet,
                             0,
                             switch_facts['hostname'])
              elif mlag_role == "secondary":
                  return get_ip_from_subnet(
                             mlag_subnet,
                             1,
                             switch_facts['hostname'])
              return


          @ctx.benchmark
          def set_trunks_config(config, switch_facts):
              if switch_facts.get('Downlinks_Interfaces'):
                  po_phys = []
                  for po, phys in switch_facts.get('Downlinks_POs', {}).items():
                      config['downlink_trunks'].append(po)
                      po_phys.extend(phys)
                  for phy in switch_facts.get('Downlinks_Interfaces', []):
                      if phy not in po_phys:
                          config['downlink_trunks'].append(phy)
              if switch_facts.get('Uplinks_Interfaces'):
                  po_phys = []
                  for po, phys in switch_facts.get('Uplinks_POs', {}).items():
                      config['uplink_trunks'].append(po)
                      po_phys.extend(phys)
                  for phy in switch_facts.get('Uplinks_Interfaces', []):
                      if phy not in po_phys:
                          config['uplink_trunks'].append(phy)
              if switch_facts.get('vlans') and fabric_variables.get('pruneVlans'):
                  config['trunk_vlans'] = ','.join(str(vlan) for vlan in switch_facts.get('vlans'))
              return config


          @ctx.benchmark
          def set_base_config(config, switch_facts):
              # Set router-bgp
              if switch_facts['network_services_l3']:
                  # Enable ipv4 routing by default for router bgp
                  config['ipv4_routing'] = True
                  config['router_bgp']['as'] = switch_facts['bgp_as']
                  config['router_bgp']['router_id'] = switch_facts['router_id']
                  # Enable BGP 4B ASN dot notation
                  config['router_bgp']['4basn_enabled'] = switch_facts.get('4basn_enabled')
              return config


          @ctx.benchmark
          def set_overlay_config(config, switch_facts):
              overlay_data = {}
              # Set evpn route servers
              overlay_data['evpn_gateway_remote_peers'] = {}
              if switch_facts.get('evpn_gateway_remote_peers'):
                  for evpn_gw_remote_peer in switch_facts['evpn_gateway_remote_peers']:
                      server = {}
                      server['bgp_as_upper'] = evpn_gw_remote_peer.get(
                          'peerBgpAsnUpper') if switch_facts['4basn_enabled'] else None
                      server['bgp_as'] = evpn_gw_remote_peer.get('peerBgpAsn')
                      server['ip_address'] = evpn_gw_remote_peer.get('peerIpAddress')
                      overlay_data['evpn_gateway_remote_peers'].update({ evpn_gw_remote_peer['peerHostname']: server })
              # Set EVPN_OVERLAY_CORE neighbors config
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  for evpn_gw_remote_peer in natural_sort(overlay_data['evpn_gateway_remote_peers'].keys()):
                      config['router_bgp']['neighbors'][overlay_data['evpn_gateway_remote_peers'][evpn_gw_remote_peer]['ip_address']] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name'],
                          "description": evpn_gw_remote_peer,
                          "remote_as_upper": overlay_data['evpn_gateway_remote_peers'][
                              evpn_gw_remote_peer].get('bgp_as_upper') if switch_facts[
                              '4basn_enabled'] else None,
                          "remote_as": overlay_data['evpn_gateway_remote_peers'][
                              evpn_gw_remote_peer]['bgp_as']
                      }
              # If the peer group has no neighbors then don't generate
              # peer group config
              if not config['router_bgp']['neighbors']:
                  return config
              # Set EVPN_OVERLAY_CORE peer group config
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['peer_groups'][fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']] = {
                      "type": "evpn",
                      "update_source": f"Loopback{fabric_variables['loopback_settings']['overlayLoopbackNumber']}",
                      "bfd": True,
                      "ebgp_multihop": fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['evpn_ebgp_gateway_multihop'],
                      "send_community": "all",
                      "maximum_routes": 0
                  }
                  if fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE'].get('password'):
                      config['router_bgp']['peer_groups'][fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']]['password'] = \
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['password']
              # Disable ipv4 address family for EVPN_OVERLAY_CORE peer group
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['address_family_ipv4'] = {
                      "peer_groups": {
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']: {
                              "activate": False
                          }
                      }
                  }
              # Enable evpn address family for EVPN_OVERLAY_CORE peer group
              if switch_facts.get('evpn_gateway_vxlan_l2') or switch_facts.get('evpn_gateway_vxlan_l3'):
                  config['router_bgp']['address_family_evpn'] = {
                      "peer_groups": {
                          fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE']['name']: {
                              "domain_remote": True,
                              "activate": True
                          }
                      }
                  }
                  if switch_facts.get('evpn_gateway_vxlan_l3'):
                      config['router_bgp']['address_family_evpn']['neighbor_default'] = {
                          "next_hop_self_received_evpn_routes": {
                              "enable": True,
                              "inter_domain": switch_facts.get('evpn_gateway_vxlan_l3_inter_domain')
                          }
                      }
              return config


          @ctx.benchmark
          def get_network_services_config_raw_data(config, switch_facts):
              tmp_tenants = []
              # tenants
              for tenant in convert_dicts(switch_facts["all_tenants"]):
                  if tenant["name"] in switch_facts.get('tenants', []):
                      switch_tenant = switch_facts["all_tenants"][tenant["name"]]
                      # vrfs
                      tmp_vrfs = []
                      for vrf in convert_dicts(tenant["vrfs"]):
                          if vrf["name"] in switch_facts["tenants"][tenant["name"]].get("vrfs", {}):
                              switch_vrf = switch_tenant["vrfs"][vrf["name"]]
                              # svis & bgp_peers
                              tmp_svis = []
                              for svi in convert_dicts(vrf["svis"], primary_key='id'):
                                  if svi["id"] in switch_facts["tenants"][tenant["name"]]["vrfs"][vrf["name"]].get("svis", []):
                                      tmp_svis.append(svi)

                              # evpn multicast
                              vrf["_evpn_l3_multicast_enabled"] = default(get(vrf, "evpn_l3_multicast.enabled"), get(tenant, "evpn_l3_multicast.enabled"))
                              # Enable switch_facts multicast settings if evpn multicast is enabled
                              if vrf["_evpn_l3_multicast_enabled"]:
                                  switch_facts["evpn_multicast"] = True
                                  switch_facts["igmp_snooping_enabled"] = True
                              rps = []
                              for rp_address in default(get(vrf, "pim_rp_addresses"), get(tenant, "pim_rp_addresses"), []):
                                  if switch_facts["serial_number"] in get(rp_address, "nodes", default=[switch_facts["serial_number"]]):
                                      for rp_ip in get(
                                          rp_address,
                                          "rps",
                                          required=True,
                                          org_key=f"pim_rp_addresses.rps under VRF '{vrf['name']}' in Tenant '{tenant['name']}'",
                                      ):
                                          if rp_groups := get(rp_address, "groups"):
                                              rps.append({"address": rp_ip, "groups": rp_groups})
                                          else:
                                              rps.append({"address": rp_ip})

                              for evpn_peg in default(get(vrf, "evpn_l3_multicast.evpn_peg"), get(tenant, "evpn_l3_multicast.evpn_peg"), []):
                                  if switch_facts["serial_number"] in evpn_peg.get("nodes", [switch_facts["serial_number"]]) and rps:
                                      vrf["_pim_rp_addresses"] = rps
                                      vrf["_evpn_l3_multicast_evpn_peg_transit"] = evpn_peg.get("transit")
                                      break

                              vrf.update({'svis': tmp_svis, 'bgp_peers': vrf.get("bgp_peers", {})})
                              tmp_vrfs.append(vrf)

                      # l2vlans
                      tmp_l2vlans = []
                      for l2vlan in convert_dicts(tenant["l2vlans"], primary_key='id'):
                          if l2vlan["id"] in switch_facts["tenants"][tenant["name"]].get("l2vlans", []):
                              # Enable switch_facts multicast settings if evpn multicast is enabled
                              vlan_evpn_l2_multicast_enabled = default(get(l2vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
                              if vlan_evpn_l2_multicast_enabled is True:
                                  switch_facts["evpn_multicast"] = True
                                  switch_facts["igmp_snooping_enabled"] = True
                              tmp_l2vlans.append(l2vlan)

                      # vlan aware bundles
                      tmp_vlan_aware_bundles = []
                      for vlan_aware_bundle in convert_dicts(tenant["vlan_aware_bundles"]):
                          if vlan_aware_bundle["name"] in switch_facts["tenants"][tenant["name"]].get("vlan_aware_bundles", []):
                              tmp_vlan_aware_bundles.append(vlan_aware_bundle)

                      tenant.update({'vrfs': tmp_vrfs, 'l2vlans': tmp_l2vlans, 'vlan_aware_bundles': tmp_vlan_aware_bundles})
                      tmp_tenants.append(tenant)

              return tmp_tenants


          @ctx.benchmark
          def set_igmp_snooping_vlan(switch_facts, tenant, isL3, vlan):
              ip_igmp_snooping_vlan = {}
              igmp_snooping_enabled = get(switch_facts, "igmp_snooping_enabled", required=False)
              tenant_igmp_snooping_querier = tenant.get("igmp_snooping_querier", {})
              vlan_igmp_snooping_querier = vlan.get("igmp_snooping_querier", {})
              if isL3:
                  # for backward compatibility cannot add l2 mcast to l3 vlans by default
                  vlan_evpn_l2_multicast_enabled = default(get(tenant, "evpn_l2_multicast.enabledSvis"), get(tenant, "evpn_l2_multicast.enabled"))
              else:
                  vlan_evpn_l2_multicast_enabled = default(get(vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
              if switch_facts.get("vtep") and vlan_evpn_l2_multicast_enabled:
                  if igmp_snooping_enabled is not None:
                      ip_igmp_snooping_vlan["enabled"] = igmp_snooping_enabled
                  igmp_snooping_querier_enabled = True
                  ip_igmp_snooping_vlan["id"] = vlan.get("id")
                  ip_igmp_snooping_vlan["querier"] = {"enabled": igmp_snooping_querier_enabled}
                  address = default(vlan_igmp_snooping_querier.get("source_address"), tenant_igmp_snooping_querier.get("source_address"), switch_facts["router_id"])
                  if address is not None:
                      ip_igmp_snooping_vlan["querier"]["address"] = address
                  version = default(
                      vlan_igmp_snooping_querier.get("version"),
                      tenant_igmp_snooping_querier.get("version"),
                  )
                  if version is not None:
                      ip_igmp_snooping_vlan["querier"]["version"] = version
              return ip_igmp_snooping_vlan


          @ctx.benchmark
          def set_network_services_config_vlans(config, switch_facts, network_services_data):
              # Enable dhcp smart relay
              config['ip_dhcp_relay'] = {"information_option": True}
              # Section commented out for now until more detail is found on which platforms
              # support dhcp snooping
              # Enable dhcp snooping
              # config['ip_dhcp_snooping'] = {
              #     "information_option": True,
              #     "vlans": []
              # }
              igmp_snooping_vlans = []
              igmp_snooping_enabled = get(switch_facts, "igmp_snooping_enabled", required=False)
              for tenant in network_services_data["tenants"]:
                  # Set l3 vlan config
                  for vrf in tenant.get('vrfs', []):
                      # Create vlans
                      for svi in vrf.get('svis', []):
                          # Create L3 vlans
                          config['vlans'][svi['id']] = {
                              "tenant": tenant,
                              "name": svi['name']
                          }
                          # Create L3 SVI with helper address pointing towards CVP
                          config['vlan_interfaces'][f"Vlan{svi['id']}"] = {}
                          # Section commented out for now until more detail is found on which platforms
                          # support dhcp snooping
                          # if vrf == "default":
                          #     config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'] = {
                          #         "127.0.0.1": {}
                          #     }
                          #     # enable snooping on that vlan
                          #     config['ip_dhcp_snooping']['vlans'].append(svi)
                          # igmp snooping
                          ip_igmp_snooping_vlan = set_igmp_snooping_vlan(switch_facts, tenant, True, svi)
                          if ip_igmp_snooping_vlan:
                              igmp_snooping_vlans.append(ip_igmp_snooping_vlan)

                      # Set vrf ibgp peering vlan params
                      if switch_facts.get('mlag') and switch_facts['network_services_l3'] \
                              and vrf.get('enable_mlag_ibgp_peering_vrfs'):
                          ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                          config['vlans'][ibgp_vlan] = {
                              "tenant": tenant['name'],
                              "name": f"MLAG_iBGP_{vrf['name']}",
                              "trunk_groups": ['MLAG_VRF_PEER']
                          }

                  # Set l2 vlan config
                  for l2vlan in tenant.get('l2vlans', []):
                      config['vlans'][l2vlan['id']] = {
                          "tenant": tenant['name'],
                          "name": l2vlan['name']
                      }
                      if l2vlan.get('bgp_eos_cli'):
                          config['vlans'][l2vlan['id']]['bgp_eos_cli'] = l2vlan['bgp_eos_cli']
                      if l2vlan.get('etree_role') and l2vlan['etree_role'] == "leaf" and switch_facts.get('vtep'):
                          config['vlans'][l2vlan['id']]['etree'] = {'role': 'leaf'}
                      # Section commented out for now until more detail is found on which platforms
                      # support dhcp snooping
                      # Create L2 SVI with helper address pointing towards CVP
                      # config['vlan_interfaces'][f"Vlan{l2vlan['id]}"]['ip_helpers'] = {
                      #     "127.0.0.1": {}
                      # }
                      # # enable snooping on the vlan
                      # config['ip_dhcp_snooping']['vlans'].append(l2vlan['id'])

                      # igmp snooping
                      ip_igmp_snooping_vlan = set_igmp_snooping_vlan(switch_facts, tenant, False, l2vlan)
                      if ip_igmp_snooping_vlan:
                          igmp_snooping_vlans.append(ip_igmp_snooping_vlan)
                  if igmp_snooping_enabled and igmp_snooping_vlans:
                      config["ip_igmp_snooping"] = {
                          "globally_enabled": True,
                          "vlans": igmp_snooping_vlans
                      }
              return config


          @ctx.benchmark
          def set_network_services_config_l3_svi_ips(config, svi, ip_ver):
              if svi.get(f'ip_address_virtual_{ip_ver}'):
                  config[f'ip{ip_ver}_routing'] = True
                  config['vlan_interfaces'][f"Vlan{svi['id']}"][
                      f'ip_address_virtual_{ip_ver}'] = svi[
                          f'ip_address_virtual_{ip_ver}']
              if svi.get(f'ip_virtual_router_addresses_{ip_ver}'):
                  config[f'ip{ip_ver}_routing'] = True
                  config['vlan_interfaces'][f"Vlan{svi['id']}"][
                      f'ip_virtual_router_addresses_{ip_ver}'] = svi[
                          f'ip_virtual_router_addresses_{ip_ver}']
              if svi.get(f'ip_address_{ip_ver}'):
                  config[f'ip{ip_ver}_routing'] = True
                  config['vlan_interfaces'][f"Vlan{svi['id']}"][
                      f'ip_address_{ip_ver}'] = svi[
                          f'ip_address_{ip_ver}']


          @ctx.benchmark
          def set_network_services_config_l3(config, switch_facts, network_services_data):
              for tenant in network_services_data["tenants"]:
                  for vrf in tenant.get('vrfs', []):
                      # configure vrfs
                      config['vrfs'][vrf['name']] = {
                          "tenant": tenant['name'],
                      }
                      if vrf.get('v4_routing'):
                          config['vrfs'][vrf['name']]['ipv4_routing'] = True
                          config['ipv4_routing'] = True
                      if vrf.get('v6_routing'):
                          config['vrfs'][vrf['name']]['ipv6_routing'] = True
                          config['ipv6_routing'] = True
                      # multicast
                      if get(vrf, "_evpn_l3_multicast_enabled"):
                          config["router_multicast"]["vrfs"].append({
                              "name": vrf['name'],
                              "ipv4": {
                                  "routing": True
                              }
                          })

                          # pim rps
                          vrf_rps = get(vrf, "_pim_rp_addresses")
                          if vrf_rps:
                              config["router_pim_sparse_mode"]["vrfs"].append(
                                  {
                                      "name": vrf["name"],
                                      "ipv4": {
                                          "rp_addresses": vrf_rps,
                                      }
                                  }
                              )

                      # configure static routes
                      if vrf.get('static_routes') is not None:
                          for static_route in vrf['static_routes']:
                              sr = {
                                  "destination_address_prefix": static_route['destination_address_prefix'],
                                  "vrf": vrf['name']
                              }
                              if static_route.get('gateway') and static_route['gateway'].strip() != "":
                                  sr['gateway'] = static_route['gateway']
                              if static_route.get('distance'):
                                  sr['distance'] = str(static_route['distance'])
                              if static_route.get('tag'):
                                  sr['tag'] = str(static_route['tag'])
                              if static_route.get('name') and static_route['name'].strip() != "":
                                  sr['name'] = static_route['name']
                              if static_route.get('metric'):
                                  sr['metric'] = str(static_route['metric'])
                              if static_route.get('interface') and static_route['interface'].strip() != "":
                                  sr['interface'] = static_route['interface']
                              config['static_routes'].append(sr)

                      # configure static routes for VARP
                      for svi in vrf.get("svis", []):
                          for ip_ver in ['v4', 'v6']:
                              if f"ip_virtual_router_addresses_{ip_ver}" not in svi or f"ip_address_{ip_ver}" not in svi:
                                  # Skip svi if VARP is not set or if
                                  # there is no unique ip_address
                                  continue
                              for virtual_router_address in svi[f"ip_virtual_router_addresses_{ip_ver}"]:
                                  if "/" not in virtual_router_address:
                                      # Only create static routes for
                                      # VARP entries with masks
                                      continue
                                  config['static_routes'].append(
                                      {
                                          "destination_address_prefix": str(
                                              ipaddress.ip_network(
                                              virtual_router_address,
                                              strict=False)),
                                          "vrf": vrf["name"],
                                          "name": "VARP",
                                          "interface": f"Vlan{svi['id']}",
                                      }
                                  )

                      # configure ethernet interfaces
                      if vrf.get('l3_interfaces') is not None:
                          l3_interface_subif_parents = []
                          for l3_iface in vrf['l3_interfaces']:
                              eth_iface = {}
                              l3_interface_subif_id = None
                              if "." in l3_iface['interfaces'][0]:
                                  if l3_iface.get('encapsulation_dot1q_vlan'):
                                      l3_interface_subif_id = l3_iface['encapsulation_dot1q_vlan']
                                  else:
                                      l3_interface_subif_id = l3_iface['interfaces'][0].split('.')[1]
                                  l3_interface_subif_parents.append(l3_iface['interfaces'][0].split('.')[0])
                              if l3_interface_subif_id is not None:
                                  eth_iface['type'] = "l3dot1q"
                                  eth_iface['encapsulation_dot1q_vlan'] = l3_interface_subif_id
                              else:
                                  eth_iface['type'] = "routed"
                              eth_iface['peer_type'] = "l3_interface"
                              eth_iface['vrf'] = vrf['name']
                              if vrf.get('v4_routing'):
                                  eth_iface['ip_address_v4'] = l3_iface['ip_addresses_v4'][0]
                              if vrf.get('v6_routing'):
                                  eth_iface['ip_address_v6'] = l3_iface['ip_addresses_v6'][0]
                              if l3_iface.get('mtu'):
                                  eth_iface['mtu'] = l3_iface['mtu']
                              if l3_iface.get('enabled') is not None:
                                  eth_iface['shutdown'] = not l3_iface["enabled"]
                              if l3_iface.get('description') and l3_iface['description'].strip() != "":
                                  eth_iface['description'] = l3_iface['description']
                              if l3_iface.get('raw_eos_cli'):
                                  eth_iface['eos_cli'] = l3_iface['raw_eos_cli']
                              config['ethernet_interfaces'][l3_iface['interfaces'][0]] = eth_iface
                          for parent_iface in l3_interface_subif_parents:
                              config['ethernet_interfaces'][parent_iface] = {
                                  "type": "routed",
                                  "peer_type": "l3_interface",
                                  "shutdown": False
                              }

                      # configure route maps
                      if vrf.get('bgp_peers'):
                          for peer, peer_info in vrf['bgp_peers'].items():
                              if peer_info.get('set_ip_next_hop'):
                                  config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"] = {
                                      "sequence_numbers": {
                                          10: {
                                              "type": "permit",
                                              "set": []
                                          }
                                      }
                                  }
                                  if is_ipv4(peer_info['set_ip_next_hop']):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ip next-hop {peer_info['set_ip_next_hop']}")
                                  elif is_ipv6(peer_info['set_ip_next_hop']):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ipv6 next-hop {peer_info['set_ip_next_hop']}")

              # configure interfaces
              for tenant in network_services_data['tenants']:
                  for vrf in tenant.get('vrfs', []):
                      # set and configure vtep diagnostic loopback interfaces
                      if vrf.get('vtep_diagnostic') and (
                          loopback_id := vrf['vtep_diagnostic']['loopback'] ):
                          config['loopback_interfaces'][f"Loopback{loopback_id}"] = {
                              "description": f"{vrf['name']}_VTEP_DIAGNOSTICS",
                              "shutdown": False,
                              "vrf": vrf['name'],
                          }
                          if loopback_ipv4_pool := vrf['vtep_diagnostic']['loopback_ip_range']:
                              loopback_ipv4_network = ipaddress.ip_network(loopback_ipv4_pool)
                              index = int(switch_facts['id']) - 1
                              loopback_ipv4 = get_ip_from_subnet(
                                                  loopback_ipv4_network,
                                                  index,
                                                  switch_facts['hostname'])
                              config['loopback_interfaces'][f"Loopback{loopback_id}"]['ip_address_v4'] = f"{loopback_ipv4}/32"
                              # Set virtual-source-nat-vrfs
                              config['virtual_source_nat_vrfs'][vrf['name']] = {
                                  "ip_address_v4": loopback_ipv4
                              }
                      if switch_facts['network_services_l2'] and switch_facts['network_services_l3']:
                          # configure svis
                          for svi in vrf.get('svis', []):
                              config['vlan_interfaces'][f"Vlan{svi['id']}"]['tenant'] = tenant['name']
                              config['vlan_interfaces'][f"Vlan{svi['id']}"]['vrf'] = vrf['name']

                              # Configure VIP and IP
                              set_network_services_config_l3_svi_ips(
                                  config, svi, 'v4')
                              set_network_services_config_l3_svi_ips(
                                  config, svi, 'v6')

                              if svi.get('ip_helpers'):
                                  config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_helpers'] = {}
                                  for helper_address, dhcp_info in svi['ip_helpers'].items():
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['ip_helpers'][helper_address] = {
                                          "source_interface": dhcp_info.get('source_interface')
                                      }
                              # if mtu
                              if svi.get('mtu'):
                                  config['vlan_interfaces'][f"Vlan{svi['id']}"]['mtu'] = svi['mtu']
                              # if arp aging timeout
                              if svi.get('arp'):
                                  if svi['arp'].get('aging_timeout'):
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]['arp_aging_timeout'] = svi['arp']['aging_timeout']

                              # multicast
                              pim_config_ipv4 = {}
                              if default(get(svi, "evpn_l3_multicast.enabled"), get(vrf, "_evpn_l3_multicast_enabled")) is True:
                                  if switch_facts.get("mlag"):
                                      pim_config_ipv4["sparse_mode"] = True
                                  else:
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]["ip_igmp"] = True

                                  if "ip_address_virtual_v4" in config['vlan_interfaces'][f"Vlan{svi['id']}"]:
                                      vrf_diagnostic_loopback = get(vrf, "vtep_diagnostic.loopback")
                                      if vrf_diagnostic_loopback is None:
                                          raise Exception(
                                              f"No vtep_diagnostic loopback defined on VRF '{vrf['name']}' in Tenant '{tenant['name']}'."
                                              "This is required when 'l3_multicast' is enabled on the VRF and ip_address_virtual is used on an SVI in that VRF."
                                          )
                                      pim_config_ipv4["local_interface"] = f"Loopback{vrf_diagnostic_loopback}"

                                  if pim_config_ipv4:
                                      config['vlan_interfaces'][f"Vlan{svi['id']}"]["pim"] = {"ipv4": pim_config_ipv4}

                              # configure eos_cli statements
                              config['vlan_interfaces'][f"Vlan{svi['id']}"]['eos_cli'] = svi['eos_cli']

                      # configure vrf ibgp mlag peer interface
                      if switch_facts.get('mlag') and vrf.get('enable_mlag_ibgp_peering_vrfs'):
                          ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                          config['vlan_interfaces'][f"Vlan{ibgp_vlan}"] = {
                              "tenant": tenant['name'],
                              "type": "underlay_peering",
                              "shutdown": False,
                              "mtu": 9214,
                              "description": f"MLAG_PEER_L3_iBGP:{vrf['name']}",
                              "vrf": vrf['name'],
                          }
                          for version in ['v4', 'v6']:
                              ibgp_peering_subnet = vrf.get(f'mlag_ibgp_peering_subnet_{version}')
                              ibgp_peering_subnet_mask = vrf.get(f'mlag_ibgp_peering_subnet_mask_{version}')
                              if ( not ibgp_peering_subnet or
                                   not ibgp_peering_subnet_mask ):
                                  continue
                              # TBD isn't it already in vrf, why recompute?
                              mlag_ip = str(get_mlag_ip(
                                      switch_facts,
                                      ibgp_peering_subnet,
                                      ibgp_peering_subnet_mask,
                                      switch_facts['mlag_role']
                                      )
                                  )
                              config['vlan_interfaces'][f"Vlan{ibgp_vlan}"][f"ip_address_{version}"] = f"{mlag_ip}/{ibgp_peering_subnet_mask}"
                          # Reset mtu to 1500 if veos
                          if re.match(veos_regex, switch_facts['platform']):
                              config['vlan_interfaces'][f"Vlan{ibgp_vlan}"]['mtu'] = None
                          if "MLAG_VRF_PEER" not in (config['port_channel_interfaces']
                                                    [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                                                    ['trunk_groups']):
                              (config['port_channel_interfaces']
                              [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                              ['trunk_groups']).append("MLAG_VRF_PEER")
              return config


          @ctx.benchmark
          def set_network_services_config_router(config, switch_facts, network_services_data):
              @ctx.benchmark
              def set_config_router_tenant_bgp_L3(tenant, config, switch_facts):
                  for vrf in tenant.get('vrfs', []):
                      # initialize vrf
                      config['router_bgp']['vrfs'][vrf['name']] = {
                          "router_id": switch_facts.get('router_id'),
                          "neighbors": {},
                          "redistribute_routes": {
                              "connected": {}
                              # "attached-host": {}
                          },
                          "address_families": {
                              "ipv4": {"neighbors": {}, "networks": {}},
                              "ipv6": {"neighbors": {}, "networks": {}}
                          },
                          "eos_cli": []
                      }
                      # set general bgp
                      if vrf.get('bgp') and vrf['bgp'].get('raw_eos_cli'):
                          config['router_bgp']['vrfs'][vrf['name']]['eos_cli'] = vrf['bgp']['raw_eos_cli']

              # bgp router for non-vxlan
              if switch_facts['network_services_l3'] and switch_facts.get('bgp_as'):
                  config['router_bgp']['vrfs'] = {}
                  config['router_bgp']['vlans'] = {}
                  config['router_bgp']['vlan_aware_bundles'] = {}
                  for tenant in network_services_data["tenants"]:
                      set_config_router_tenant_bgp_L3(tenant, config, switch_facts)
              return config


          @ctx.benchmark
          def set_network_services_config_vtep(config, switch_facts, network_services_data):
              @ctx.benchmark
              def get_lower_2B_asn(switch_facts):
                  return (splitasn[1] if (len(
                      (splitasn := switch_facts.get(
                      'bgp_as').split('.'))) > 1) else switch_facts.get(
                      'bgp_as'))

              @ctx.benchmark
              def get_upper_2B_asn(switch_facts):
                  return (splitasn[0] if (len(
                      (splitasn := switch_facts.get(
                      'bgp_as').split('.'))) > 1) else switch_facts.get(
                      'bgp_as'))

              @ctx.benchmark
              def vlan_based_mac_vrf_admin_field_xlate(format, vlan,
                  switch_facts):
                  match format:
                      case 'VNI':
                          return vlan['vni']
                      case 'VLAN':
                          return vlan['id']
                      case 'Router-ID':
                          return switch_facts['router_id']
                      case 'VTEP Source IP':
                          return switch_facts['vtep_ip']
                      case 'Lower-2B-ASN':
                          return get_lower_2B_asn(switch_facts)
                      case 'Upper-2B-ASN':
                          return get_upper_2B_asn(switch_facts)
                      case _:
                          return None

              @ctx.benchmark
              def vlan_bundle_based_mac_vrf_admin_field_xlate(format, bundle,
                  switch_facts):
                  match format:
                      case "First-VLAN":
                          return bundle['first_vlan']
                      case "First-VNI":
                          return bundle['first_vni']
                      case "Last-VLAN":
                          return bundle['last_vlan']
                      case "Last-VNI":
                          return bundle['last_vni']
                      case "Router-ID":
                          return switch_facts['router_id']
                      case "VTEP Source IP":
                          return switch_facts['vtep_ip']
                      case 'Lower-2B-ASN':
                          return get_lower_2B_asn(switch_facts)
                      case 'Upper-2B-ASN':
                          return get_upper_2B_asn(switch_facts)
                      case _:
                          return None

              @ctx.benchmark
              def ip_vrf_admin_field_xlate(format, vrf,
                  switch_facts):
                  match format:
                      case "VNI":
                          return vrf['vni']
                      case "Router-ID":
                          return switch_facts['router_id']
                      case "VTEP Source IP":
                          return switch_facts['vtep_ip']
                      case 'Lower-2B-ASN':
                          return get_lower_2B_asn(switch_facts)
                      case 'Upper-2B-ASN':
                          return get_upper_2B_asn(switch_facts)
                      case _:
                          return None

              @ctx.benchmark
              def prepare_vtep_tenant_mcast(tenant, switch_facts, isL3, vlan):
                  if isL3:
                      # for backward compatibility cannot add l2 mcast to l3 vlans by default
                      vlan_evpn_l2_multicast_enabled = default(get(tenant, "evpn_l2_multicast.enabledSvis"), get(tenant, "evpn_l2_multicast.enabled"))
                  else:
                      vlan_evpn_l2_multicast_enabled = default(get(vlan, "evpn_l2_multicast.enabled"), get(tenant, "evpn_l2_multicast.enabled"))
                  if vlan_evpn_l2_multicast_enabled is True:
                      mcast_pool = get(
                          tenant,
                          "evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool",
                          required=True,
                          org_key=f"'evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool' for Tenant: {tenant['name']}",
                      )
                      assert mcast_pool, (
                          f"Tenant {tenant.get('name')} VLAN {vlan.get('id')} "
                          f"has L2 multicast enabled without specifying "
                          f"the requisite tenant L2 Multicast Group Pool" )
                      offset = vlan['id'] - 1 + get(tenant, "evpn_l2_multicast.underlay_l2_multicast_group_ipv4_pool_offset", default=0)
                      underlay_group_address = get_ip(mcast_pool, 32, offset, 0)
                      vlan["multicast_group"] = underlay_group_address

              @ctx.benchmark
              def prepare_vtep_tenant_L3(tenant, switch_facts):
                  @ctx.benchmark
                  def prepare_vtep_tenant_vrf_general(tenant, vrf, switch_facts):
                      # Set vrf rd
                      switch_rd = []
                      for rd_segment in vrf['route_distinguisher'].split(":"):
                          if xlated := ip_vrf_admin_field_xlate(
                              rd_segment, vrf, switch_facts):
                              rd_segment = str(xlated)
                          switch_rd.append(rd_segment)
                      vrf['route_distinguisher'] = ":".join(switch_rd)
                      # Set vrf rt
                      switch_rt = []
                      for rt_segment in vrf['route_target'].split(":"):
                          if xlated := ip_vrf_admin_field_xlate(
                              rt_segment, vrf, switch_facts):
                              rt_segment = str(xlated)
                          switch_rt.append(rt_segment)
                      vrf['route_target'] = ":".join(switch_rt)
                      # Set l3 multicast group
                      if vrf.get("_evpn_l3_multicast_enabled") and tenant.get("evpn_l3_multicast"):
                          mcast_pool = tenant["evpn_l3_multicast"]["evpn_underlay_l3_multicast_group_ipv4_pool"]
                          assert mcast_pool, (
                              f"Tenant {tenant.get('name')} VRF {vrf.get('name')} "
                              f"has L3 multicast enabled without specifying "
                              f"the requisite tenant L3 Multicast Group Pool" )
                          offset = vrf['vni'] - 1 + tenant["evpn_l3_multicast"].get("evpn_underlay_l3_multicast_group_ipv4_pool_offset", 0)
                          underlay_group_address = get_ip(mcast_pool, 32, offset, 0)
                          vrf["multicast_group"] = underlay_group_address

                  @ctx.benchmark
                  def prepare_vtep_tenant_vrf_vlans(vrf, switch_facts):
                      # Set L3 vlans
                      for vlan in vrf.get("svis", []):
                          if not vlan["vxlan"]:
                              continue
                          # Set vlan rd
                          switch_rd = []
                          for rd_segment in vlan['route_distinguisher'].split(":"):
                              if xlated := vlan_based_mac_vrf_admin_field_xlate(
                                  rd_segment, vlan, switch_facts):
                                  rd_segment = str(xlated)
                              switch_rd.append(rd_segment)
                          vlan['route_distinguisher'] = ":".join(switch_rd)
                          # Set vlan rts
                          switch_rt = []  # For both import/export rt
                          for i, rt_segment in enumerate(vlan['route_target'].split(":")):
                              if xlated := vlan_based_mac_vrf_admin_field_xlate(
                                  rt_segment, vlan, switch_facts):
                                  rt_segment = str(xlated)
                              switch_rt.append(rt_segment)
                          vlan['route_target'] = ":".join(switch_rt)
                          if switch_facts.get('evpn_gateway_vxlan_l2'):
                              vlan['rd_evpn_domain'] = {
                                  "domain": "remote",
                                  "rd": ":".join(switch_rd)
                              }
                              vlan['import_export_evpn_domains'] = [
                                  {
                                      "domain": "remote",
                                      "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else None
                                  }
                              ]
                          # Set L2 mcast on SVIs
                          prepare_vtep_tenant_mcast(tenant, switch_facts, True, vlan)

                  # Set vrfs
                  for vrf in tenant.get("vrfs", []):
                      if vrf["name"] != "default":
                          prepare_vtep_tenant_vrf_general(tenant, vrf, switch_facts)
                      prepare_vtep_tenant_vrf_vlans(vrf, switch_facts)

              @ctx.benchmark
              def prepare_vtep_tenant_L2(tenant, switch_facts):
                  # Set L2 vlans
                  for vlan in tenant.get("l2vlans", []):
                      if not vlan["vxlan"]:
                          continue
                      prepare_vtep_tenant_mcast(tenant, switch_facts, False, vlan)
                      # Set vlan rd
                      switch_rd = []
                      for rd_segment in vlan['route_distinguisher'].split(":"):
                          if xlated := vlan_based_mac_vrf_admin_field_xlate(
                              rd_segment, vlan, switch_facts):
                              rd_segment = str(xlated)
                          switch_rd.append(rd_segment)
                      vlan['route_distinguisher'] = ":".join(switch_rd)
                      # Set vlan rt
                      switch_rt = []  # For both import/export rt
                      switch_import_rt = []  # For only import rt
                      switch_export_rt = []  # For only export rt
                      for i, rt_segment in enumerate(vlan['route_target'].split(":")):
                          if xlated := vlan_based_mac_vrf_admin_field_xlate(
                              rt_segment, vlan, switch_facts):
                              rt_segment = str(xlated)
                          # Format for etree switches
                          if not vlan.get('etree_role'):
                              switch_rt.append(rt_segment)
                          else:
                              leaf_rt_segment = str(vlan['etree_leaf_export_rt_offset'] + int(rt_segment)) if i % 2 == 1 else rt_segment
                              if vlan["etree_role"] == 'root':
                                  switch_rt.append(rt_segment)
                                  switch_import_rt.append(leaf_rt_segment)
                              else:
                                  switch_import_rt.append(rt_segment)
                                  switch_export_rt.append(leaf_rt_segment)
                                  switch_rt = []

                      vlan['route_target'] = ":".join(switch_rt) if len(switch_rt) > 0 else None
                      vlan['import_route_target'] = ":".join(switch_import_rt) if len(switch_import_rt) > 0 else None
                      vlan['export_route_target'] = ":".join(switch_export_rt) if len(switch_export_rt) > 0 else None
                      if switch_facts.get('evpn_gateway_vxlan_l2'):
                          vlan['rd_evpn_domain'] = {
                              "domain": "remote",
                              "rd": ":".join(switch_rd)
                          }
                          vlan['import_export_evpn_domains'] = [
                              {
                                  "domain": "remote",
                                  "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else None
                              }
                          ]

              @ctx.benchmark
              def prepare_vtep_tenant_bundles(tenant, switch_facts):
                  # Set vlan_aware_bundles
                  for bundle in tenant.get('vlan_aware_bundles', []):
                      # Set bundle rd
                      switch_rd = []
                      for rd_segment in bundle['route_distinguisher'].split(":"):
                          if xlated := vlan_bundle_based_mac_vrf_admin_field_xlate(
                              rd_segment, bundle, switch_facts):
                              rd_segment = str(xlated)
                          switch_rd.append(rd_segment)
                      bundle['route_distinguisher'] = ":".join(switch_rd)
                      # Set bundle rt
                      switch_rt = []
                      for rt_segment in bundle['route_target'].split(":"):
                          if xlated := vlan_bundle_based_mac_vrf_admin_field_xlate(
                              rt_segment, bundle, switch_facts):
                              rt_segment = str(xlated)
                          switch_rt.append(rt_segment)
                      bundle['route_target'] = ":".join(switch_rt)
                      if switch_facts.get('evpn_gateway_vxlan_l2'):
                          bundle['rd_evpn_domain'] = {
                              "domain": "remote",
                              "rd": ":".join(switch_rd)
                          }
                          bundle['import_export_evpn_domains'] = [
                              {
                                  "domain": "remote",
                                  "route_target": ":".join(switch_rt) if len(switch_rt) > 0 else None
                              }
                          ]

              @ctx.benchmark
              def set_config_vtep_tenant_bgp_L3(tenant, config, switch_facts):
                  # Set vrfs
                  for vrf in tenant.get('vrfs', []):
                      address_family_neighbors = {}
                      address_family_neighbors['v4'] = []
                      address_family_neighbors['v6'] = []
                      try:
                          if vrf['name'] == "default":
                              route_distinguisher = None
                              route_targets = None
                          else:
                              route_distinguisher = vrf['route_distinguisher']
                              route_targets = {
                                  "import": {
                                      "evpn": [vrf['route_target']]
                                  },
                                  "export": {
                                      "evpn": [vrf['route_target']]
                                  }
                              }
                              # additional route targets
                              if vrf.get('additional_route_targets'):
                                  for rt in natural_sort(vrf['additional_route_targets']):
                                      if rt.get('address_family') \
                                              and rt.get('route_target') \
                                              and rt.get('type'):
                                          if rt['address_family'] in route_targets[rt['type']].keys():
                                              route_targets[rt['type']][rt['address_family']].append(rt['route_target'])
                                          else:
                                              route_targets[rt['type']].update({rt['address_family']: rt['route_target']})
                      except Exception as e:
                          assert False, f"{switch_facts['hostname']} is having an issue with {vrf['name']} vrf: {e}"
                      # initialize vrf
                      config['router_bgp']['vrfs'][vrf['name']] = {
                          "router_id": switch_facts['router_id'],
                          "rd": route_distinguisher,
                          "route_targets": route_targets,
                          "neighbors": {},
                          "redistribute_routes": {
                              "connected": {}
                              # "attached-host": {}
                          },
                          "address_families": {
                              "ipv4": {"neighbors": {}, "networks": {}},
                              "ipv6": {"neighbors": {}, "networks": {}}
                          },
                          "evpn_multicast": get(vrf, "_evpn_l3_multicast_enabled"),
                          "eos_cli": []
                      }
                      # set mlag peer config
                      mlag_peer_sn = switch_facts.get('mlag_peer_serial_number')
                      if switch_facts.get('mlag') and mlag_peer_sn and vrf.get(
                          'enable_mlag_ibgp_peering_vrfs'):
                          mlag_peer_switch_facts = my_neighbors_switch_facts[mlag_peer_sn]
                          ibgp_vlan = vrf['mlag_ibgp_peering_vlan']
                          for version in ['v4', 'v6']:
                              ibgp_peering_subnet = vrf.get(f'mlag_ibgp_peering_subnet_{version}')
                              ibgp_peering_subnet_mask = vrf.get(f'mlag_ibgp_peering_subnet_mask_{version}')
                              if ( not ibgp_peering_subnet or
                                   not ibgp_peering_subnet_mask ):
                                  continue
                              # TBD isn't it already in vrf, why recompute?
                              mlag_peer_ip = str(get_mlag_ip(
                                      switch_facts,
                                      ibgp_peering_subnet,
                                      ibgp_peering_subnet_mask,
                                      mlag_peer_switch_facts['mlag_role']
                                      )
                                  )
                              # Add mlag_ip to neighbors and address family
                              config['router_bgp']['vrfs'][vrf['name']]['neighbors'][mlag_peer_ip] = {
                                  "remote_as": switch_facts['bgp_as'],
                                  "description": mlag_peer_switch_facts['hostname'],
                                  "send_community": "all",
                                  "next_hop_self": True,
                              }
                              address_family_neighbors[version].append(mlag_peer_ip)
                      # set external bgp peers
                      if vrf.get('bgp_peers'):
                          for peer, peer_info in vrf['bgp_peers'].items():
                              if is_ipv4(peer):
                                  address_family_neighbors['v4'].append(peer)
                              elif is_ipv6(peer):
                                  address_family_neighbors['v6'].append(peer)
                              else:
                                  continue
                              if peer_info.get('set_ip_next_hop'):
                                  peer_info.update({"route_map_out": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"})
                                  if peer_info.get('default_originate'):
                                      if not peer_info['default_originate'].get('route_map'):
                                          peer_info['default_originate'].update(
                                              {"route_map": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"}
                                          )
                                  peer_info.pop("set_ip_next_hop")
                              config['router_bgp']['vrfs'][vrf['name']]['neighbors'][peer] = peer_info
                      # set general bgp
                      if vrf.get('bgp') and vrf['bgp'].get('raw_eos_cli'):
                          config['router_bgp']['vrfs'][vrf['name']]['eos_cli'] = vrf['bgp']['raw_eos_cli']

                      # redistribute static routes
                      if vrf.get('redistribute_static'):
                          config['router_bgp']['vrfs'][vrf['name']]['redistribute_routes']['static'] = {}
                      # activate neighbors for ipv4 address family
                      if len(address_family_neighbors['v4']) > 0:
                          for neighbor in address_family_neighbors['v4']:
                              config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv4']['neighbors'][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv4'])
                      # activate neighbors for ipv6 address family
                      if len(address_family_neighbors['v6']) > 0:
                          for neighbor in address_family_neighbors['v6']:
                              config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv6']['neighbors'][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config['router_bgp']['vrfs'][vrf['name']]['address_families']['ipv6'])

                      # multicast
                      evpn_multicast_transit_mode = get(vrf, "_evpn_l3_multicast_evpn_peg_transit")
                      if evpn_multicast_transit_mode is True:
                          config['router_bgp']['vrfs'][vrf['name']]["evpn_multicast_address_family"] = {"ipv4": {"transit": evpn_multicast_transit_mode}}

                      # Set l3 vlans
                      for svi in vrf.get('svis', []):
                          if svi['vxlan'] == False:
                              continue
                          vlan_in_bundle = False
                          for bundle in tenant.get('vlan_aware_bundles', []):
                              if svi['id'] in string_to_list(bundle['vlan_range']):
                                  vlan_in_bundle = True
                                  break
                          if vlan_in_bundle is True:
                              continue
                          config['router_bgp']['vlans'][svi['id']] = {
                              "tenant": tenant['name'],
                              "rd": svi['route_distinguisher'],
                              "route_targets": {},
                              "redistribute_routes": {
                                  "learned": {}
                              }
                          }
                          if svi.get('redistribute_learned'):
                              del(config['router_bgp']['vlans'][svi['id']]['redistribute_routes']['learned'])
                          if svi.get("multicast_group"):
                              config['router_bgp']['vlans'][svi['id']]["redistribute_routes"]["igmp"] = {}
                          if svi.get('bgp_eos_cli'):
                              config['router_bgp']['vlans'][svi['id']]['bgp_eos_cli'] = svi['bgp_eos_cli']
                          if svi.get('rd_evpn_domain'):
                              config['router_bgp']['vlans'][svi['id']]['rd_evpn_domain'] = svi['rd_evpn_domain']
                          # Set route targets
                          config['router_bgp']['vlans'][svi['id']]['route_targets']['both'] = [svi['route_target']] if svi.get('route_target') else None
                          config['router_bgp']['vlans'][svi['id']]['route_targets']['import'] = [svi['import_route_target']] if svi.get('import_route_target') else None
                          config['router_bgp']['vlans'][svi['id']]['route_targets']['export'] = [svi['export_route_target']] if svi.get('export_route_target') else None
                          if svi.get('import_export_evpn_domains'):
                              config['router_bgp']['vlans'][svi['id']]['route_targets']['import_export_evpn_domains'] = svi['import_export_evpn_domains']

              @ctx.benchmark
              def set_config_vtep_tenant_bgp_L2(tenant, config):
                  # Set l2 vlans
                  for l2vlan in tenant.get('l2vlans', []):
                      if l2vlan['vxlan'] == False:
                          continue
                      vlan_in_bundle = False
                      for bundle in tenant.get('vlan_aware_bundles', []):
                          if l2vlan['id'] in string_to_list(bundle['vlan_range']):
                              if l2vlan.get("multicast_group"):
                                  bundle['vlan_evpn_l2_multicast_enabled'] = True
                              vlan_in_bundle = True
                              break
                      if vlan_in_bundle is True:
                          continue
                      config['router_bgp']['vlans'][l2vlan['id']] = {
                          "tenant": tenant['name'],
                          "rd": l2vlan['route_distinguisher'],
                          "route_targets": {},
                          "redistribute_routes": {
                              "learned": {}
                          }
                      }
                      if l2vlan.get('redistribute_learned'):
                          del(config['router_bgp']['vlans'][l2vlan['id']]['redistribute_routes']['learned'])
                      if l2vlan.get('bgp_eos_cli'):
                          config['router_bgp']['vlans'][l2vlan['id']]['bgp_eos_cli'] = l2vlan['bgp_eos_cli']
                      if l2vlan.get('rd_evpn_domain'):
                          config['router_bgp']['vlans'][l2vlan['id']]['rd_evpn_domain'] = l2vlan['rd_evpn_domain']
                      # Set route targets
                      config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['both'] = [l2vlan['route_target']] if l2vlan.get('route_target') else None
                      config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['import'] = [l2vlan['import_route_target']] if l2vlan.get('import_route_target') else None
                      config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['export'] = [l2vlan['export_route_target']] if l2vlan.get('export_route_target') else None
                      if l2vlan.get('import_export_evpn_domains'):
                          config['router_bgp']['vlans'][l2vlan['id']]['route_targets']['import_export_evpn_domains'] = l2vlan['import_export_evpn_domains']

                      if l2vlan.get("multicast_group"):
                          config['router_bgp']['vlans'][l2vlan['id']]["redistribute_routes"]["igmp"] = {}

              @ctx.benchmark
              def set_config_vtep_tenant_bgp_bundles(tenant, config):
                  # Set vlan aware bundles
                  for bundle in tenant.get('vlan_aware_bundles', []):
                      config['router_bgp']['vlan_aware_bundles'][bundle['name']] = {
                          "rd": bundle['route_distinguisher'],
                          "route_targets": {
                              "both": [bundle['route_target']]
                          },
                          "vlan": bundle['vlan_range'],
                          "redistribute_routes": [
                              "learned"
                          ]
                      }
                      if bundle.get('redistribute_learned'):
                          config['router_bgp']['vlan_aware_bundles'][bundle['name']]['redistribute_routes'].remove("learned")
                      if bundle.get('bgp_eos_cli'):
                          config['router_bgp']['vlan_aware_bundles'][bundle['name']]['bgp_eos_cli'] = bundle['bgp_eos_cli']
                      if bundle.get('rd_evpn_domain'):
                          config['router_bgp']['vlan_aware_bundles'][bundle['name']]['rd_evpn_domain'] = bundle['rd_evpn_domain']
                      if bundle.get('import_export_evpn_domains'):
                          config['router_bgp']['vlan_aware_bundles'][bundle['name']]['route_targets']['import_export_evpn_domains'] = bundle['import_export_evpn_domains']
                      if bundle.get("vlan_evpn_l2_multicast_enabled"):
                          config['router_bgp']['vlan_aware_bundles'][bundle['name']]["redistribute_routes"].append("igmp")

              @ctx.benchmark
              def set_config_vtep_tenant_vxlan_vrf(tenant, config, l3vlan_vnis):
                  for vrf in tenant.get('vrfs', []):
                      if vrf['name'] != "default":
                          # map vrfs to vnis
                          config['vxlan_interface']['Vxlan1']['vxlan']['vrfs'][vrf['name']] = {
                              "vni": vrf['vni']
                          }
                          if vrf.get("multicast_group"):
                              config['vxlan_interface']['Vxlan1']['vxlan']['vrfs'][vrf['name']]["multicast_group"] = vrf["multicast_group"]
                      # map l3vlans to vnis
                      for svi in vrf.get('svis', []):
                          if not svi.get('vni') or not svi['vxlan']:
                              continue
                          config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][svi['id']] = {
                              "vni": svi['vni']
                          }
                          # for L2 mcast on SVIs
                          if svi.get("multicast_group"):
                              config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][svi['id']]["multicast_group"] = svi["multicast_group"]
                          l3vlan_vnis[svi['id']] = svi['vni']

              @ctx.benchmark
              def set_config_vtep_tenant_vxlan_L2(tenant, config, l2vlan_vnis):
                  # map l2vlans to vnis
                  for l2vlan in tenant.get('l2vlans', []):
                      if not l2vlan.get('vni') or not l2vlan['vxlan']:
                          continue
                      config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][l2vlan['id']] = {
                          "vni": l2vlan['vni']
                      }
                      l2vlan_vnis[l2vlan['id']] = l2vlan['vni']
                      if l2vlan.get("multicast_group"):
                          config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][l2vlan['id']]["multicast_group"] = l2vlan["multicast_group"]

              # Start of set_network_services_config_vtep()
              #
              # Prepare tenants for config
              for tenant in network_services_data["tenants"]:
                  prepare_vtep_tenant_L3(tenant, switch_facts)
                  prepare_vtep_tenant_L2(tenant, switch_facts)
                  prepare_vtep_tenant_bundles(tenant, switch_facts)

              # Set bgp
              if switch_facts['network_services_l3']:
                  config['router_bgp']['vrfs'] = {}
                  config['router_bgp']['vlans'] = {}
                  config['router_bgp']['vlan_aware_bundles'] = {}
                  for tenant in network_services_data["tenants"]:
                      set_config_vtep_tenant_bgp_L3(tenant, config,
                                             switch_facts)
                      set_config_vtep_tenant_bgp_L2(tenant, config)
                      set_config_vtep_tenant_bgp_bundles(tenant, config)

              # Set vxlan interface
              config['vxlan_interface'] = {"Vxlan1": {"vxlan": {"vrfs": {}, "vlans": {}}}}
              l3vlan_vnis = {}
              l2vlan_vnis = {}
              for tenant in network_services_data["tenants"]:
                  set_config_vtep_tenant_vxlan_vrf(tenant, config, l3vlan_vnis)
                  set_config_vtep_tenant_vxlan_L2(tenant, config, l2vlan_vnis)

              if fabric_variables.get('summarizeVlanVnis'):
                  config['vxlan_interface']['Vxlan1']['vxlan']['vlan_vni_ranges'] = summarize_ranges(l3vlan_vnis | l2vlan_vnis)
              return config


          @ctx.benchmark
          def set_network_services_config(config, switch_facts):
              # logic (Probably will be easier to break away from AVD logic)
              network_services_data = {}
              network_services_data["tenants"] = get_network_services_config_raw_data(config, switch_facts)

              # Log network services data
              # ctx.info(f"Raw Network Services Data: {json.dumps(network_services_data, sort_keys=True, indent=4)}")

              # Configure vlans
              if switch_facts['network_services_l2']:
                  config = set_network_services_config_vlans(config,
                               switch_facts, network_services_data)

              # Configure mlag
              if switch_facts.get('mlag'):
                  # Initialize mlag port-channel interface for ibgp trunk groups
                  config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"] = {"trunk_groups": []}

              # Configure L3
              if switch_facts['network_services_l3']:
                  config = set_network_services_config_l3(config, switch_facts, network_services_data)

              # Configure routing protocol instance
              if switch_facts.get('vtep'):
                  config = set_network_services_config_vtep(config, switch_facts, network_services_data)
              else:
                  config = set_network_services_config_router(config, switch_facts, network_services_data)

              # clean up unnecessary config elements
              if switch_facts.get('mlag') \
                      and config['port_channel_interfaces'].get(f"Port-Channel{switch_facts['mlag_port_channel_id']}") \
                      and len(
                          config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"]['trunk_groups']
                          ) == 0:
                  del(config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"])

              # Clear dhcp snooping config if veos
              if re.match(veos_regex, switch_facts['platform']) and config.get('ip_dhcp_snooping'):
                  del config['ip_dhcp_snooping']

              return config


          @ctx.benchmark
          def validate_facts(switch_facts):
              if switch_facts.get('vtep'):
                  assert switch_facts.get('bgp_as') is not None, f"BGP ASN is not set.  Please apply a 'router_bgp.as' tag to " \
                                                                 f"{switch_facts['hostname']} in the Tags section of Provisioning " \
                                                                 f"with the appropriate workspace selected."
                  assert switch_facts.get('router_id') is not None, f"BGP Router ID is not set.  Please apply a 'router_bgp.router_id' " \
                                                                    f"tag to {switch_facts['hostname']} in the Tags section of " \
                                                                    f"Provisioning with the appropriate workspace selected."
              if switch_facts.get('mlag') is True:
                  assert switch_facts.get('mlag_port_channel_id') is not None, f"MLAG Peer Link is not set.  Please apply a " \
                                                                               f"'mlag_configuration.peer_link' tag to " \
                                                                               f"{switch_facts['hostname']} in the Tags " \
                                                                               f"'section of Provisioning with the appropriate " \
                                                                               f"workspace selected"


          @ctx.benchmark
          def get_interfaces_info(switch_facts):
              device_id = switch_facts['serial_number']
              interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None and "Ethernet" in i.name:
                      interfaces[i.name] = {
                          "neighborId": peer_device.id,
                          "neighborHostname": peer_device.hostName,
                          "neighborInterface": peer_interface.name
                      }
              return interfaces


          @ctx.benchmark
          def get_mlag_peer(switch_facts):
              mlag_peer_switch_serial_number = None
              if switch_facts.get('mlag'):
                  # Get MLAG peer from interface's neighbor details
                  # Look for DC data center tags to get MLAG peer
                  if switch_facts.get('type') and switch_facts.get('dc') and switch_facts.get('pod'):
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts.get('mlag') and \
                                  neighbor_switch_facts.get('type', '') == switch_facts.get('type') and \
                                  neighbor_switch_facts.get('dc', '') == switch_facts.get('dc') and \
                                  neighbor_switch_facts.get('pod', '') == switch_facts.get('pod'):
                              mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                              return mlag_peer_switch_serial_number
                  # Look for campus tags to get MLAG peer
                  if switch_facts.get('type') and switch_facts.get('campus') and switch_facts.get('site'):
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts.get('mlag') and \
                                  neighbor_switch_facts.get('type', '') == switch_facts.get('type') and \
                                  neighbor_switch_facts.get('campus', '') == switch_facts.get('campus') and \
                                  neighbor_switch_facts.get('site', '') == switch_facts.get('site'):
                              mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                              return mlag_peer_switch_serial_number
                  # If mlag peer is still not found, use 'universal' tags
                  # Assumption is that this switch's MLAG peer should be the only neighbor switch with
                  # mlag enabled, the same services running, and a node id difference of 1
                  for info in switch_facts['interfaces'].values():
                      neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                      if neighbor_switch_facts.get('mlag') \
                              and switch_facts['network_services_l2'] == neighbor_switch_facts['network_services_l2'] \
                              and switch_facts['network_services_l3'] == neighbor_switch_facts['network_services_l3'] \
                              and switch_facts.get('id') and neighbor_switch_facts.get('id') \
                              and abs(int(switch_facts['id']) - int(neighbor_switch_facts['id'])) == 1:
                          mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                          return mlag_peer_switch_serial_number
              return mlag_peer_switch_serial_number


          @ctx.benchmark
          def get_switch_basics_from_tags(device_id):
              if device_id in my_neighbors_switch_facts:
                  return my_neighbors_switch_facts[device_id]
              relevant_roles = ["Leaf", "Spine", "L2-Leaf", "Super-Spine"]
              dev = ctx.topology.getDevices(deviceIds=[device_id])[0]

              switch_facts = {
                  'serial_number': device_id,
                  'type': None,
                  'id': None,
                  'network_services_l2': False,
                  'network_services_l3': False,
                  'vtep_ip': None,
                  'bgp_as': None,
                  'router_id': None,
                  'mlag': False,
                  'dc': None,
                  'pod': None,
                  'campus': None,
                  'site': None,
              }
              old_leaf_number = None
              old_spine_number = None

              if dev.hostName:
                  switch_facts["hostname"] = dev.hostName
              if dev.modelName:
                  switch_facts["platform"] = dev.modelName

              rolesAssigned = []
              for tag in dev.getTags(ctx):
                  # collect Roles, finalized after loop
                  if tag.label == 'Role':
                      rolesAssigned.append(tag.value)

                  # Set node_id
                  elif tag.label == 'NodeId':
                      switch_facts['id'] = int(tag.value)

                  # Prime old way in case NodeId tag is missing
                  elif tag.label == 'Leaf-Number':
                      old_leaf_number = int(tag.value)
                  elif tag.label == 'Spine-Number':
                      old_spine_number = int(tag.value)

                  # Set network_services
                  elif tag.label == 'NetworkServices':
                      # Set l2 network_services
                      if tag.value == 'L2':
                          switch_facts['network_services_l2'] = True
                      # Set l3 network_services
                      if tag.value == 'L3':
                          switch_facts['network_services_l3'] = True

                  # Set Vtep
                  elif tag.label == 'Vtep':
                      if re.match(r'true', tag.value, flags=re.IGNORECASE):
                          switch_facts['vtep'] = True
                      else:
                          switch_facts['vtep'] = False

                  # Set VtepIp
                  elif tag.label == 'VtepIp':
                      switch_facts['vtep_ip'] = tag.value

                  # Set BGP ASN
                  elif tag.label in ['router_bgp.as', 'bgp_as']:
                      switch_facts['bgp_as'] = tag.value

                  # Set Router ID
                  elif tag.label in ['router_bgp.router_id', 'router_id']:
                      switch_facts['router_id'] = tag.value

                  # Set mlag_port_channel_id and turn mlag on
                  elif tag.label == 'mlag_configuration.peer_link':
                      if tag.value.strip():
                          switch_facts['mlag_port_channel_id'] = "".join(re.findall(r'\d', tag.value))
                          switch_facts['mlag'] = True

                  # Set additional 'good to have' facts
                  elif tag.label == 'DC':
                      switch_facts['dc'] = tag.value
                  elif tag.label == 'DC-Pod':
                      switch_facts['pod'] = tag.value
                  elif tag.label == 'Campus':
                      switch_facts['campus'] = tag.value
                  elif tag.label == 'Site':
                      switch_facts['site'] = tag.value
                  elif tag.label == 'Leaf-Domain':
                      switch_facts['leaf_domain'] = int(tag.value) if tag.value else 0
              # Finished getting tags

              # Set only one role if relevant one exists
              # Note: dual DC-leaf/Campus-spine is a Leaf for this studio
              rolesAssigned = list(set(relevant_roles)&set(rolesAssigned))
              if switch_facts.get('leaf_domain') and switch_facts.get(
                  'campus') and (set(['Spine', 'Leaf']) == set(rolesAssigned)):
                  rolesAssigned = ['Leaf']
              assert len(rolesAssigned) <= 1, \
                  f"Only 1 data center role should be applied to the switch. " \
                  f"Detected the following roles applied to " \
                  f"{switch_facts['hostname']}: {rolesAssigned}"
              if rolesAssigned:
                  switch_facts['type'] = rolesAssigned[0]

              # If no NodeId tag, use old Leaf-Number or Spine-Number tags
              if not switch_facts.get('id'):
                  if switch_facts.get('type') == "Leaf":
                      switch_facts['id'] = old_leaf_number
                  elif switch_facts.get('type') ==  "Spine":
                      switch_facts['id'] = old_spine_number

              # Set l3 network services if not explicitly set by tag
              if not switch_facts.get('network_services_l3'):
                  if switch_facts.get('type') in ["Leaf"]:
                      switch_facts['network_services_l3'] = True
                  else:
                      switch_facts['network_services_l3'] = False

              # Set l2 network services if not explicitly set by tag
              if not switch_facts.get('network_services_l2'):
                  if switch_facts.get('type') in ["Leaf", "L2-Leaf"]:
                      switch_facts['network_services_l2'] = True
                  else:
                      switch_facts['network_services_l2'] = False

              # Set vtep if not explicitly set by tag
              if switch_facts.get('type') and switch_facts['type'] in ['Leaf']:
                  switch_facts['vtep'] = True

              # Set other facts
              if switch_facts.get('network_services_l3'):
                  switch_facts['uplink_type'] = "p2p"
              else:
                  switch_facts['uplink_type'] = "port-channel"
              switch_facts['4basn_enabled'] = fabric_variables['4basn_enabled']

              my_neighbors_switch_facts[device_id] = switch_facts
              return switch_facts


          @ctx.benchmark
          def set_fabric_variables():
              '''
              Updates global fabric_variables variable with custom settings
              '''
              custom_fabric_variables = advancedSettings
              # Update BGP variables
              if name := custom_fabric_variables['bgpPeerGroupSettings'][
                  'evpnOverlayCorePeerGroup']['name']:
                  fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE'][
                      'name'] = name
              if password := custom_fabric_variables['bgpPeerGroupSettings'][
                  'evpnOverlayCorePeerGroup']['password']:
                  fabric_variables['bgp_peer_groups']['EVPN_OVERLAY_CORE'][
                      'password'] = password
              fabric_variables['pruneVlans'] = (custom_fabric_variables.get('l2trunkSettings') or {}).get('pruneVlansToggle')
              fabric_variables['summarizeVlanVnis'] = (custom_fabric_variables.get('evpnSettings') or {}).get('vlanVniSummaryToggle')
              fabric_variables['summarizeVlans'] = (custom_fabric_variables.get('vlanSettings') or {}).get('vlanSummaryToggle')
              fabric_variables['loopback_settings']['overlayLoopbackNumber'] = (custom_fabric_variables.get('loopbackSettings') or {}).get('overlayLoopbackNumber')
              fabric_variables['4basn_enabled'] = (custom_fabric_variables.get('asnSettings') or {}).get('asnDotNotationAllow')


          @ctx.benchmark
          def set_switch_facts(switch_facts):
              # Set mlag relevant facts
              switch_facts['mlag_role'] = None
              if switch_facts.get('mlag'):
                  if mlag_peer_sn := get_mlag_peer(switch_facts):
                      switch_facts['mlag_peer_serial_number'] = mlag_peer_sn
                      mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts['mlag_peer_serial_number'])
                      if int(switch_facts['id']) < int(mlag_peer_switch_facts['id']):
                          switch_facts['mlag_role'] = "primary"
                          switch_facts['mlag_primary_id'] = int(switch_facts['id'])
                      else:
                          switch_facts['mlag_role'] = "secondary"
                          switch_facts['mlag_primary_id'] = int(mlag_peer_switch_facts['id'])

              # Set switch.evpn_gateway
              if switch_facts.get("vtep"):
                  # attempt to resolve EVPN GW
                  evpn_gw_details = evpnGatewayVteps.resolve(device=switch_facts['serial_number'])
                  if evpn_gw_details:
                      switch_facts['evpn_gateway_vxlan_l2'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL2']['enable']
                      switch_facts['evpn_gateway_vxlan_l3'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL3']['enable']
                      switch_facts['evpn_gateway_vxlan_l3_inter_domain'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['evpnL3']['interDomain']
                      if switch_facts['evpn_gateway_vxlan_l2'] or switch_facts['evpn_gateway_vxlan_l3']:
                          switch_facts['evpn_gateway_remote_peers'] = evpn_gw_details['remoteEvpnGatewayVtepsDetails']['remoteEvpnGatewayVtepPeers']

              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return switch_facts


          @ctx.benchmark
          def clean_config(config):
              # remove default vrf dictionary
              if config.get('vrfs') and config['vrfs'].get('default'):
                  del config['vrfs']['default']
              # remove any empty SVIs
              svis_to_delete = []
              for svi, info in config['vlan_interfaces'].items():
                  if len(info.keys()) == 0:
                      svis_to_delete.append(svi)
              for svi in svis_to_delete:
                  del config['vlan_interfaces'][svi]

              # remove default vrf from L3 vrfs in bgp config
              if config.get('router_bgp') and config['router_bgp'].get('vrfs') and config['router_bgp']['vrfs'].get('default'):
                  del config['router_bgp']['vrfs']['default']

              # remove default router_multicast dictionary
              if len(config.get("router_multicast", {}).get("vrfs", [])) == 0:
                  del config['router_multicast']
              # remove default router_pim_sparse_mode dictionary
              if len(config.get("router_pim_sparse_mode", {}).get("vrfs", [])) == 0:
                  del config['router_pim_sparse_mode']

              return config


          @ctx.benchmark
          def summarize_vlans(config):
              """
              Create summarized ranges for generating the vlan command by:
                1) grouping vlans having the same L2 attributes
                   of ['name', 'state', 'trunk_groups', 'etree']
                2) specifing each group by an eos style range (eg. 1-5,10,12-15)
              """
              groups_vlans = {}
              for key, value in config['vlans'].items():
                  groups_vlans.setdefault((
                          value.get('name'),
                          value.get('state'),
                          ' '.join(str(item) for item in sorted(
                              value.get('trunk_groups',[]))),
                          value.get('etree', {}).get('role'),
                      ), []).append(key)
              for _, group in sorted(groups_vlans.items(), key=lambda item: item[1]):
                  group_dict = {vlan: vlan for vlan in group}
                  config['summarized_vlans'].append(','.join(summarize_ranges(group_dict).keys()))
              return config


          @ctx.benchmark
          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          @ctx.benchmark
          def get_network_services_applied_to_switch(switch_facts, tenants):
              device_id = switch_facts['serial_number']
              switch_facts['tenants'] =  {}
              switch_facts['vlans'] =  []
              non_switch_vlans = []

              # allow all vlans
              # switch_facts["allow_all_vlans"] = site_details["services"].get("allowAllVLANs", False)

              switch_services = {
                  "vlans": [],
                  "tenants": {}
              }
              for tenant in tenants:
                  # Add vrfs
                  add_vrfs = {}  # Used to determine which services are applied to this switch
                  for vrf in tenant['vrfs']:
                      # if vrf is manually assigned to devices
                      if device_matches_resolver_query(vrf['devices'], device_id):
                          add_vrfs[vrf['name']] = {
                              "svis": []
                          }
                          # ctx.info(f"Adding {vrf['name']} because found it in applied devices list")
                          continue

                      # Add VRF if l3 interface is to be configured on switch
                      if len(vrf.get('l3Interfaces').resolve(device=device_id)['interfaces']) > 0:
                          if device_matches_resolver_query(vrf['l3Interfaces'], device_id):
                              add_vrfs[vrf['name']] = {
                                  "svis": []
                              }
                              # ctx.info(f"Adding {vrf['name']} because found an l3 interface")
                              continue

                      # Add VRF if there is a BGP neighbor for this node in vrf
                      for bgp_peer in vrf.get("externalBgpPeers", []):
                          # if bgp peer is to be configured on switch
                          if device_matches_resolver_query(bgp_peer['devices'], device_id):
                              add_vrfs[vrf['name']] = {
                                  "svis": []
                              }
                              # ctx.info(f"Adding {vrf['name']} because found an ebgp peer")
                              break

                      if add_vrfs.get(vrf['name']):
                          continue

                      # Add VRF if there is a static route for this node in vrf
                      for sr in vrf.get('staticRoutes', []):
                          # if static route is to be configured on switch
                          if device_matches_resolver_query(sr['devices'], device_id):
                              add_vrfs[vrf['name']] = {
                                  "svis": []
                              }
                              # ctx.info(f"Adding {vrf['name']} because found a static route")
                              break

                      if add_vrfs.get(vrf['name']):
                          continue

                      # Add VRF if there are extra route targets
                      for rt in vrf.get('additionalRouteTargets', []):
                          # if static route is to be configured on switch
                          if device_matches_resolver_query(rt['devices'], device_id):
                              add_vrfs[vrf['name']] = {
                                  "svis": []
                              }
                              # ctx.info(f"Adding {vrf['name']} because found an addition rt")
                              break

                      # Last check in loop is unnecessary
                      if add_vrfs.get(vrf['name']):
                          continue

                  # Add vlans
                  add_l2vlans = []
                  for vlan in tenant["vlans"]:
                      # Check if vlan applies to switch
                      downstream_devs = list(vlans_devs.get(tenant['name'],{}).get(vlan['vlanId'], set()) & set(my_switch_facts.get('Downlinks_Devices', [])))
                      if downstream_devs:
                          if vlan.get('l3OrL2') and vlan['l3OrL2'] is True:
                              switch_services['vlans'].append(int(vlan['vlanId']))
                              if vlan.get('vrf', '') == '':
                                  vrf_name = 'default'
                              else:
                                  vrf_name = vlan['vrf']

                              # Add vrf to add_vrfs
                              if not add_vrfs.get(vrf_name):
                                  add_vrfs[vrf_name] = {
                                      "svis": []
                                  }

                              # Add vlan to vrf's svis
                              add_vrfs[vrf_name]["svis"].append(int(vlan['vlanId']))
                          else:
                              add_l2vlans.append(int(vlan['vlanId']))
                              switch_services['vlans'].append(int(vlan['vlanId']))
                      else:
                          # these vlans should be excluded from vlan configs
                          # even if in a bundle range
                          non_switch_vlans.append(int(vlan['vlanId']))

                  # Add vlan aware bundles
                  add_vlan_aware_bundles = []
                  for vlan_aware_bundle in tenant["vlanAwareBundles"]:
                      if not vlan_aware_bundle.get('name', "").strip():
                          continue
                      if not (vlan_range := string_to_list(vlan_aware_bundle['vlanRange'])):
                          continue
                      # add vlans from bundles as applicable
                      if attributes := (vlan_aware_bundle.get(
                              'attributes') or {}).get('l2Attributes'):
                          bundle_switches = attributes['switches'].resolveAll(
                              strict=True)
                          bundle_devs = set()
                          for bundle_dev, _ in bundle_switches:
                              bundle_devs.add(bundle_dev)
                          downstream_devs = list(bundle_devs & set(
                              my_switch_facts.get('Downlinks_Devices', [])))
                          if downstream_devs:
                              for vlan in vlan_range:
                                  # avoids adding L3 vlans, re-adding L2 vlans,
                                  # or adding non-switch vlans from vlans inputs
                                  if vlan not in (switch_services['vlans'] +
                                      non_switch_vlans):
                                      switch_services['vlans'].append(vlan)
                                      add_l2vlans.append(vlan)
                      if set(vlan_range) & set(switch_services['vlans']):
                          add_vlan_aware_bundles.append(vlan_aware_bundle['name'])

                  # Filter only services applied to this switch
                  if len(add_vrfs) > 0 or len(add_l2vlans) > 0:
                      switch_services['tenants'].update({ tenant['name']: {"vrfs": add_vrfs, "l2vlans": add_l2vlans, "vlan_aware_bundles": add_vlan_aware_bundles} })

              switch_facts['tenants'] =  switch_services['tenants']
              switch_facts['vlans'] =  switch_services['vlans']

              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return switch_facts


          @ctx.benchmark
          def get_tenant_evpn_mcast(switch_facts, tenant, tenant_data_model):
              device_id = switch_facts["serial_number"]
              if tenant.get('evpnMulticast') is None:
                  return
              # Check to see if l2 evpn multicast is enabled
              if tenant['evpnMulticast'].get('l2Multicast') is not None:
                  if tenant['evpnMulticast']['l2Multicast'].get("enabled", "No") == "Yes":
                      l2_mcast_inputs = tenant['evpnMulticast']["l2Multicast"]
                      tenant_data_model["evpn_l2_multicast"] = {
                          "enabled": True,
                          "enabledSvis": True if tenant['evpnMulticast']['l2Multicast'].get("enabledSvis", "No") == "Yes" else False,
                          "underlay_l2_multicast_group_ipv4_pool": (l2_mcast_inputs.get("evpnUnderlayMulticast") or {}).get('evpnUnderlayL2MulticastGroupIpv4Pool'),
                          "underlay_l2_multicast_group_ipv4_pool_offset": (l2_mcast_inputs.get("evpnUnderlayMulticast") or {}).get('evpnUnderlayL2MulticastGroupIpv4PoolOffset')
                      }
              # Check to see if l3 evpn multicast is enabled
              if tenant['evpnMulticast'].get('l3Multicast') is not None:
                  if tenant['evpnMulticast']['l3Multicast'].get("enabled", "No") == "Yes":
                      l3_mcast_inputs = tenant['evpnMulticast']["l3Multicast"]
                      tenant_data_model["evpn_l3_multicast"] = {
                          "enabled": True,
                          "evpn_underlay_l3_multicast_group_ipv4_pool": (l3_mcast_inputs.get("evpnUnderlayMulticast") or {}).get('evpnUnderlayL3MulticastGroupIpv4Pool'),
                          "evpn_underlay_l3_multicast_group_ipv4_pool_offset": (l3_mcast_inputs.get("evpnUnderlayMulticast") or {}).get('evpnUnderlayL3MulticastGroupIpv4PoolOffset')
                      }
                      if l3_mcast_inputs.get('evpnPeg') and device_matches_resolver_query(l3_mcast_inputs['evpnPeg'], device_id):
                          evpn_peg = {
                              "nodes": [device_id]
                          }
                          if l3_mcast_inputs['evpnPeg'].resolve(device=device_id).get("transit", "") != "":
                              evpn_peg["transit"] = True if l3_mcast_inputs['evpnPeg'].resolve(device=device_id)["transit"] == "Yes" else False
                          tenant_data_model["evpn_l3_multicast"]["evpn_peg"] = [evpn_peg]
                      rp_groups = []
                      for rp_group in l3_mcast_inputs.get("pimRpAddresses", []):
                          if len(rp_group.get("rpIpAddresses", [])) > 0:
                              rp_group_info = {
                                  "rps": rp_group["rpIpAddresses"]
                              }
                              if len(rp_group.get("groupAddresses", [])) > 0:
                                  rp_group_info["groups"] = rp_group["groupAddresses"]
                              rp_groups.append(rp_group_info)
                      if len(rp_groups) > 0:
                          tenant_data_model["pim_rp_addresses"] = rp_groups


          @ctx.benchmark
          def get_tenant_vrf_mlag_peering(switch_facts, vrf,
              tenant_data_model, ip_ver = 'v4'):
              vrf_name = vrf["name"]
              if ip_ver == 'v4':
                  defaultMask = 31
                  mlag_peer_l3_ip_pool = vrf["iBgpDetails"].get(
                                                 "iBgpSubnet")
                  mlag_peer_l3_subnet_mask = vrf["iBgpDetails"].get(
                                                 "iBgpSubnetMask", 31)
              else:
                  mlag_peer_l3_ip_pool = vrf["iBgpDetails"].get(
                                                 "iBgpSubnetV6")
                  mlag_peer_l3_subnet_mask = vrf["iBgpDetails"].get(
                                                 "iBgpSubnetMaskV6", 127)
              if not mlag_peer_l3_ip_pool or not mlag_peer_l3_subnet_mask:
                  return
              if switch_facts["mlag_role"] == "primary":
                  mlag_l3_ip = str(get_mlag_ip(
                                   switch_facts, mlag_peer_l3_ip_pool,
                                   mlag_peer_l3_subnet_mask, "primary"))

                  mlag_peer_l3_ip = str(get_mlag_ip(
                                   switch_facts, mlag_peer_l3_ip_pool,
                                   mlag_peer_l3_subnet_mask, "secondary"))

              else:
                  mlag_l3_ip = str(get_mlag_ip(
                                   switch_facts, mlag_peer_l3_ip_pool,
                                   mlag_peer_l3_subnet_mask, "secondary"))

                  mlag_peer_l3_ip = str(get_mlag_ip(
                                   switch_facts, mlag_peer_l3_ip_pool,
                                   mlag_peer_l3_subnet_mask, "primary"))

              tenant_data_model["vrfs"][vrf_name]["enable_mlag_ibgp_peering_vrfs"] = True
              tenant_data_model["vrfs"][vrf_name][
                  f"mlag_ibgp_peering_subnet_{ip_ver}"] = mlag_peer_l3_ip_pool
              tenant_data_model["vrfs"][vrf_name][
                  f"mlag_ibgp_peering_subnet_mask_{ip_ver}"] = mlag_peer_l3_subnet_mask
              tenant_data_model["vrfs"][vrf_name][
                  f"mlag_l3_ip_{ip_ver}"] = mlag_l3_ip
              tenant_data_model["vrfs"][vrf_name][
                  f"mlag_peer_l3_ip_{ip_ver}"] = mlag_peer_l3_ip
              tenant_data_model["vrfs"][vrf_name][
                  f"mlag_peer_l3_subnet_mask_{ip_ver}"] = mlag_peer_l3_subnet_mask


          @ctx.benchmark
          def get_tenant_vrf_l3_interface(device_id, l3_interface):
              # ctx.info(f"l3_interface: {l3_interface}")
              interface = {}
              interface["interfaces"] = [l3_interface["name"]]
              interface["nodes"] = [device_id]
              interface["ip_addresses_v4"] = [l3_interface.get("ipAddress")]
              interface["ip_addresses_v6"] = [l3_interface.get("ipAddressV6")]
              interface["enabled"] = l3_interface["enabled"]
              if l3_interface.get("description"):
                  interface["description"] = l3_interface["description"]
              if l3_interface.get("mtu"):
                  interface["mtu"] = l3_interface["mtu"]
              if len(l3_interface.get("eosCli", [])) > 0:
                  interface["raw_eos_cli"] = l3_interface["eosCli"]
                  # interface["raw_eos_cli"] = "\n".join(l3_interface["eosCli"])  # will use this method when extended text input type is available
              # Check ospf
              if l3_interface.get("ospf"):
                  ospf = {
                      "enabled": l3_interface["ospf"]["enabled"],
                      "point_to_point": l3_interface["ospf"]["pointToPoint"],
                      "area": l3_interface["ospf"].get("area", "0"),
                      "cost": l3_interface["ospf"].get("cost"),
                  }
                  # ospf authentication
                  if l3_interface["ospf"].get("authentication"):
                      ospf["authentication"] = l3_interface["ospf"]["authentication"]
                  # ospf simple auth key
                  if l3_interface["ospf"].get("simpleAuthKey"):
                      ospf["simpleAuthKey"] = l3_interface["ospf"]["simpleAuthKey"]
                  # ospf message digest keys
                  if len(l3_interface["ospf"].get("messageDigestKeys", [])) > 0:
                      ospf["message_digest_keys"] = []
                      for mdk in l3_interface["ospf"]["messageDigestKeys"]:
                          ospf["message_digest_keys"].append({
                              "id": mdk.get("id"),
                              "hash_algorithm": mdk.get("hashAlgorithm"),
                              "key": mdk.get("key"),
                          })
                  interface["ospf"] = ospf
              return interface


          @ctx.benchmark
          def get_tenant_vrf_static_route(device_id, sr):
              # ctx.info(f"SR: {sr}")
              static_route = {
                  "destination_address_prefix": sr[
                      "routeDetails"]["destinationAddressPrefix"],
                  "name": sr["description"].replace(" ", "_"),
                  "nodes": [device_id]
              }
              # gateway
              if not sr["routeDetails"].get("gateway"):
                  static_route["gateway"] = None
              else:
                  static_route["gateway"] = sr["routeDetails"]["gateway"]
              # interface
              if not sr["routeDetails"].get("interface"):
                  static_route["interface"] = None
              else:
                  static_route["interface"] = sr["routeDetails"]["interface"]
              # distance
              if not sr["routeDetails"].get("distance"):
                  static_route["distance"] = None
              else:
                  static_route["distance"] = sr["routeDetails"]["distance"]
              # tag
              if not sr["routeDetails"].get("tag"):
                  static_route["tag"] = None
              else:
                  static_route["tag"] = sr["routeDetails"]["tag"]
              # metric
              if not sr["routeDetails"].get("metric"):
                  static_route["metric"] = None
              else:
                  static_route["metric"] = sr["routeDetails"]["metric"]
              return static_route


          @ctx.benchmark
          def get_tenant_vrf_peer(device_id, switch_facts, bgp_peer):
              # ctx.info(f"bgp_peer: {bgp_peer}")
              peer = {}
              if switch_facts['4basn_enabled'] and bgp_peer.get('remoteAsUpper'):
                  peer['remote_as_upper'] = bgp_peer.get('remoteAsUpper')
              peer['remote_as'] = bgp_peer['remoteAs']
              if bgp_peer.get('description', '').strip():
                  peer['description'] = bgp_peer['description']
              if bgp_peer.get('password', '').strip():
                  peer['password'] = bgp_peer['password']
              if bgp_peer.get('sendCommunity', '').strip():
                  peer['send_community'] = bgp_peer['sendCommunity']
              if bgp_peer.get('nextHopSelf', '').strip():
                  peer['next_hop_self'] = bgp_peer['nextHopSelf']
              if (bgp_peer.get('maxRoutes') or {}).get('maximumRoutes'):
                  peer['maximum_routes'] = bgp_peer[
                      'maxRoutes']['maximumRoutes']
              if (bgp_peer.get('maxRoutes') or {}).get('warningLimit'):
                  peer['maximum_routes_warning_limit'] = bgp_peer[
                      'maxRoutes']['warningLimit']
              if (bgp_peer.get('defaultOriginate') or {}).get(
                  'ebgpPeerDefaultOriginateEnable'):
                  peer['default_originate'] = {
                      "always": bgp_peer['defaultOriginate']['always']
                  }
              if bgp_peer.get('updateSource', '').strip():
                  peer['update_source'] = bgp_peer['updateSource']
              if bgp_peer.get('ebgpMultihop'):
                  peer['ebgp_multihop'] = bgp_peer['ebgpMultihop']
              peer['nodes'] = [device_id]
              # Note: iPv4NextHop is either ipv4 or ipv6
              # It is a legacy name for backward compatibility
              if (bgp_peer.get('nextHop') or {}).get(
                  'iPv4NextHop', '').strip():
                  peer['set_ip_next_hop'] = bgp_peer[
                      'nextHop']['iPv4NextHop']
              if (bgp_peer.get('routeMap') or {}).get(
                  'routeMapOut', '').strip():
                  peer['route_map_out'] = bgp_peer[
                      'routeMap']['routeMapOut']
              if (bgp_peer.get('routeMap') or {}).get(
                  'routeMapIn', '').strip():
                  peer['route_map_in'] = bgp_peer[
                      'routeMap']['routeMapIn']
              if bgp_peer.get('weight'):
                  peer['weight'] = bgp_peer['weight']
              if bgp_peer.get('localAs'):
                  peer['local_as'] = bgp_peer['localAs']
              if switch_facts['4basn_enabled'] and bgp_peer.get('localAsUpper'):
                  peer['local_as_upper'] = bgp_peer['localAsUpper']
              return peer


          @ctx.benchmark
          def get_tenant_vrf_mcast(device_id, tenant_data_model, vrf):
              l3_mcast_inputs = vrf['evpnMulticast']
              vrf_name = vrf["name"]
              if l3_mcast_inputs.get('evpnPeg') and (
                  device_matches_resolver_query(
                      l3_mcast_inputs['evpnPeg'], device_id)):
                  evpn_peg = {
                      "nodes": [device_id]
                  }
                  if transit := l3_mcast_inputs['evpnPeg'].resolve(
                      device=device_id).get("transit"):
                      evpn_peg["transit"] = True if transit == "Yes" else False
                  tenant_data_model["vrfs"][vrf_name][
                      "evpn_l3_multicast"]["evpn_peg"] = [evpn_peg]
              rp_groups = []
              for rp_group in l3_mcast_inputs.get("pimRpAddresses", []):
                  if len(rp_group.get("rpIpAddresses", [])) > 0:
                      rp_group_info = {
                          "rps": rp_group["rpIpAddresses"]
                      }
                      if len(rp_group.get("groupAddresses", [])) > 0:
                          rp_group_info["groups"] = rp_group["groupAddresses"]
                      rp_groups.append(rp_group_info)
              if len(rp_groups) > 0:
                  tenant_data_model["vrfs"][vrf_name][
                      "pim_rp_addresses"] = rp_groups


          @ctx.benchmark
          def get_tenant_vrfs(switch_facts, tenant, tenant_data_model):
              device_id = switch_facts["serial_number"]
              for vrf in tenant['vrfs']:
                  vrf_name = vrf["name"]
                  tenant_data_model["vrfs"][vrf_name] = {
                      "error_name": vrf_name,
                      "svis": {},
                      "v4_routing": False,
                      "v6_routing": False,
                  }
                  tenant_data_model["vrfs"][vrf_name]["vni"] = vrf["vni"]
                  if switch_facts["network_services_l3"]:
                      # vrf ip version enable
                      if (vrf.get('enableVrfIpVersion') or {}).get(
                          'enableVrfIpV4'):
                          tenant_data_model["vrfs"][vrf_name][
                              "v4_routing"] = True
                      if (vrf.get('enableVrfIpVersion') or {}).get(
                          'enableVrfIpV6'):
                          tenant_data_model["vrfs"][vrf_name][
                              "v6_routing"] = True
                  if switch_facts["network_services_l2"] and switch_facts[
                      "network_services_l3"]:
                      # mlag l3 peering
                      if vrf.get("iBgpDetails") and (
                          vrf["iBgpDetails"].get("iBgpVlanId") ) and (
                          switch_facts.get('mlag_role') is not None ):
                          tenant_data_model["vrfs"][vrf_name][
                              "mlag_ibgp_peering_vlan"] = vrf[
                                  "iBgpDetails"]["iBgpVlanId"]
                          if vrf["iBgpDetails"].get("iBgpSubnet"):
                              if tenant_data_model["vrfs"][vrf_name]["v4_routing"]:
                                  get_tenant_vrf_mlag_peering(
                                      switch_facts, vrf,
                                      tenant_data_model, 'v4')
                              if tenant_data_model["vrfs"][vrf_name]["v6_routing"]:
                                  get_tenant_vrf_mlag_peering(
                                      switch_facts, vrf,
                                      tenant_data_model, 'v6')
                  if switch_facts["network_services_l3"]:
                      # source nat interface
                      if vrf['natSourceDetails'].get('natInterface', "").strip() != "":
                          # ctx.info(f"{vrf['natSourceDetails']}")
                          nat_subnet = vrf['natSourceDetails'][
                              'campus'].resolve(device=device_id)[
                              'site'].resolve(device=device_id)['subnet']
                          if not nat_subnet or nat_subnet.strip() == "":
                              nat_subnet = vrf['natSourceDetails'][
                                  'dataCenter'].resolve(
                                  device=device_id)['dcPoD'].resolve(
                                  device=device_id)['subnet']
                          if nat_subnet and nat_subnet.strip() != "":
                              tenant_data_model["vrfs"][vrf_name][
                                  'vtep_diagnostic'] = {
                                  "loopback": "".join(re.findall(r'\d',
                                      vrf['natSourceDetails']['natInterface'])),
                                  "loopback_ip_range": nat_subnet
                              }

                      # static routes
                      if len(vrf.get("staticRoutes", [])) > 0:
                          tenant_data_model["vrfs"][vrf_name][
                              "static_routes"] = []
                          for sr in vrf.get("staticRoutes", []):
                              if device_matches_resolver_query(sr["devices"],
                                  device_id):
                                  static_route = get_tenant_vrf_static_route(
                                      device_id, sr)
                                  tenant_data_model["vrfs"][vrf_name][
                                      "static_routes"].append(static_route)

                      # redistribute static routes
                      if vrf['redistributeStaticRoutes']:
                          tenant_data_model['vrfs'][vrf_name][
                              'redistribute_static'] = vrf[
                              'redistributeStaticRoutes']

                      # l3 interfaces
                      if vrf.get("l3Interfaces") and (
                          device_matches_resolver_query(vrf["l3Interfaces"],
                          device_id)):
                          # Populate l3_interfaces list in tenant vrf with
                          # user input l3 interfaces
                          for l3_interface in vrf['l3Interfaces'].resolve(
                              device=device_id).get("interfaces", []):
                              # Added for subinterfaces
                              l3_interface['encapsulation_dot1q_vlan'] = None
                              interface = get_tenant_vrf_l3_interface(
                                  device_id, l3_interface)
                              # add interface
                              tenant_data_model["vrfs"][vrf_name].setdefault(
                                  "l3_interfaces", []).append(interface)

                      # external bgp peers
                      if len(vrf.get('externalBgpPeers', {})) > 0:
                          tenant_data_model["vrfs"][vrf_name][
                              'bgp_peers'] = {}
                          for bgp_peer in vrf.get('externalBgpPeers', {}):
                              # check if bgp peer is to be configured on switch
                              if device_matches_resolver_query(
                                  bgp_peer['devices'], device_id):
                                  peer = get_tenant_vrf_peer(device_id, switch_facts,
                                      bgp_peer)
                                  tenant_data_model["vrfs"][vrf_name][
                                      'bgp_peers'][bgp_peer['neighborIpAddress']] = peer

                      # normalize bgp
                      tenant_data_model["vrfs"][vrf_name]["bgp"] = {}
                      if len(vrf['bgp'].get('eosCli', [])) > 0:
                          tenant_data_model["vrfs"][vrf_name]["bgp"]['raw_eos_cli'] = vrf['bgp']['eosCli']

                      # additional route targets
                      additional_route_targets = []
                      for rt in vrf['additionalRouteTargets']:
                          # if additional route target is to be configured on switch
                          if device_matches_resolver_query(rt['devices'], device_id):
                              # ctx.info(f"{rt}")
                              route_target = {}
                              route_target['type'] = rt['type']
                              route_target['address_family'] = rt['addressFamily']
                              route_target['route_target'] = rt['routeTarget']
                              route_target['nodes'] = [device_id]
                              additional_route_targets.append(route_target)

                      if len(additional_route_targets) > 0:
                          tenant_data_model['vrfs'][vrf_name][
                              'additional_route_targets'] = additional_route_targets

                      # ospf configuration
                      if (vrf.get("vrfOspfConfiguration") or {}).get(
                          "vrfOspfEnabled"):
                          # ctx.info(f"{vrf['vrfOspfConfiguration']}")
                          ospf = {"enabled": True}
                          # process_id
                          if vrf["vrfOspfConfiguration"].get(
                              "vrfOspfProcessId") is not None:
                              ospf["process_id"] = vrf["vrfOspfConfiguration"]["vrfOspfProcessId"]
                          else:
                              ospf["process_id"] = switch_facts["underlay_ospf_process_id"]
                          # max lsa
                          if vrf["vrfOspfConfiguration"].get(
                              "vrfOspfMaxLsa") is not None:
                              ospf["max_lsa"] = vrf["vrfOspfConfiguration"]["vrfOspfMaxLsa"]
                          else:
                              ospf["max_lsa"] = switch_facts["underlay_ospf_max_lsa"]
                          # bfd
                          if vrf["vrfOspfConfiguration"].get("vrfOspfBfd"):
                              ospf["bfd"] = True if vrf[
                                  "vrfOspfConfiguration"]["vrfOspfBfd"] == "Yes" else False
                          else:
                              ospf["bfd"] = switch_facts["underlay_ospf_bfd_enable"]
                          # add ospf details to vrf
                          tenant_data_model["vrfs"][vrf_name]["ospf"] = ospf

                      # evpn multicast
                      if (vrf.get("evpnMulticast") or {}).get(
                          "enabled", "").strip():
                          l3_mcast_enabled = True if vrf[
                              "evpnMulticast"]["enabled"] == "Yes" else False
                          tenant_data_model["vrfs"][vrf_name][
                              "evpn_l3_multicast"] = {
                              "enabled": l3_mcast_enabled
                          }

                      # pim rps
                      # Check to see if l3 evpn multicast is enabled
                      if (tenant.get('evpnMulticast') or {}).get(
                          'l3Multicast'):
                          if tenant['evpnMulticast']['l3Multicast'].get(
                              "enabled", "") == "Yes" and (
                              vrf.get("evpnMulticast") or {}).get(
                              "enabled", "").strip() != "No":
                              get_tenant_vrf_mcast(
                                  device_id, tenant_data_model, vrf)

                      # route-distinguisher
                      if (vrf.get('overrideVariables') or {}).get(
                          'routeDistinguisher').strip(""):
                          tenant_data_model["vrfs"][vrf_name][
                              'route_distinguisher'] = vrf[
                              'overrideVariables']['routeDistinguisher']
                      else:
                          tenant_data_model["vrfs"][vrf_name][
                              'route_distinguisher'] = vrf_attribute_formats[
                              'vrfRouteDistinguisherFormat']
                      # route-target
                      if (vrf.get('overrideVariables') or {}).get(
                          'routeTarget').strip(""):
                          tenant_data_model["vrfs"][vrf_name][
                              'route_target'] = vrf[
                              'overrideVariables']['routeTarget']
                      else:
                          tenant_data_model["vrfs"][vrf_name][
                              'route_target'] = vrf_attribute_formats[
                              'vrfRouteTargetFormat']


          @ctx.benchmark
          def generate_svi_ips(svi_vip, vlanId, mlag_role):
              svi_vip_network = ipaddress.ip_interface(svi_vip).network
              first_host = first_usable_address(svi_vip)
              last_host = last_usable_address(svi_vip)
              if not first_host or not last_host:
                  return None, None
              if first_host == svi_vip.split("/")[0]:
                  position = "start"
              elif last_host == svi_vip.split("/")[0]:
                  position = "end"
              else:
                  assert False, (
                      f"Input Error: "
                      f"Vlan {vlanId}'s virtual IP address "
                      f"must be either the first or last host address "
                      f"in the subnet if "
                      f"'ip virtual-router address' "
                      f"config type is set" )
              if mlag_role == "secondary":
                  # take higher host address closest to vip
                  if position == "start":
                      svi_ip = str(svi_vip_network[3])
                  else:
                      svi_ip = str(svi_vip_network[-3])
              else:
                  # take lower host address closest to vip
                  if position == "start":
                      svi_ip = str(svi_vip_network[2])
                  else:
                      svi_ip = str(svi_vip_network[-4])
              # format ips
              svi_ip = f"{svi_ip}/{svi_vip_network.prefixlen}"
              svi_vip = svi_vip.split("/")[0]
              return svi_ip, svi_vip


          @ctx.benchmark
          def get_tenant_svi_ip(switch_facts, tenant, vlan, svi, ip_ver):
              device_id = switch_facts["serial_number"]
              if ip_ver == 'v4':
                  name_suffix = ''
              else:
                  name_suffix = 'V6'
              # ip virtual-router address type config
              vlanSvi = vlan[f'sviIpAddresses{name_suffix}']
              virtualIp = vlanSvi.get('sviVirtualIpAddress', '').strip()
              nodeInfo = vlan['nodes'].resolve(device=device_id)['sviIpInfo']
              # ip address virtual case
              if vlanSvi.get('virtualAddressConfigType'):
                  if nodeInfo and (virtualIpOverride := nodeInfo[
                      f'ipAddress{name_suffix}'].strip()):
                      svi[f"ip_address_virtual_{ip_ver}"] = virtualIpOverride
                  elif virtualIp:
                      svi[f"ip_address_virtual_{ip_ver}"] = virtualIp
                  return

              # ip virtual-router address case
              # Get virtual ip address
              primaryIp = (vlanSvi.get(
                  'primarySwitchSviIpAddress') or '').strip()
              secondaryIp = (vlanSvi.get(
                  'secondarySwitchSviIpAddress') or '').strip()
              if vlan['vxlan']:
                  # get virtual ip from sviIpAddresses input
                  svi_vip = virtualIp
              else:
                  # get virtual ip from node resolver input
                  if nodeInfo and (nodeSviVip := nodeInfo[
                      f'virtualIpAddress{name_suffix}'].strip()):
                      svi_vip = nodeSviVip
                  else:
                      svi_vip = None
              # Prioritize real ip address from node resolver input
              svi_ip = nodeInfo[f'ipAddress{name_suffix}'].strip() if nodeInfo else None
              # Default real ip address from sviIpAddresses input
              if not svi_ip:
                  if svi_vip and "/" in svi_vip:
                      if primaryIp:
                          if switch_facts.get('mlag_role') == "secondary":
                              svi_ip = secondaryIp
                          else:
                              svi_ip = primaryIp
                      else:
                          svi_ip, svi_vip = generate_svi_ips(
                              svi_vip,
                              vlan.get('vlanId'),
                              switch_facts.get('mlag_role'))
                  else:
                      if switch_facts.get('mlag_role') == "secondary":
                          svi_ip = secondaryIp
                      else:
                          svi_ip = primaryIp
              # Set svi vip and ip
              if svi_vip:
                  svi[f'ip_virtual_router_addresses_{ip_ver}'] = [svi_vip]
              if svi_ip:
                  svi[f'ip_address_{ip_ver}'] = svi_ip


          @ctx.benchmark
          def get_tenant_vlan_vni(device_id, vlan, vni_base, leaf_domain, vlan_id):
              vni = None
              if nodeInfo := vlan['nodes'].resolve(device=device_id)['sviIpInfo']:
                  if nodeVni := nodeInfo.get('nodeVlanOverrideVni'):
                      vni = nodeVni
                  elif nodeInfo.get('autoGenNodeVlanVni'):
                      vni = vni_base + leaf_domain * 10000 + vlan_id
              if not vni and vlan.get('overrideVariables'):
                  vni = vlan.get('overrideVariables').get('vni')
              if not vni:
                  vni = vni_base + vlan_id
              return vni

          @ctx.benchmark
          def get_tenant_vlans(switch_facts, tenant, tenant_data_model,
              l2VlanNumsList, l3VlanNumsList):
              device_id = switch_facts["serial_number"]
              leaf_domain = switch_facts.get("leaf_domain")
              vlan_vnis = {}
              for vlan in tenant["vlans"]:
                  if not vlan:
                      continue
                  vlan_id = int(vlan["vlanId"])
                  # Create entry for VLAN's VNI if one exists
                  if vlan["vxlan"]:
                      vni = get_tenant_vlan_vni(device_id, vlan,
                          int(tenant_data_model["mac_vrf_vni_base"]),
                          leaf_domain, vlan_id)
                  else:
                      vni = 0
                  vlan_vnis[vlan_id] = vni

                  # track per tenant vlans assigned to lowest tier devices
                  vlan_details = vlan['switches'].resolveAll(strict=True)
                  for vlan_dev, vlan_detail in vlan_details:
                      vlans_devs.setdefault(tenant['name'], {}).setdefault(vlan_id, set()).add(vlan_dev)
                  # parse vlan info if service is enabled for device
                  if switch_facts["network_services_l2"] is not True:
                      continue

                  # If this is an L3 vlan
                  if vlan['l3OrL2']:
                      svi = {
                          "description": None,
                          "ip_helpers": {},
                          "nodes": {},
                          "vxlan": vlan["vxlan"]
                      }
                      # name
                      svi["name"] = vlan["name"] if vlan["name"].strip() != "" else None
                      # vrf
                      if vlan.get("vrf", "") == "":
                          vrf_name =  "default"
                      else:
                          vrf_name = vlan["vrf"]
                          assert tenant_data_model["vrfs"].get(vrf_name), \
                              f"In Tenant {tenant_name}, VLAN {vlan_id} " \
                              f"references non-existent VRF {vrf_name}"
                      # enable vlan
                      svi['enabled'] = True
                      if vlan['vxlan']:
                          svi['vni'] = get_tenant_vlan_vni(device_id, vlan,
                              int(tenant_data_model["mac_vrf_vni_base"]),
                              leaf_domain, vlan_id)
                          # route-distinguisher
                          if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeDistinguisher').strip("") != "":
                              svi['route_distinguisher'] = vlan['overrideVariables']['routeDistinguisher']
                          else:
                              svi['route_distinguisher'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                          # route-target
                          if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeTarget').strip("") != "":
                              svi['route_target'] = vlan['overrideVariables']['routeTarget']
                          else:
                              svi['route_target'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat']

                      # SVI IP address
                      if (vlan.get('enableVlanIpVersion') or {}).get('enableVlanIpV4'):
                          get_tenant_svi_ip(switch_facts, tenant, vlan, svi, 'v4')
                      if (vlan.get('enableVlanIpVersion') or {}).get('enableVlanIpV6'):
                          get_tenant_svi_ip(switch_facts, tenant, vlan, svi, 'v6')

                      # ip helper info
                      if len(vlan['dhcpServerDetails']) > 0:
                          svi['ip_helpers'] = {}
                          for dhcp_info in vlan['dhcpServerDetails']:
                              if dhcp_info.get('dhcpServer') and dhcp_info['dhcpServer'].strip() != "":
                                  svi['ip_helpers'][dhcp_info['dhcpServer']] = {}
                              if dhcp_info.get('sourceInterface') and dhcp_info['sourceInterface'].strip() != "":
                                  # set source interface associated with vrf
                                  svi['ip_helpers'][dhcp_info['dhcpServer']]['source_interface'] = dhcp_info['sourceInterface']

                      # mtu
                      svi['mtu'] = vlan['mtu']
                      # normalize arp
                      if vlan.get('arp'):
                          svi['arp'] = {}
                          if vlan['arp'].get('arpAgingTimeout'):
                              svi['arp']['aging_timeout'] = vlan['arp']['arpAgingTimeout']

                      # evpn multicast
                      if vlan.get("evpnMulticast"):
                          if vlan["evpnMulticast"].get("l3Enabled", "").strip():
                              l3_mcast_enabled = True if vlan["evpnMulticast"]["l3Enabled"] == "Yes" else False
                              svi["evpn_l3_multicast"] = {
                                  "enabled": l3_mcast_enabled
                              }

                      # Add SVI's EOS CLI
                      svi['eos_cli'] = vlan['eosCli']

                      # disable redistribute Learned option
                      svi['redistribute_learned'] = vlan['redistributeLearned']

                      # Add SVI's BGP EOS CLI
                      svi['bgp_eos_cli'] = vlan['bgpEosCli']

                      tenant_data_model["vrfs"][vrf_name]['svis'][vlan_id] = svi
                      l3VlanNumsList.append(vlan_id)

                  else:
                      l2vlan = {
                          "vxlan": vlan["vxlan"]
                      }
                      # name
                      l2vlan["name"] = vlan["name"] if vlan["name"].strip() != "" else None
                      if vlan["vxlan"]:
                          l2vlan['vni'] = get_tenant_vlan_vni(device_id, vlan,
                              int(tenant_data_model["mac_vrf_vni_base"]),
                              leaf_domain, vlan_id)
                          # route-distinguisher
                          if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeDistinguisher').strip("") != "":
                              l2vlan['route_distinguisher'] = vlan['overrideVariables']['routeDistinguisher']
                          else:
                              l2vlan['route_distinguisher'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                          # route-target
                          if vlan.get('overrideVariables') and vlan['overrideVariables'].get('routeTarget').strip("") != "":
                              l2vlan['route_target'] = vlan['overrideVariables']['routeTarget']
                          else:
                              l2vlan['route_target'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat']

                      # evpn multicast
                      if vlan.get("evpnMulticast"):
                          if vlan["evpnMulticast"].get("l2Enabled", "").strip():
                              l2_mcast_enabled = True if vlan["evpnMulticast"]["l2Enabled"] == "Yes" else False
                              l2vlan["evpn_l2_multicast"] = {
                                  "enabled": l2_mcast_enabled
                              }

                      # etree
                      if vlan['eTreeDetails'].get('etreeEnable'):
                          l2vlan['etree_leaf_export_rt_offset'] = vlan['eTreeDetails']['leafExportRouteTargetOffset']
                          if vlan['eTreeRootSwitches'].resolve(device=device_id)['role'] == 'Root':
                              l2vlan['etree_role'] = 'root'
                          else:
                              l2vlan['etree_role'] = 'leaf'

                      # disable redistribute Learned option
                      l2vlan['redistribute_learned'] = vlan['redistributeLearned']

                      # Add l2vlan's BGP EOS CLI
                      l2vlan['bgp_eos_cli'] = vlan['bgpEosCli']

                      tenant_data_model["l2vlans"][vlan_id] = l2vlan
                      l2VlanNumsList.append(vlan_id)
              return vlan_vnis


          @ctx.benchmark
          def get_tenant_vlan_bundles(switch_facts, tenant, tenant_data_model,
              l2VlanNumsList, l3VlanNumsList, vlan_vnis):
              device_id = switch_facts["serial_number"]
              for vlan_aware_bundle in tenant["vlanAwareBundles"]:
                  if not vlan_aware_bundle:
                      continue
                  if not (bundle_name := vlan_aware_bundle.get('name', "").strip()):
                      continue
                  if not (vlan_range := string_to_list(vlan_aware_bundle['vlanRange'])):
                      continue
                  bundle = {}
                  # first and last vlan
                  bundle["first_vlan"] = vlan_range[0]
                  bundle["last_vlan"] = vlan_range[-1]
                  # first and last vni
                  bundle["first_vni"] = vlan_vnis.get(vlan_range[0], f"{int(tenant_data_model['mac_vrf_vni_base']) + int(vlan_range[0])}")
                  bundle["last_vni"] = vlan_vnis.get(vlan_range[-1], f"{int(tenant_data_model['mac_vrf_vni_base']) + int(vlan_range[-1])}")
                  # set compressed vlan range
                  bundle["vlan_range"] = list_compress(vlan_range)
                  # disable redistribute Learned option
                  bundle['redistribute_learned'] = vlan_aware_bundle['redistributeLearned']
                  # add bundle's BGP EOS CLI
                  bundle['bgp_eos_cli'] = vlan_aware_bundle['bgpEosCli']
                  # route-distinguisher
                  if vlan_aware_bundle.get('overrideVariables') and vlan_aware_bundle['overrideVariables'].get('routeDistinguisher').strip("") != "":
                      bundle['route_distinguisher'] = vlan_aware_bundle['overrideVariables']['routeDistinguisher']
                  else:
                      bundle['route_distinguisher'] = vlan_bundle_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                  # route-target
                  if vlan_aware_bundle.get('overrideVariables') and vlan_aware_bundle['overrideVariables'].get('routeTarget').strip("") != "":
                      bundle['route_target'] = vlan_aware_bundle['overrideVariables']['routeTarget']
                  else:
                      bundle['route_target'] = vlan_bundle_mac_vrf_attribute_formats['macVrfRouteTargetFormat']
                  tenant_data_model['vlan_aware_bundles'][bundle_name] = bundle
                  # for bundle vlans not individually input, add them as L2 vlans
                  if not (attributes := (vlan_aware_bundle.get(
                      'attributes') or {}).get('l2Attributes')):
                      continue
                  l2_mcast_enabled = None
                  if attributes["evpnMulticast"].get("l2Enabled", "").strip():
                      l2_mcast_enabled = True if attributes["evpnMulticast"][
                          "l2Enabled"] == "Yes" else False
                  if attributes['eTreeDetails']['etreeEnable']:
                      etree_offset = attributes['eTreeDetails'].get(
                          'leafExportRouteTargetOffset')
                      if attributes['eTreeRootSwitches'].resolve(
                          device=device_id)['role'] == 'Root':
                          etree_role = 'root'
                      else:
                          etree_role = 'leaf'
                  vlanName = attributes["name"] if attributes[
                      "name"].strip() != "" else None
                  for vlan_id in vlan_range:
                      if vlan_id in (l2VlanNumsList + l3VlanNumsList):
                          continue
                      l2vlan = {
                          "vxlan": attributes["vxlan"],
                          "name": vlanName,
                      }
                      if l2_mcast_enabled != None:
                          l2vlan['evpn_l2_multicast'] = {
                              "enabled": l2_mcast_enabled
                          }
                      if attributes["vxlan"]:
                          l2vlan['route_distinguisher'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat']
                          l2vlan['route_target'] = vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat']
                          l2vlan['vni'] = int(tenant_data_model["mac_vrf_vni_base"]) + vlan_id
                      if attributes["eTreeDetails"]['etreeEnable']:
                          l2vlan['etree_leaf_export_rt_offset'] = etree_offset
                          l2vlan['etree_role'] = etree_role
                      tenant_data_model["l2vlans"][vlan_id] = l2vlan


          @ctx.benchmark
          def get_tenants(switch_facts, tenants):
              '''
              Converts studios input schema to avd network services schema:
              AVD tenant data model - https://avd.sh/en/stable/roles/eos_designs/doc/network-services.html
              '''
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              tenants_data_model = {}
              for tenant in tenants:
                  l2VlanNumsList = []
                  l3VlanNumsList = []

                  tenant_name = tenant['name']
                  tenant_data_model = {
                      'mac_vrf_vni_base': tenant['macVrfVniBase'],
                      'vrfs': {
                          'default': {
                              'error_name': 'default',
                              'svis': {}
                          }
                      },
                      'l2vlans': {},
                      'vlan_aware_bundles': {}
                  }

                  # Update tenant_data_model for evpn multicast
                  get_tenant_evpn_mcast(switch_facts, tenant, tenant_data_model)

                  # Update tenant_data_model for tenant vrfs
                  get_tenant_vrfs(switch_facts, tenant, tenant_data_model)

                  # Update tenant_data_model for vlans
                  vlan_vnis = get_tenant_vlans(switch_facts, tenant, tenant_data_model,
                      l2VlanNumsList, l3VlanNumsList)

                  # Update tenant_data_model for vlan bundles
                  get_tenant_vlan_bundles(switch_facts, tenant, tenant_data_model,
                      l2VlanNumsList, l3VlanNumsList, vlan_vnis)

                  tenants_data_model[tenant_name] = tenant_data_model

              switch_facts["all_tenants"] = tenants_data_model
              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return switch_facts


          @ctx.benchmark
          def summarize_ranges(input_dict):
              '''
              Used to summarize the keys and corresponding values.
                  Input  -  dictionary with integer keys and integer values
                  Output -  dictionary with keys and values as strings of ranges
              '''
              sorted_keys = sorted(input_dict.keys())
              summarized_dict = {}
              start_key = sorted_keys[0]
              start_value = input_dict[start_key]
              end_key = sorted_keys[0]
              end_value = input_dict[start_key]
              for key in sorted_keys[1:]:
                  if key == end_key + 1 and input_dict[key] == end_value + 1:
                      end_key = key
                      end_value = input_dict[key]
                  else:
                      if start_key == end_key:
                          summarized_dict[str(start_key)] = str(start_value)
                      else:
                          summarized_dict[f"{start_key}-{end_key}"] = f"{start_value}-{end_value}"
                      start_key = key
                      start_value = input_dict[key]
                      end_key = key
                      end_value = input_dict[key]
              if start_key == end_key:
                  summarized_dict[str(start_key)] = str(start_value)
              else:
                  summarized_dict[f"{start_key}-{end_key}"] = f"{start_value}-{end_value}"
              return summarized_dict


          @ctx.benchmark
          def get_neighbors(switch_facts):
              switch_facts['interfaces'] = get_interfaces_info(switch_facts)
              switch_facts["neighbor_ids"] = []
              for iface in switch_facts['interfaces'].values():
                  if iface["neighborId"] not in switch_facts["neighbor_ids"]:
                      switch_facts["neighbor_ids"].append(iface["neighborId"])

              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return switch_facts


          @ctx.benchmark
          def set_fabricLinks(switch_facts, type):
              '''
              Set the fabric links of specified switch based on fabric studio outputs
                  - type string is either Uplinks or Downlinks
                  - sets port-channels and phsyical interfaces in switch_facts keyed by:
                       Downlinks_POs
                       Downlinks_Interfaces
                       Uplinks_POs
                       Uplinks_Interfaces
                  - currently fabric studio outputs passed as tags of format:
                       Downlinks: Po31-Ethernet3,Po41-Ethernet4
                       Uplinks: Po11-Ethernet1,Po11-Ethernet2
              '''
              pos = {}
              phys = []
              device_id = switch_facts['serial_number']
              dev = ctx.topology.getDevices(deviceIds=[device_id])[0]
              links_tag = dev.getSingleTag(ctx, type, required=False)
              if not links_tag:
                  return switch_facts
              links = links_tag.value.replace('Port-Channel', 'Po').split(',')
              for link in links:
                  po_phy = link.split('-')
                  if len(po_phy) == 2:
                      pos.setdefault(po_phy[0].replace(
                          'Po', 'Port-Channel'), []).append(po_phy[1])
                      phys.append(po_phy[1])
                  elif len(po_phy) == 1:
                      phys.append(po_phy[0])
              switch_facts['%s_POs' % type] = pos
              switch_facts['%s_Interfaces' % type] = phys
              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return switch_facts


          @ctx.benchmark
          def set_xstreamDevs(switch_facts, type, devices):
              '''
              Set the Upstream or Downstream devices
                  - type string is either Uplinks or Downlinks
                  - sets Upstream or Downstream devices in switch_facts keyed by:
                       Downlinks_Devices
                       Uplinks_Devices
              '''
              if not switch_facts:
                  return devices
              devices.add(switch_facts['serial_number'])
              if (intfs := switch_facts.get('interfaces')):
                  for link in switch_facts.get('%s_Interfaces' % type, []):
                      if (intf := intfs.get(link)) and (peer := intf.get('neighborId')):
                          if peer not in devices:
                              devices.add(peer)
                              devices = devices | set_xstreamDevs(my_neighbors_switch_facts.get(peer), type, set())
              switch_facts['%s_Devices' % type] = list(devices)
              my_neighbors_switch_facts[switch_facts['serial_number']] = switch_facts
              return devices

          # Template mainline start
          workspace_id = ctx.studio.workspaceId
          my_device = ctx.getDevice()
          my_device_id = my_device.id
          # Use this to keep latest switch facts for me an my neighbors
          my_neighbors_switch_facts = {}

          # Return if there are no studio inputs
          if not tenants or not evpnGatewayVteps:
              ctx.info(f"the studio has no inputs")
              return

          config = {}

          # Update advanced settings
          set_fabric_variables()

          # Get basics
          my_switch_facts = get_switch_basics_from_tags(my_device_id)
          dump_my_switch_facts(1)

          # Return if this switch is not enabled for services, eg. is a Spine
          if not my_switch_facts["network_services_l2"] and not my_switch_facts["network_services_l3"]:
              ctx.info(f"{my_device_id}: not enabled for L3 or L2 services")
              return

          # Get uplinks and downlinks from Fabric Studio for my switch
          my_switch_facts = set_fabricLinks(my_switch_facts, 'Uplinks')
          my_switch_facts = set_fabricLinks(my_switch_facts, 'Downlinks')

          # Get neighbors
          my_switch_facts = get_neighbors(my_switch_facts)
          dump_my_switch_facts(2)

          # Get switch facts for my neighbors
          for switch_id in my_switch_facts["neighbor_ids"]:
               neighbor_switch_facts = get_switch_basics_from_tags(switch_id)
               set_fabricLinks(neighbor_switch_facts, 'Uplinks')
               set_fabricLinks(neighbor_switch_facts, 'Downlinks')
               my_neighbors_switch_facts[switch_id] = get_neighbors(neighbor_switch_facts)

          my_switch_facts = set_switch_facts(my_switch_facts)
          set_xstreamDevs(my_switch_facts, 'Downlinks', set())
          dump_my_switch_facts(3)

          validate_facts(my_switch_facts)

          vlan_based_mac_vrf_attribute_formats = vlanBasedMacVrfAttributeFormats
          vlan_bundle_mac_vrf_attribute_formats = vlanBundleMacVrfAttributeFormats
          vrf_attribute_formats = vrfAttributeFormats

          my_switch_facts = get_tenants(my_switch_facts, tenants)
          dump_my_switch_facts(4)

          # Check for duplicate VNIs
          check_vni_overlap(my_switch_facts['all_tenants'])

          my_switch_facts = get_network_services_applied_to_switch(
              my_switch_facts, tenants)

          my_neighbors_switch_facts[my_switch_facts['serial_number']] = my_switch_facts
          dump_my_switch_facts(5)

          # Return if this switch is not assigned to any resolvers
          if not my_switch_facts.get('tenants') and not my_switch_facts.get(
              'vlans') and not my_switch_facts.get('evpn_gateway_remote_peers'):
              ctx.info(f"{my_device_id}: no VRF or VLAN services assigned")
              return

          # Set switch facts for the mlag peer
          if my_switch_facts.get('mlag') and (
              mlag_peer_sn := my_switch_facts.get('mlag_peer_serial_number')):
              set_switch_facts(get_switch_basics_from_tags(mlag_peer_sn))

          # Now that switch facts are completed, generate config
          if len(my_switch_facts['tenants'].keys()) > 0 or len(my_switch_facts.get('evpn_gateway_remote_peers', [])) > 0:
              my_config = {
                  "vrfs": {},
                  "vlans": {},
                  "vlan_interfaces": {},
                  "port_channel_interfaces": {},
                  "ethernet_interfaces": {},
                  "loopback_interfaces": {},
                  "virtual_source_nat_vrfs": {},
                  "static_routes": [],
                  "route_maps": {},
                  "router_bgp": {
                      "peer_groups": {},
                      "neighbors": {}
                  },
                  "router_multicast": {
                      "vrfs": []
                  },
                  "router_pim_sparse_mode": {
                      "vrfs": []
                  },
                  "uplink_trunks": [],
                  "downlink_trunks": [],
                  "trunk_vlans": None,
                  "summarized_vlans": [],
              }
              my_config = set_base_config(my_config, my_switch_facts)
              my_config = set_trunks_config(my_config, my_switch_facts)
              dump_my_config(1)
              my_config = set_overlay_config(my_config, my_switch_facts)
              dump_my_config(2)
              my_config = set_network_services_config(my_config, my_switch_facts)
              dump_my_config(3)
              my_config = clean_config(my_config)
              if fabric_variables.get('summarizeVlans'):
                  my_config = summarize_vlans(my_config)
              dump_my_config(4)
          else:
              my_config = {}

          config = my_config
          dump_my_switch_facts(6)
          ctx.benchmarkDump()
          if not config:
              return
          %>
          ## eos - ip dhcp relay
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - ip dhcp snooping
          % if config.get("ip_dhcp_snooping"):
          ip dhcp snooping
          !
          %   if config["ip_dhcp_snooping"].get("information_option"):
          ip dhcp snooping information option
          %   endif
          %   if config["ip_dhcp_snooping"].get("vlans"):
          %       for vlan in config["ip_dhcp_snooping"]["vlans"]:
          ip dhcp snooping vlan ${vlan}
          %       endfor
          %   endif
          !
          % endif
          ## eos - IP IGMP Snooping
          % if config.get("ip_igmp_snooping"):
          %    if not config["ip_igmp_snooping"].get("globally_enabled"):
          no ip igmp snooping
          %    elif config["ip_igmp_snooping"].get("vlans"):
          %      for vlan in natural_sort(config["ip_igmp_snooping"]["vlans"], sort_key="id"):
          %          if not vlan.get("enabled"):
          no ip igmp snooping vlan ${ vlan['id'] }
          %          elif vlan.get("enabled", False) is True:
          ip igmp snooping vlan ${ vlan['id'] }
          %          endif
          %          if vlan.get("querier"):
          %              if vlan["querier"].get("enabled", False) is True:
          ip igmp snooping vlan ${ vlan["id"] } querier
          %              elif vlan["querier"].get("enabled", True) is False:
          no ip igmp snooping vlan ${ vlan["id"] } querier
          %              endif
          %              if vlan["querier"].get("address"):
          ip igmp snooping vlan ${ vlan["id"] } querier address ${ vlan["querier"]["address"] }
          %              endif
          %              if vlan["querier"].get("query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier query-interval ${ vlan["querier"]["query_interval"] }
          %              endif
          %              if vlan["querier"].get("max_response_time"):
          ip igmp snooping vlan ${ vlan["id"] } querier max-response-time ${ vlan["querier"]["max_response_time"] }
          %              endif
          %              if vlan["querier"].get("last_member_query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier last-member-query-interval ${ vlan["querier"]["last_member_query_interval"] }
          %              endif
          %              if vlan["querier"].get("last_member_query_count"):
          ip igmp snooping vlan ${ vlan["id"] } querier last-member-query-count ${ vlan["querier"]["last_member_query_count"] }
          %              endif
          %              if vlan["querier"].get("startup_query_interval"):
          ip igmp snooping vlan ${ vlan["id"] } querier startup-query-interval ${ vlan["querier"]["startup_query_interval"] }
          %              endif
          %              if vlan["querier"].get("startup_query_count"):
          ip igmp snooping vlan ${ vlan["id"] } querier startup-query-count ${ vlan["querier"]["startup_query_count"] }
          %              endif
          %              if vlan["querier"].get("version"):
          ip igmp snooping vlan ${ vlan["id"] } querier version ${ vlan["querier"]["version"] }
          %              endif
          %          endif
          %          if vlan.get("max_groups"):
          ip igmp snooping vlan ${ vlan["id"] } max-groups ${ vlan["max_groups"] }
          %          endif
          %          if vlan.get("fast_leave", False) is True:
          ip igmp snooping vlan ${ vlan["id"] } fast-leave
          %          elif vlan.get("fast_leave", True) is False:
          no ip igmp snooping vlan ${ vlan["id"] } fast-leave
          %          endif
          !
          %      endfor %}
          !
          %    endif
          % endif
          ## eos - VLANs
          % if config.get("vlans") is not None:
          %   if config.get("summarized_vlans"):
          %      for entry in config.get("summarized_vlans"):
          vlan ${ entry }
          <%         vlan = int(entry.replace('-',',').split(',')[0]) %>
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          %          if config["vlans"][vlan].get("etree") is not None and config["vlans"][vlan]["etree"]["role"] == "leaf":
             e-tree role ${ config["vlans"][vlan]["etree"]["role"] }
          %          endif
          !
          %      endfor
          %   else:
          %      for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          %          if config["vlans"][vlan].get("etree") is not None and config["vlans"][vlan]["etree"]["role"] == "leaf":
             e-tree role ${ config["vlans"][vlan]["etree"]["role"] }
          %          endif
          !
          %      endfor
          %   endif
          % endif
          ## vrfs
          % for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          % endfor
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Uplink VLAN Trunks
          % for trunk in natural_sort(config.get("uplink_trunks")):
          %     if config.get("trunk_vlans"):
          interface ${trunk}
             switchport trunk allowed vlan ${config.get("trunk_vlans")}
          !
          %     endif
          % endfor
          ## eos - Downlink VLAN Trunks
          % for trunk in natural_sort(config.get("downlink_trunks")):
          %     if config.get("trunk_vlans"):
          interface ${trunk}
             switchport trunk allowed vlan ${config.get("trunk_vlans")}
          !
          %     endif
          % endfor
          ## eos - Ethernet Interfaces
          % if config.get("ethernet_interfaces") is not None:
          %   for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("shutdown") in [True]:
             shutdown
          %     elif config["ethernet_interfaces"][ethernet_interface].get("shutdown") in [False]:
             no shutdown
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface]["type"] == "l3dot1q" and config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
             encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if l3_ip := config["ethernet_interfaces"][ethernet_interface].get("ip_address_v4"):
             ip address ${ l3_ip }
          %             if ip_secondaries := config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries_v4"):
          %                 for ip_address_secondary in ip_secondaries:
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if l3_ip := config["ethernet_interfaces"][ethernet_interface].get("ip_address_v6"):
             ipv6 address ${ l3_ip }
          %             if ip_secondaries := config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries_v6"):
          %                 for ip_address_secondary in ip_secondaries:
             ipv6 address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %       for statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Loopback Interfaces
          % if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if lb_ip := config["loopback_interfaces"][loopback_interface].get("ip_address_v4"):
             ip address ${ lb_ip }
          %           if ip_secondaries := config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries_v4"):
          %               for ip_address_secondary in ip_secondaries:
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          !
          %   endfor
          % endif
          ## vlan-interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface]["vrf"] != "default":
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if svi_ip := config.get("vlan_interfaces")[vlan_interface].get("ip_address_v4"):
             ip address ${ svi_ip }
          %       if ip_secondaries := config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries_v4"):
          %         for ip_address_secondary in ip_secondaries:
             ip address ${ ip_address_secondary } secondary
          %         endfor
          %       endif
          %     endif
          %     if svi_ip := config.get("vlan_interfaces")[vlan_interface].get("ip_address_v6"):
             ipv6 address ${ svi_ip }
          %       if ip_secondaries := config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries_v6"):
          %         for ip_address_secondary in ip_secondaries:
             ipv6 address ${ ip_address_secondary } secondary
          %         endfor
          %       endif
          %     endif
          %     if virps := config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses_v4"):
          %       for ip_virtual_router_address in virps:
             ip virtual-router address ${ ip_virtual_router_address }
          %       endfor
          %     endif
          %     if virps := config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses_v6"):
          %       for ip_virtual_router_address in virps:
             ipv6 virtual-router address ${ ip_virtual_router_address }
          %       endfor
          %     endif
          %     if vip := config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual_v4"):
             ip address virtual ${ vip }
          %     endif
          %     if vip := config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual_v6"):
             ipv6 address virtual ${ vip }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config["vlan_interfaces"][vlan_interface].get("ip_helpers").keys():
          <%
                    if is_ipv6(ip_helper):
                        ip_helper_cli = "ipv6 helper-address " + ip_helper
                    else:
                        ip_helper_cli = "ip helper-address " + ip_helper
          %>
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("arp_aging_timeout") is not None:
             arp aging timeout ${ config.get("vlan_interfaces")[vlan_interface]["arp_aging_timeout"] }
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("ip_igmp"):
             ip igmp
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("multicast"):
          %       if config.get("vlan_interfaces")[vlan_interface]["multicast"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("static"):
             multicast ipv4 static
          %           endif
          %       endif
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("pim"):
          %       if config.get("vlan_interfaces")[vlan_interface]["pim"].get("ipv4"):
          %           if config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %           if config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"].get("dr_priority"):
             pim ipv4 dr-priority ${ config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"]["dr_priority"] }
          %           endif
          %           if config.get("vlan_interfaces")[vlan_interface]["pim"]["ipv4"].get("local_interface"):
             pim ipv4 local-interface ${config.get("vlan_interfaces")[vlan_interface]["pim"]["ipv4"]["local_interface"]}
          %           endif
          %       endif
          %    endif
          %    if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %       for statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %    endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["source_interface"] }
          %     endif
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if (vlan_vni_ranges := config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlan_vni_ranges")):
             vxlan vlan ${ ",".join(vlan_vni_ranges.keys()) } vni ${ ",".join(vlan_vni_ranges.values()) }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys()):
          %               if not vlan_vni_ranges:
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %               endif
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan].get("multicast_group"):
             vxlan vlan ${ vlan } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["multicast_group"]}
          %               endif
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys()):
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf].get("multicast_group"):
             vxlan vrf ${ vrf } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["multicast_group"]}
          %               endif
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - IP Routing
          % if config.get("ipv4_routing") == True:
          ip routing
          !
          % elif config.get("ipv4_routing") == False:
          no ip routing
          !
          % endif
          % if config.get("ipv6_routing") == True:
          ipv6 unicast-routing
          !
          % elif config.get("ipv6_routing") == False:
          no ipv6 unicast-routing
          !
          % endif
          % for vrf in config.get("vrfs"):
          %     if config.get("vrfs")[vrf].get("ipv4_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %     elif config.get("vrfs")[vrf].get("ipv4_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %     endif
          %     if config.get("vrfs")[vrf].get("ipv6_routing") == True  and vrf != 'default':
          ipv6 unicast-routing vrf ${ vrf }
          %     elif config.get("vrfs")[vrf].get("ipv6_routing") == False  and vrf != 'default':
          no ipv6 unicast-routing vrf ${ vrf }
          %     endif
          % endfor
          !
          ## static routes
          % if config.get("static_routes"):
          %     for static_route in config["static_routes"]:
          <%
                    destIp = static_route.get("destination_address_prefix")
                    if is_ipv4(destIp):
                        static_route_cli = "ip route"
                    elif is_ipv6(destIp):
                        static_route_cli = "ipv6 route"
                    else:
                        continue
                    if static_route.get("vrf") != 'default':
                        static_route_cli = static_route_cli + " vrf " + static_route["vrf"]
                    static_route_cli = static_route_cli + " " + destIp
                    if intf := static_route.get("interface"):
                         static_route_cli = static_route_cli + " " + intf.upper()
                    if gateway := static_route.get("gateway"):
                         static_route_cli = static_route_cli + " " + gateway
                    if distance := static_route.get("distance"):
                         static_route_cli = static_route_cli + " " + distance
                    if tag := static_route.get("tag"):
                         static_route_cli = static_route_cli + " tag " + tag
                    if name := static_route.get("name"):
                         static_route_cli = static_route_cli + " name " + name
                    if metric := static_route.get("metric"):
                         static_route_cli = static_route_cli + " metric " + metric
          %>
          ${ static_route_cli }
          !
          %    endfor %}
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if ipv4 := config["virtual_source_nat_vrfs"][vrf].get("ip_address_v4"):
          ip address virtual source-nat vrf ${ vrf } address ${ ipv4 }
          %         endif
          %     endfor
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in natural_sort(config["route_maps"].keys()):
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## router-bgp
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("4basn_enabled"):
             bgp asn notation asdot
          %     endif
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
          <%            max_routes_cli = f"neighbor {peer_group} maximum-routes {config['router_bgp']['peer_groups'][peer_group]['maximum_routes']}" %>
          %             if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
          <%                max_routes_cli += f" warning-limit {config['router_bgp']['peer_groups'][peer_group]['maximum_routes_warning_limit']}"  %>
          %             endif
             ${max_routes_cli}
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in config["router_bgp"]["neighbors"].keys():
          %         if peer_group := config["router_bgp"]["neighbors"][neighbor].get("peer_group"):
             neighbor ${ neighbor } peer group ${ peer_group }
          %         endif
          %         if remote_as := config["router_bgp"]["neighbors"][neighbor].get("remote_as"):
          %           if remote_as_upper := config["router_bgp"]["neighbors"][neighbor].get("remote_as_upper"):
             neighbor ${ neighbor } remote-as ${ remote_as_upper }.${ remote_as }
          %           else:
             neighbor ${ neighbor } remote-as ${ remote_as }
          %           endif
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in natural_sort(config["router_bgp"]["vlans"]):
             !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].get("rd") is not None:
                rd ${ config["router_bgp"]["vlans"][vlan]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vlans"][vlan]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %         for cli_statement in config["router_bgp"]["vlans"][vlan].get("bgp_eos_cli", "").split("\n"):
                ${cli_statement}
          %         endfor
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         for cli_statement in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("bgp_eos_cli", "").split("\n"):
                ${cli_statement}
          %         endfor
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get('domain_remote'):
                neighbor ${ peer_group } domain remote
          %             endif
          %           endfor
          %           if config["router_bgp"]["address_family_evpn"].get('neighbor_default'):
          %               if config["router_bgp"]["address_family_evpn"]['neighbor_default'].get('next_hop_self_received_evpn_routes'):
          %                   if config["router_bgp"]["address_family_evpn"]['neighbor_default']['next_hop_self_received_evpn_routes'].get('enable'):
          <%                      evpn_neighbor_default_nhs_received_evpn_routes_cli = "neighbor default next-hop-self received-evpn-routes route-type ip-prefix" %>
          %                       if config["router_bgp"]["address_family_evpn"]['neighbor_default']['next_hop_self_received_evpn_routes'].get('inter_domain'):
          <%                          evpn_neighbor_default_nhs_received_evpn_routes_cli = evpn_neighbor_default_nhs_received_evpn_routes_cli + " inter-domain" %>
          %                       endif
                ${ evpn_neighbor_default_nhs_received_evpn_routes_cli }
          %                   endif
          %               endif
          %           endif
          %         endif
          %     endif
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in natural_sort(config["router_bgp"]["vrfs"].keys()):
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast"):
                evpn multicast
          %             if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast_address_family", {}).get("ipv4", {}).get("transit") is True:
                   address-family ipv4
          %                 if config["router_bgp"]["vrfs"][vrf]["evpn_multicast_address_family"]["ipv4"]["transit"] is True:
                      transit
          %                 endif
          %             endif
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("rd_evpn_domain") is not None:
          %             if config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"].get('domain') is not None and config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"].get('rd') is not None:
                rd evpn domain ${ config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"]["domain"] } ${ config["router_bgp"]["vrfs"][vrf]["rd_evpn_domain"]["rd"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import_evpn_domains"]:
                route-target import evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export_evpn_domains"]:
                route-target export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %        endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import_export_evpn_domains") is not None:
          %             for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import_export_evpn_domains"]:
                route-target import export evpn domain ${ route_target.get('domain') } ${ route_target.get('route_target') }
          %             endfor %}
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if remote_as := config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as"):
          %               if remote_as_upper := config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as_upper"):
                neighbor ${ neighbor } remote-as ${ remote_as_upper }.${ remote_as }
          %               else:
                neighbor ${ neighbor } remote-as ${ remote_as }
          %               endif
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if local_as := config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as"):
          %               if local_as_upper := config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as_upper"):
                neighbor ${ neighbor } local-as ${ local_as_upper }.${ local_as } no-prepend replace-as
          %               else:
                neighbor ${ neighbor } local-as ${ local_as } no-prepend replace-as
          %               endif
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + str(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
          <%                max_routes_cli = f"neighbor {neighbor} maximum-routes {config['router_bgp']['vrfs'][vrf]['neighbors'][neighbor]['maximum_routes']}" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes_warning_limit") is not None:
          <%                    max_routes_cli += f" warning-limit {config['router_bgp']['vrfs'][vrf]['neighbors'][neighbor]['maximum_routes_warning_limit']}"  %>
          %                 endif
                ${max_routes_cli}
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         for statement in config["router_bgp"]["vrfs"][vrf].get('eos_cli', []):
                ${ statement }
          %         endfor
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
                !
                address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                   neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                   ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
          ## eos - router multicast
          % if config.get("router_multicast"):
          router multicast
          %     for vrf in natural_sort(config["router_multicast"].get("vrfs", [])):
          %         if vrf["name"] != "default":
             vrf ${ vrf["name"] }
          %             if vrf.get("ipv4"):
                ipv4
          %             endif
          %             if vrf["ipv4"].get("routing") is True:
                   routing
          %             endif
             !
          %         endif
          %     endfor
          !
          % endif
          ## router pim sparse mode
          % if config.get('router_pim_sparse_mode'):
          router pim sparse-mode
          %     for vrf in natural_sort(config["router_pim_sparse_mode"].get("vrfs", [])):
          %         if vrf["name"] != "default":
             vrf ${ vrf["name"] }
          %             if vrf.get("ipv4"):
                ipv4
          %                 if vrf.get("bfd", False) is True:
                   bfd
          %                 endif
          %                 for rp_address in natural_sort(vrf["ipv4"].get("rp_addresses", [])):
          %                     if len(rp_address.get("groups", [])) > 0 or len(rp_address.get("access_lists", [])) > 0:
          %                         if rp_address.get("groups"):
          %                             for group in natural_sort(rp_address["groups"]):
                   rp address ${ rp_address["address"] } ${ group }
          %                             endfor
          %                         endif
          %                         if rp_address.get("access_lists"):
          %                             for access_list in natural_sort(rp_address["access_lists"]):
                   rp address ${ rp_address["address"] } access-list ${ access_list }
          %                             endfor
          %                         endif
          %                     else:
                   rp address ${ rp_address["address"] }
          %                     endif
          %                 endfor
          %             endif
             !
          %         endif
          %     endfor
          !
          % endif
      input_schema:
        fields:
          values:
            tenantName:
              id: tenantName
              name: name
              label: Name
              description: Specify a tenant name.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfName:
              id: vrfName
              name: name
              label: Name
              description: VRF Name
              required: true
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            iBgpSubnet:
              id: iBgpSubnet
              name: iBgpSubnet
              label: IPv4 Peering Subnet
              description: Define the subnet of the host IPv4 address for the iBGP peering of SVIs with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv4
                length: null
                pattern: null
                dynamic_options: null
            iBgpSubnetV6:
              id: iBgpSubnetV6
              name: iBgpSubnetV6
              label: IPv6 Peering Subnet
              description: Define the subnet of the host IPv6 address for the iBGP peering of SVIs with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv6
                length: null
                pattern: null
                dynamic_options: null
            iBgpVlanId:
              id: iBgpVlanId
              name: iBgpVlanId
              label: Peering VLAN
              description: Determine the VLAN used for iBGP peering with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            iBgpSubnetMask:
              id: iBgpSubnetMask
              name: iBgpSubnetMask
              label: IPv4 Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            iBgpSubnetMaskV6:
              id: iBgpSubnetMaskV6
              name: iBgpSubnetMaskV6
              label: IPv6 Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: 127
                static_options:
                  values:
                    - 126
                    - 127
                dynamic_options: null
            iBgpDetails:
              id: iBgpDetails
              name: iBgpDetails
              label: MLAG L3 Peering
              description: Create an iBGP peering between MLAG peers for this VRF.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - iBgpSubnet
                    - iBgpSubnetV6
                    - iBgpVlanId
                    - iBgpSubnetMask
                    - iBgpSubnetMaskV6
            natInterface:
              id: natInterface
              name: natInterface
              label: Source NAT Loopback ID
              description: Define the loopback interface used for sourcing pings within this VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSourceNatSubnet:
              id: campusSourceNatSubnet
              name: subnet
              label: Subnet
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            campusSite:
              id: campusSite
              name: site
              label: Site
              description: Set the source NAT interface IPv4 pool for the site. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Sites, enter a unique IPv4 pool per Site.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            sourceNatCampusResolver:
              id: sourceNatCampusResolver
              name: campus
              label: Campus Source NAT Subnets
              description: Select the campus for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSite
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            dataCenterSourceNatSubnet:
              id: dataCenterSourceNatSubnet
              name: subnet
              label: IPv4 Pool
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            dataCenterPod:
              id: dataCenterPod
              name: dcPoD
              label: DC PoD
              description: Set the source NAT interface IPv4 pool for the data center Pod. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Pods, enter a unique IPv4 pool per DC-Pod.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC-Pod
                tag_filter_query: null
            sourceNatDataCenterResolver:
              id: sourceNatDataCenterResolver
              name: dataCenter
              label: Data Center Source NAT Subnets
              description: Select the data center for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterPod
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC
                tag_filter_query: null
            natSourceDetails:
              id: natSourceDetails
              name: natSourceDetails
              label: Virtual Source NAT
              description: Create a loopback with virtual source-nat enabled to perform diagnostics from the device.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - natInterface
                    - sourceNatCampusResolver
                    - sourceNatDataCenterResolver
            vrfOverrideRouteDistinguisher:
              id: vrfOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideRouteTarget:
              id: vrfOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideVariables:
              id: vrfOverrideVariables
              name: overrideVariables
              label: Override VRF Attributes
              description: Enter values specific to this VRF to override the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOverrideRouteDistinguisher
                    - vrfOverrideRouteTarget
            vrfOverrideVNI:
              id: vrfOverrideVNI
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay.
              required: true
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Name
              description: Name of the interface or subinterface to configure (i.e. Ethernet1 or Ethernet1.100).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IPv4 Address
              description: Enter an IP address and subnet mask in CIDR notation.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv4
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddressV6:
              id: vrfL3InterfaceIpAddressV6
              name: ipAddressV6
              label: IPv6 Address
              description: Enter an IPv6 address and subnet mask in CIDR notation.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv6
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: Define EOS CLI statements to be configured under the interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceIpAddressV6
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: Create an IP routed interface inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: Non-selectively redistribute static routes.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            additionalRouteTargetsRouteTarget:
              id: additionalRouteTargetsRouteTarget
              name: routeTarget
              label: Route Target
              description: Use the format <integer>:<integer>.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsType:
              id: additionalRouteTargetsType
              name: type
              label: Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - import
                    - export
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsAddressFamily:
              id: additionalRouteTargetsAddressFamily
              name: addressFamily
              label: Address Family
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: evpn
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsApply:
              id: additionalRouteTargetsApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            additionalRouteTargetsHostname:
              id: additionalRouteTargetsHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            additionalRouteTargetsDevicesGroup:
              id: additionalRouteTargetsDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsHostname
            additionalRouteTargetsDevicesResolver:
              id: additionalRouteTargetsDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure route targets on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            additionalRouteTargetsDetails:
              id: additionalRouteTargetsDetails
              name: routeTargetDetails
              label: Route Target Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsRouteTarget
                    - additionalRouteTargetsType
                    - additionalRouteTargetsAddressFamily
                    - additionalRouteTargetsDevicesResolver
            additionalRouteTargets:
              id: additionalRouteTargets
              name: additionalRouteTargets
              label: Additional Route Targets
              description: Configure extra route-targets for this VRF. Useful for route-leaking or gateway between address families.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: additionalRouteTargetsDetails
                key: ''
            externalBgpPeersNeighborIpAddress:
              id: externalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRemoteAsUpper:
              id: externalBgpPeersRemoteAsUpper
              name: remoteAsUpper
              label: Remote ASN (Upper 2B)
              description: Define the Upper 2B of 4B Remote ASN in Dot Notation
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersRemoteAs:
              id: externalBgpPeersRemoteAs
              name: remoteAs
              label: Remote ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersDescription:
              id: externalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersPassword:
              id: externalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersSendCommunity:
              id: externalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopSelf:
              id: externalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersMaxRoutes:
              id: externalBgpPeersMaxRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWarningLimitRoutes:
              id: externalBgpPeersWarningLimitRoutes
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersMaxRoutesGroup:
              id: externalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersMaxRoutes
                    - externalBgpPeersWarningLimitRoutes
            externalBgpPeersUpdateSource:
              id: externalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: Name of source interface
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersEbgpMultihop:
              id: externalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWeight:
              id: externalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersRouteMapIn:
              id: externalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapOut:
              id: externalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapGroup:
              id: externalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: Enter the name of the route map to configure in/out for the peer.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersRouteMapIn
                    - externalBgpPeersRouteMapOut
            ebgpPeerDefaultOriginateEnable:
              id: ebgpPeerDefaultOriginateEnable
              name: ebgpPeerDefaultOriginateEnable
              label: Enable
              description: Enable default-originate for the peer.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginateAlways:
              id: externalBgpPeersDefaultOriginateAlways
              name: always
              label: Always
              description: The always option can be used to always artificially generate a default route and send this artificially generated default route to the neighbor irrespective of another default route being present in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginate:
              id: externalBgpPeersDefaultOriginate
              name: defaultOriginate
              label: Default Originate
              description: The default-originate feature is used to advertise a default route to the neighbor even when a default route is not present in the BGP RIB. If a default route is present in the BGP RIB, this route will be advertised to the neighbor. When a default route is not present in the BGP RIB, one will be artificially generated and advertised to the neighbor for which this feature is configured. This artificially generated default route will not be installed in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ebgpPeerDefaultOriginateEnable
                    - externalBgpPeersDefaultOriginateAlways
            externalBgpPeersNextHopIpv4:
              id: externalBgpPeersNextHopIpv4
              name: iPv4NextHop
              label: IP Next Hop
              description: 'Next Hop IPv4 or IPv6 Address'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopIpv6:
              id: externalBgpPeersNextHopIpv6
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: 'This field is deprecated.  Use IP Next Hop field.'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ipv6
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopGroup:
              id: externalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by a uniquely generated route-map per neighbor. Next hop takes precedence over route_map_out.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNextHopIpv4
                    - externalBgpPeersNextHopIpv6
            externalBgpPeersApply:
              id: externalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            externalBgpPeersHostname:
              id: externalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            externalBgpPeersDevicesGroup:
              id: externalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersHostname
            externalBgpPeersDevicesResolver:
              id: externalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the BGP neighbor on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            externalBgpPeersLocalAsUpper:
              id: externalBgpPeersLocalAsUpper
              name: localAsUpper
              label: Local ASN (Upper 2B)
              description: Define the Upper 2B of 4B Local ASN in Dot Notation
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersLocalAs:
              id: externalBgpPeersLocalAs
              name: localAs
              label: Local ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeeringName:
              id: externalBgpPeeringName
              name: bgpPeeringName
              label: Name
              description: Name of the BGP peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersDetails:
              id: externalBgpPeersDetails
              name: bgpPeerDetails
              label: BGP Peer Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNeighborIpAddress
                    - externalBgpPeersRemoteAsUpper
                    - externalBgpPeersRemoteAs
                    - externalBgpPeersDescription
                    - externalBgpPeersPassword
                    - externalBgpPeersSendCommunity
                    - externalBgpPeersNextHopSelf
                    - externalBgpPeersMaxRoutesGroup
                    - externalBgpPeersUpdateSource
                    - externalBgpPeersEbgpMultihop
                    - externalBgpPeersWeight
                    - externalBgpPeersRouteMapGroup
                    - externalBgpPeersDefaultOriginate
                    - externalBgpPeersNextHopGroup
                    - externalBgpPeersDevicesResolver
                    - externalBgpPeersLocalAsUpper
                    - externalBgpPeersLocalAs
                    - externalBgpPeeringName
            externalBgpPeers:
              id: externalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: Configure BGP neighbors inside the tenant VRF for peering with external devices. The configured peer will automatically be activated for IPv4 or IPv6 address family based on the IP address.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: externalBgpPeersDetails
                key: externalBgpPeeringName
            staticRoutesDescription:
              id: staticRoutesDescription
              name: description
              label: Description
              description: Unique description for the static route.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesApply:
              id: staticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            staticRoutesHostname:
              id: staticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            staticRoutesDevicesGroup:
              id: staticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesHostname
            staticRoutesDevicesResolver:
              id: staticRoutesDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the static route on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            staticRoutesDestinationAddressPrefix:
              id: staticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesGateway:
              id: staticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesInterface:
              id: staticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesDistance:
              id: staticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesTag:
              id: staticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesMetric:
              id: staticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesDetails:
              id: staticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDestinationAddressPrefix
                    - staticRoutesGateway
                    - staticRoutesInterface
                    - staticRoutesDistance
                    - staticRoutesTag
                    - staticRoutesMetric
            staticRoutesGroup:
              id: staticRoutesGroup
              name: value
              label: Static Routes Group
              description: Group of members for Static Routes
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDescription
                    - staticRoutesDevicesResolver
                    - staticRoutesDetails
            staticRoutesCollection:
              id: staticRoutesCollection
              name: staticRoutes
              label: Static Routes
              description: Create static routes inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: staticRoutesGroup
                key: staticRoutesDescription
            vrfAssignApply:
              id: vrfAssignApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfAssignHostname:
              id: vrfAssignHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfAssignDevicesGroup:
              id: vrfAssignDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfAssignHostname
            vrfAssignDevicesResolver:
              id: vrfAssignDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to apply this VRF to where the VRF won't be automatically applied from VLAN association, static routes, external BGP peerings, or additional route-targets.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfCliStatement:
              id: vrfCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfEosCliStatements:
              id: vrfEosCliStatements
              name: eosCli
              label: EOS CLI
              description: Raw EOS CLI statements to be configured under the Router BGP VRF definition.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfCliStatement
                key: ''
            vrfRouterBgp:
              id: vrfRouterBgp
              name: bgp
              label: BGP
              description: Configure additional BGP parameters for the VRF.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfEosCliStatements
            vrfL3EvpnMulticastEnabled:
              id: vrfL3EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable or Disable L3 Multicast
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsGroupName:
              id: vrfPimRpsGroupName
              name: name
              label: RP Group Name
              description: Group Name
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsIpAddressesIpAddress:
              id: vrfPimRpsIpAddressesIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsIpAddressesCollection:
              id: vrfPimRpsIpAddressesCollection
              name: rpIpAddresses
              label: RP IP Addresses
              description: A minimum of one RP must be specified
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpsIpAddressesIpAddress
                key: ''
            vrfPimRpsGroupAddressesGroupAddress:
              id: vrfPimRpsGroupAddressesGroupAddress
              name: groupAddress
              label: Group Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vrfPimRpsGroupAddressesCollection:
              id: vrfPimRpsGroupAddressesCollection
              name: groupAddresses
              label: Group Addresses
              description: 'List of groups to associate with the RP address.'
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpsGroupAddressesGroupAddress
                key: ''
            vrfPimRpAddressesDetails:
              id: vrfPimRpAddressesDetails
              name: pimRpAddressesDetails
              label: PIM RP Addresses Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfPimRpsGroupName
                    - vrfPimRpsIpAddressesCollection
                    - vrfPimRpsGroupAddressesCollection
            vrfPimRpAddressesCollection:
              id: vrfPimRpAddressesCollection
              name: pimRpAddresses
              label: PIM RP Addresses
              description: For each group of EVPN PEG nodes, allow configuration of RP Addresses & associated groups.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfPimRpAddressesDetails
                key: ''
            vrfEvpnPegTransitMode:
              id: vrfEvpnPegTransitMode
              name: transit
              label: Transit
              description: Enable EVPN PEG transit mode
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfEvpnPegResolver:
              id: vrfEvpnPegResolver
              name: evpnPeg
              label: EVPN PEG
              description: For each group of nodes, allow configuration of EVPN PEG features. Restrict configuration to specific nodes. Will apply to all nodes with RP addresses configured if not set.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfEvpnPegTransitMode
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfEvpnMulticastDetails:
              id: vrfEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: Explicitly enable or disable EVPN L3 Multicast to override Tenant Settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3EvpnMulticastEnabled
                    - vrfPimRpAddressesCollection
                    - vrfEvpnPegResolver
            enableVrfIpV4:
              id: enableVrfIpV4
              name: enableVrfIpV4
              label: Enable IPv4 for VRF
              description: Enable IPv4 for this VRF
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            enableVrfIpV6:
              id: enableVrfIpV6
              name: enableVrfIpV6
              label: Enable IPv6 for VRF
              description: Enable IPv6 for this VRF
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            enableVrfIpVersion:
              id: enableVrfIpVersion
              name: enableVrfIpVersion
              label: VRF IP Version Enables
              description: Select which IP versions to enable for the VRF
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - enableVrfIpV4
                    - enableVrfIpV6
            vrfGroup:
              id: vrfGroup
              name: vrfGroup
              label: VRF Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - iBgpDetails
                    - natSourceDetails
                    - vrfOverrideVariables
                    - vrfOverrideVNI
                    - vrfL3InterfacesDevice
                    - vrfRedistributeStaticRoutesToggle
                    - additionalRouteTargets
                    - externalBgpPeers
                    - staticRoutesCollection
                    - vrfAssignDevicesResolver
                    - vrfRouterBgp
                    - vrfEvpnMulticastDetails
                    - enableVrfIpVersion
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: Define L3 network services organized by VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfGroup
                key: vrfName
            vlanAwareBundleVlanRange:
              id: vlanAwareBundleVlanRange
              name: vlanRange
              label: VLAN Range
              description: Assign VLANs to this bundle with their VLAN IDs. Specify separate VLANs with a comma and series with a hyphen (e.g 1-9, 14, 23-40).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleName:
              id: vlanAwareBundleName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteDistinguisher:
              id: vlanAwareBundleOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteTarget:
              id: vlanAwareBundleOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideVariables:
              id: vlanAwareBundleOverrideVariables
              name: overrideVariables
              label: Overide MAC-VRF Attributes
              description: Enter values specific to this VRF to overide the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleOverrideRouteDistinguisher
                    - vlanAwareBundleOverrideRouteTarget
            vlanAwareBundleRedistributeLearnedToggle:
              id: vlanAwareBundleRedistributeLearnedToggle
              name: redistributeLearned
              label: Disable Redistribute Learned
              description: Option to disable redistribute learned.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vlanAwareBundleBgpEosCliStatements:
              id: vlanAwareBundleBgpEosCliStatements
              name: bgpEosCli
              label: BGP EOS CLI
              description: Enter EOS commands to configure in router bgp under the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareVlanMemberSwitchApply:
              id: vlanAwareVlanMemberSwitchApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanAwareVlanMemberSwitchHostname:
              id: vlanAwareVlanMemberSwitchHostname
              name: hostname
              label: Hostname
              description: The service will not be configured unless Apply is selected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanAwareVlanMemberSwitchApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vlanAwareVlanMemberSwitch:
              id: vlanAwareVlanMemberSwitch
              name: switch
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareVlanMemberSwitchHostname
            vlanAwareL2VlanMemberSwitches:
              id: vlanAwareL2VlanMemberSwitches
              name: switches
              label: VTEPs
              description: Assign the VLAN to devices.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanAwareVlanMemberSwitch
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanAwareL2VlanName:
              id: vlanAwareL2VlanName
              name: name
              label: Name
              description: Enter a one-word name for the VLANs in the bundle.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareL2VlanVxlanToggle:
              id: vlanAwareL2VlanVxlanToggle
              name: vxlan
              label: VXLAN
              description: Extend VLANs over the VXLAN overlay.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanAwareEtreeEnable:
              id: vlanAwareEtreeEnable
              name: etreeEnable
              label: Enable
              description: Enable Etree for L2 VLANs in Range
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vlanAwareLeafExportRouteTargetOffset:
              id: vlanAwareLeafExportRouteTargetOffset
              name: leafExportRouteTargetOffset
              label: Leaf Export Route Target Offset
              description: This number is added to the second half of the leaf export route target.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            vlanAwareEtreeDetails:
              id: vlanAwareEtreeDetails
              name: eTreeDetails
              label: Etree
              description: Enable Etree for this VLAN. All VTEPs will be a Leaf node by default. Root switches are specified below.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareEtreeEnable
                    - vlanAwareLeafExportRouteTargetOffset
            vlanAwareEtreeRole:
              id: vlanAwareEtreeRole
              name: role
              label: Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Root
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareEtreeRootSwitches:
              id: vlanAwareEtreeRootSwitches
              name: eTreeRootSwitches
              label: E Tree Root Switches
              description: Specify which switches are Etree Root for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanAwareEtreeRole
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanAwareL2VlanL2EvpnMulticastEnabled:
              id: vlanAwareL2VlanL2EvpnMulticastEnabled
              name: l2Enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareL2VlanEvpnMulticastDetails:
              id: vlanAwareL2VlanEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareL2VlanL2EvpnMulticastEnabled
            vlanAwareL2VlanAttributes:
              id: vlanAwareL2VlanAttributes
              name: l2Attributes
              label: L2 VLAN Attributes
              description: Enter attributes for the L2 VLANs of the VLAN Range.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareL2VlanMemberSwitches
                    - vlanAwareL2VlanName
                    - vlanAwareL2VlanVxlanToggle
                    - vlanAwareEtreeDetails
                    - vlanAwareEtreeRootSwitches
                    - vlanAwareL2VlanEvpnMulticastDetails
            vlanAwareVlanAttributes:
              id: vlanAwareVlanAttributes
              name: attributes
              label: VLAN Default Attributes
              description: Enter default attributes for VLANs of the VLAN Range.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareL2VlanAttributes
            vlanAwareBundleGroup:
              id: vlanAwareBundleGroup
              name: vlanGroup
              label: VLAN Bundle Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleVlanRange
                    - vlanAwareBundleName
                    - vlanAwareBundleOverrideVariables
                    - vlanAwareBundleRedistributeLearnedToggle
                    - vlanAwareBundleBgpEosCliStatements
                    - vlanAwareVlanAttributes
            vlanAwareBundles:
              id: vlanAwareBundles
              name: vlanAwareBundles
              label: VLAN Aware Bundles
              description: Configure a bundle of VLANs that share the same MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanAwareBundleGroup
                key: vlanAwareBundleName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: VLAN ID
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanBasedVlanName:
              id: vlanBasedVlanName
              name: name
              label: Name
              description: Enter a one-word name for the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanMemberSwitchApply:
              id: vlanMemberSwitchApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanMemberSwitchHostname:
              id: vlanMemberSwitchHostname
              name: hostname
              label: Hostname
              description: The service will not be configured unless Apply is selected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitchApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vlanMemberSwitch:
              id: vlanMemberSwitch
              name: switch
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanMemberSwitchHostname
            vlanMemberSwitches:
              id: vlanMemberSwitches
              name: switches
              label: VTEPs
              description: Assign the VLAN to devices.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitch
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanDhcpServers:
              id: vlanDhcpServers
              name: dhcpServer
              label: DHCP Server
              description: Enter the FQDN or the IP address of the DHCP server.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelperSourceInterface:
              id: vlanDhcpHelperSourceInterface
              name: sourceInterface
              label: Source Interface
              description: Enter an interface to source DHCP relays from
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpServerDetail:
              id: vlanDhcpServerDetail
              name: dhcpServerDetail
              label: DHCP Server Detail
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpServers
                    - vlanDhcpHelperSourceInterface
            vlanDhcpServerDetails:
              id: vlanDhcpServerDetails
              name: dhcpServerDetails
              label: DHCP Helper Details
              description: Specify the location of the DHCP server for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpServerDetail
                key: vlanDhcpServers
            vlanRedistributeLearnedToggle:
              id: vlanRedistributeLearnedToggle
              name: redistributeLearned
              label: Disable Redistribute Learned
              description: Option to disable redistribute learned.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vlanL3OrL2:
              id: vlanL3OrL2
              name: l3OrL2
              label: Routed or Bridged
              description: If set to 'Routed', both the L3 SVI and L2 VLAN will be configured on a selected L3 device. If set to 'Bridged', only the L2 VLAN will be configured on a selected L3 device. Only the L2 VLAN will be configured on any L2 devices downstream of the selected L3 device.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSviVirtualIpAddress:
              id: vlanSviVirtualIpAddress
              name: sviVirtualIpAddress
              label: SVI Virtual IPv4 Address
              description: Assign a virtual IPv4 address to be used on the VLAN's SVI. This will be the default IPv4 gateway for devices behind this VTEP on this VLAN. If the address type is 'ip address virtual' use CIDR notation (i.e. 192.168.0.1/24). If the address type is 'ip virtual-router address', enter either just an IPv4 address (i.e. 192.168.0.1) or an IPv4 address in CIDR notation (192.168.0.1/24).  If 'ip virtual-router address' is selected and an IPv4 Address is entered in CIDR notation, make sure to enter the appropriate values for the Primary Switch SVI IPv4 Address field and the Secondary Switch SVI IPv4 Address field.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanVirtualAddressConfigType:
              id: vlanVirtualAddressConfigType
              name: virtualAddressConfigType
              label: Virtual IPv4 Address Config Type
              description: Set the virtual IPv4 address type to be used to implement VARP.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanPrimarySwitchSviIpAddress:
              id: vlanPrimarySwitchSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Switch SVI IPv4 Address
              description: The real IPv4 address of SVI on the primary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlanSecondarySwitchSviIpAddress:
              id: vlanSecondarySwitchSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Switch SVI IPv4 Address
              description: The real IPv4 address of SVI on the secondary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlanSVIIpAddresses:
              id: vlanSVIIpAddresses
              name: sviIpAddresses
              label: SVI IPv4 Addresses
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviVirtualIpAddress
                    - vlanVirtualAddressConfigType
                    - vlanPrimarySwitchSviIpAddress
                    - vlanSecondarySwitchSviIpAddress
            vlanSviVirtualIpAddressV6:
              id: vlanSviVirtualIpAddressV6
              name: sviVirtualIpAddress
              label: SVI Virtual IPv6 Address
              description: Assign a virtual IPv6 address to be used on the VLAN's SVI. This will be the default IPv6 gateway for devices behind this VTEP on this VLAN. If the address type is 'ipv6 address virtual' use CIDR notation (i.e. 2024:192:168::1/64). If the address type is 'ipv6 virtual-router address', enter either just an IPv6 address (i.e. 2024:192:168::1) or an IPv6 address in CIDR notation (2024:192:168::1/64).  If 'ipv6 virtual-router address' is selected and an IPv6 Address is entered in CIDR notation, make sure to enter the appropriate values for the Primary Switch SVI IPv6 Address field and the Secondary Switch SVI IPv6 Address field.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanVirtualAddressConfigTypeV6:
              id: vlanVirtualAddressConfigTypeV6
              name: virtualAddressConfigType
              label: Virtual IPv6 Address Config Type
              description: Set the virtual IPv6 address type to be used to implement VARP.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanPrimarySwitchSviIpAddressV6:
              id: vlanPrimarySwitchSviIpAddressV6
              name: primarySwitchSviIpAddress
              label: Primary Switch SVI IPv6 Address
              description: The real IPv6 address of SVI on the primary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv6
                length: null
                pattern: null
                dynamic_options: null
            vlanSecondarySwitchSviIpAddressV6:
              id: vlanSecondarySwitchSviIpAddressV6
              name: secondarySwitchSviIpAddress
              label: Secondary Switch SVI IPv6 Address
              description: The real IPv6 address of SVI on the secondary switch of an MLAG pair.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv6
                length: null
                pattern: null
                dynamic_options: null
            vlanSVIIpAddressesV6:
              id: vlanSVIIpAddressesV6
              name: sviIpAddressesV6
              label: SVI IPv6 Addresses
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviVirtualIpAddressV6
                    - vlanVirtualAddressConfigTypeV6
                    - vlanPrimarySwitchSviIpAddressV6
                    - vlanSecondarySwitchSviIpAddressV6
            vlanOverrideVni:
              id: vlanOverrideVni
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanOverrideRouteDistinguisher:
              id: vlanOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideRouteTarget:
              id: vlanOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideVariables:
              id: vlanOverrideVariables
              name: overrideVariables
              label: Attribute Overrides
              description: Enter values specific to this VLAN and VRF to override the default generated attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanOverrideVni
                    - vlanOverrideRouteDistinguisher
                    - vlanOverrideRouteTarget
            vlanSviMtu:
              id: vlanSviMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '9214'
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpAgingTimeout:
              id: vlanSviArpAgingTimeout
              name: arpAgingTimeout
              label: ARP Aging Timeout
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpDetails:
              id: vlanSviArpDetails
              name: arp
              label: ARP
              description: Set the ARP aging timeout (seconds) for ARP entries for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviArpAgingTimeout
            vlanSviBgpEosCliStatements:
              id: vlanSviBgpEosCliStatements
              name: bgpEosCli
              label: BGP EOS CLI
              description: Enter EOS commands to configure in router bgp under the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviCliStatement:
              id: vlanSviCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCliStatements:
              id: vlanSviEosCliStatements
              name: eosCli
              label: Interface EOS CLI
              description: Enter EOS commands to configure under the VLAN interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviCliStatement
                key: ''
            vlanVrf:
              id: vlanVrf
              name: vrf
              label: VRF
              description: Assign the VLAN to a VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            vlanVxlanToggle:
              id: vlanVxlanToggle
              name: vxlan
              label: VXLAN
              description: Extend this VLAN over the VXLAN overlay. If not extending, SVI parameters are defined by selecting each VTEP and separately configuring.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            nodeSviIpAddress:
              id: nodeSviIpAddress
              name: ipAddress
              label: IPv4 Address
              description: Enter an IPv4 address and subnet mask in CIDR notation for the SVI (i.e. 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv4
                length: null
                pattern: null
                dynamic_options: null
            nodeVirtualSviIpAddress:
              id: nodeVirtualSviIpAddress
              name: virtualIpAddress
              label: Virtual IPv4 Address
              description: Enter an IPv4 address and optionally a subnet mask for the SVI (i.e. 1.1.1.1 or 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            nodeSviIpAddressV6:
              id: nodeSviIpAddressV6
              name: ipAddressV6
              label: IPv6 Address
              description: Enter an IPv6 address and subnet mask in CIDR notation for the SVI (i.e. 2024:1:1:1::1/64).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidrv6
                length: null
                pattern: null
                dynamic_options: null
            nodeVirtualSviIpAddressV6:
              id: nodeVirtualSviIpAddressV6
              name: virtualIpAddressV6
              label: Virtual IPv6 Address
              description: Enter an IPv6 address and optionally a subnet mask for the SVI (i.e. 2024:1:1:1::1 or 2024:1:1:1::1/64).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            autoGenNodeVlanVni:
              id: autoGenNodeVlanVni
              name: autoGenNodeVlanVni
              label: Auto-Generate VNI
              description: Auto-generate VNI for this Node's re-use of VLAN ( VNI = <MAC-VRF VNI Base> + 10,000 * <Leaf-Domain> + <VLAN ID> )
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            nodeVlanOverrideVni:
              id: nodeVlanOverrideVni
              name: nodeVlanOverrideVni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            nodeSviIpInfo:
              id: nodeSviIpInfo
              name: sviIpInfo
              label: SVI IP Info
              description: Override dynamically allocated addresses
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - nodeSviIpAddress
                    - nodeVirtualSviIpAddress
                    - nodeSviIpAddressV6
                    - nodeVirtualSviIpAddressV6
                    - autoGenNodeVlanVni
                    - nodeVlanOverrideVni
            nodeVlanDetails:
              id: nodeVlanDetails
              name: nodes
              label: Node Attribute Overrides
              description: Override VLAN attributes per device
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: nodeSviIpInfo
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            etreeEnable:
              id: etreeEnable
              name: etreeEnable
              label: Enable
              description: Enable Etree for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            leafExportRouteTargetOffset:
              id: leafExportRouteTargetOffset
              name: leafExportRouteTargetOffset
              label: Leaf Export Route Target Offset
              description: This number is added to the second half of the leaf export route target.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            eTreeDetails:
              id: eTreeDetails
              name: eTreeDetails
              label: Etree
              description: Enable Etree for this VLAN. All VTEPs will be a Leaf node by default. Root switches are specified below.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - etreeEnable
                    - leafExportRouteTargetOffset
            etreeRole:
              id: etreeRole
              name: role
              label: Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Root
                format: null
                length: null
                pattern: null
                dynamic_options: null
            etreeRootSwitches:
              id: etreeRootSwitches
              name: eTreeRootSwitches
              label: E Tree Root Switches
              description: Specify which switches are Etree Root for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: etreeRole
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanL2EvpnMulticastEnabled:
              id: vlanL2EvpnMulticastEnabled
              name: l2Enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanL3EvpnMulticastEnabled:
              id: vlanL3EvpnMulticastEnabled
              name: l3Enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanEvpnMulticastDetails:
              id: vlanEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanL2EvpnMulticastEnabled
                    - vlanL3EvpnMulticastEnabled
            enableVlanIpV4:
              id: enableVlanIpV4
              name: enableVlanIpV4
              label: Enable IPv4 for VLAN
              description: Enable IPv4 for this VLAN
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            enableVlanIpV6:
              id: enableVlanIpV6
              name: enableVlanIpV6
              label: Enable IPv6 for VLAN
              description: Enable IPv6 for this VLAN
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            enableVlanIpVersion:
              id: enableVlanIpVersion
              name: enableVlanIpVersion
              label: VLAN IP Version Enables
              description: Select which IP versions to enable for the VLAN
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - enableVlanIpV4
                    - enableVlanIpV6
            vlanBasedVlans:
              id: vlanBasedVlans
              name: vlanBasedVlaNs
              label: VLAN Definitions
              description: VLAN based VLANs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanBasedVlanName
                    - vlanMemberSwitches
                    - vlanDhcpServerDetails
                    - vlanRedistributeLearnedToggle
                    - vlanL3OrL2
                    - vlanSVIIpAddresses
                    - vlanSVIIpAddressesV6
                    - vlanOverrideVariables
                    - vlanSviMtu
                    - vlanSviArpDetails
                    - vlanSviEosCliStatements
                    - vlanSviBgpEosCliStatements
                    - vlanVrf
                    - vlanVxlanToggle
                    - nodeVlanDetails
                    - eTreeDetails
                    - etreeRootSwitches
                    - vlanEvpnMulticastDetails
                    - enableVlanIpVersion
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: Define L2 network services organized by VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanBasedVlans
                key: vlanId
            macVrfVniBase:
              id: macVrfVniBase
              name: macVrfVniBase
              label: MAC-VRF VNI Base
              description: Set the default number that generates each Virtual Network Identifier by adding it to the specific VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            tenantL3EvpnMulticastEnabled:
              id: tenantL3EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable/Disable L3 Multicast (OISM)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantEvpnPegTransitMode:
              id: tenantEvpnPegTransitMode
              name: transit
              label: Transit
              description: Enable EVPN PEG transit mode
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantEvpnPegResolver:
              id: tenantEvpnPegResolver
              name: evpnPeg
              label: EVPN PEG
              description: For each group of nodes, allow configuration of EVPN PEG features. Restrict configuration to specific nodes. Will apply to all nodes with RP addresses configured if not set.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: tenantEvpnPegTransitMode
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            tenantPimRpsGroupName:
              id: tenantPimRpsGroupName
              name: name
              label: Group Name
              description: Group Name
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsIpAddressesIpAddress:
              id: tenantPimRpsIpAddressesIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsIpAddressesCollection:
              id: tenantPimRpsIpAddressesCollection
              name: rpIpAddresses
              label: RP IP Addresses
              description: List of Rendevouz Points
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpsIpAddressesIpAddress
                key: ''
            tenantPimRpsGroupAddressesGroupAddress:
              id: tenantPimRpsGroupAddressesGroupAddress
              name: groupAddress
              label: Group Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantPimRpsGroupAddressesCollection:
              id: tenantPimRpsGroupAddressesCollection
              name: groupAddresses
              label: Group Addresses
              description: 'List of groups to associate with the RP address.'
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpsGroupAddressesGroupAddress
                key: ''
            tenantPimRpAddressesDetails:
              id: tenantPimRpAddressesDetails
              name: pimRpAddressesDetails
              label: PIM RP Addresses Details
              description: Group of members for PIM RP Addresses
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantPimRpsGroupName
                    - tenantPimRpsIpAddressesCollection
                    - tenantPimRpsGroupAddressesCollection
            tenantPimRpAddressesCollection:
              id: tenantPimRpAddressesCollection
              name: pimRpAddresses
              label: PIM RP Addresses
              description: For each group of EVPN PEG nodes, allow configuration of RP Addresses & associated groups.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantPimRpAddressesDetails
                key: ''
            tenantL3EvpnMulticastGroupIpv4Pool:
              id: tenantL3EvpnMulticastGroupIpv4Pool
              name: evpnUnderlayL3MulticastGroupIpv4Pool
              label: Multicast Group Pool
              description: 'Pool to assign overlay multicast address bindings from. Pool is assigned using the following formula: < L3 Multicast Group Pool > + < VRF VNI - 1 > + < L3 Multicast Group Pool Offset >. The recommendation is to assign a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantL3EvpnMulticastGroupIpv4PoolOffset:
              id: tenantL3EvpnMulticastGroupIpv4PoolOffset
              name: evpnUnderlayL3MulticastGroupIpv4PoolOffset
              label: Multicast Group Pool Offset
              description: 'Offset used in the VXLAN, VLAN, multicast group IPv4 address binding formula (Value should be an integer)'
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: 0
                range: null
                static_options: null
                dynamic_options: null
            tenantL3EvpnMulticast:
              id: tenantL3EvpnMulticast
              name: evpnUnderlayMulticast
              label: EVPN Underlay Multicast
              description: Configure underlay multicast groups
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastGroupIpv4Pool
                    - tenantL3EvpnMulticastGroupIpv4PoolOffset
            tenantL3EvpnMulticastDetails:
              id: tenantL3EvpnMulticastDetails
              name: l3Multicast
              label: L3 Multicast
              description: Enable L3 Multicast (OISM) for all SVIs and l3vlans within Tenant
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastEnabled
                    - tenantEvpnPegResolver
                    - tenantPimRpAddressesCollection
                    - tenantL3EvpnMulticast
            tenantL2EvpnMulticastEnabled:
              id: tenantL2EvpnMulticastEnabled
              name: enabled
              label: Enabled
              description: Enable/Disable EVPN L2 Multicast
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantL2EvpnMulticastEnabledOnSvis:
              id: tenantL2EvpnMulticastEnabledOnSvis
              name: enabledSvis
              label: Enabled also on SVIs
              description: Enable/Disable EVPN L2 Multicast additionally on SVIs
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 'No'
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            tenantL2EvpnMulticastGroupIpv4Pool:
              id: tenantL2EvpnMulticastGroupIpv4Pool
              name: evpnUnderlayL2MulticastGroupIpv4Pool
              label: Multicast Group Pool
              description: 'Pool to assign overlay multicast address bindings from. Pool is assigned using the following formula:  < L2 Multicast Group Pool > + < Vlan ID - 1 > + < L2 Multicast Group Pool Offset >. The recommendation is to assign a /20 block within the 232.0.0.0/8 Source-Specific Multicast range.'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            tenantL2EvpnMulticastGroupIpv4PoolOffset:
              id: tenantL2EvpnMulticastGroupIpv4PoolOffset
              name: evpnUnderlayL2MulticastGroupIpv4PoolOffset
              label: Multicast Group Pool Offset
              description: 'Offset used in the VXLAN, VLAN, multicast group IPv4 address binding formula (Value should be an integer)'
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: 0
                range: null
                static_options: null
                dynamic_options: null
            tenantL2EvpnMulticast:
              id: tenantL2EvpnMulticast
              name: evpnUnderlayMulticast
              label: EVPN Underlay Multicast
              description: Configure the underlay multicast groups
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL2EvpnMulticastGroupIpv4Pool
                    - tenantL2EvpnMulticastGroupIpv4PoolOffset
            tenantL2EvpnMulticastDetails:
              id: tenantL2EvpnMulticastDetails
              name: l2Multicast
              label: L2 Multicast
              description: Enable EVPN L2 Multicast for all SVIs and l2vlans within Tenant.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL2EvpnMulticastEnabled
                    - tenantL2EvpnMulticastEnabledOnSvis
                    - tenantL2EvpnMulticast
            tenantEvpnMulticastDetails:
              id: tenantEvpnMulticastDetails
              name: evpnMulticast
              label: EVPN Multicast
              description: 'Configure L2/L3 EVPN Multicast '
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantL3EvpnMulticastDetails
                    - tenantL2EvpnMulticastDetails
            tenantDefinition:
              id: tenantDefinition
              name: tenantDefinition
              label: Tenant Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantName
                    - vrfs
                    - vlanAwareBundles
                    - vlans
                    - macVrfVniBase
                    - tenantEvpnMulticastDetails
            tenants:
              id: tenants
              name: tenants
              label: Tenants
              description: Network services are grouped by tenants. This allows for granular deployment of network service to the fabric leveraging the tenant name and tags applied to the service definition.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantDefinition
                key: tenantName
            vrfRouteDistinguisherFormat:
              id: vrfRouteDistinguisherFormat
              name: vrfRouteDistinguisherFormat
              label: VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - VTEP Source IP:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfRouteTargetFormat:
              id: vrfRouteTargetFormat
              name: vrfRouteTargetFormat
              label: VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                    - Upper-2B-ASN:VNI
                    - Lower-2B-ASN:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfAttributeFormats:
              id: vrfAttributeFormats
              name: vrfAttributeFormats
              label: VRF Attributes
              description: Set the default format for how VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfRouteDistinguisherFormat
                    - vrfRouteTargetFormat
            vlanBasedMacVrfRouteDistinguisherFormat:
              id: vlanBasedMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - Router-ID:VLAN
                    - VTEP Source IP:VNI
                    - VTEP Source IP:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfRouteTargetFormat:
              id: vlanBasedMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                    - VLAN:VLAN
                    - VLAN:VNI
                    - Upper-2B-ASN:VNI
                    - Lower-2B-ASN:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfAttributeFormats:
              id: vlanBasedMacVrfAttributeFormats
              name: vlanBasedMacVrfAttributeFormats
              label: VLAN Based MAC-VRF Attributes
              description: Set the default format for how VLAN based MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBasedMacVrfRouteDistinguisherFormat
                    - vlanBasedMacVrfRouteTargetFormat
            vlanBundleMacVrfRouteDistinguisherFormat:
              id: vlanBundleMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:First-VLAN
                static_options:
                  values:
                    - Router-ID:First-VLAN
                    - Router-ID:First-VNI
                    - Router-ID:Last-VLAN
                    - Router-ID:Last-VNI
                    - VTEP Source IP:First-VNI
                    - VTEP Source IP:Last-VLAN
                    - VTEP Source IP:First-VLAN
                    - VTEP Source IP:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfRouteTargetFormat:
              id: vlanBundleMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: First-VNI:Last-VNI
                static_options:
                  values:
                    - First-VLAN:First-VLAN
                    - First-VNI:First-VNI
                    - Last-VLAN:Last-VLAN
                    - Last-VNI:Last-VNI
                    - First-VLAN:Last-VLAN
                    - First-VNI:Last-VNI
                    - Upper-2B-ASN:First-VNI
                    - Lower-2B-ASN:First-VNI
                    - Upper-2B-ASN:Last-VNI
                    - Lower-2B-ASN:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfAttributeFormats:
              id: vlanBundleMacVrfAttributeFormats
              name: vlanBundleMacVrfAttributeFormats
              label: VLAN Bundle MAC-VRF Attributes
              description: Set the default format for how VLAN bundled MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBundleMacVrfRouteDistinguisherFormat
                    - vlanBundleMacVrfRouteTargetFormat
            evpnGwVtepPeerHostname:
              id: evpnGwVtepPeerHostname
              name: peerHostname
              label: Peer Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnGwVtepPeerIpAddress:
              id: evpnGwVtepPeerIpAddress
              name: peerIpAddress
              label: Peer IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: ip
                length: null
                pattern: null
                dynamic_options: null
            evpnGwVtepPeerBgpAsnUpper:
              id: evpnGwVtepPeerBgpAsnUpper
              name: peerBgpAsnUpper
              label: Peer BGP ASN (Upper 2B)
              description: Define the Upper 2B of 4B Peer BGP ASN in Dot Notation
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            evpnGwVtepPeerBgpAsn:
              id: evpnGwVtepPeerBgpAsn
              name: peerBgpAsn
              label: Peer BGP ASN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            remoteEvpnGatewayVtepDetails:
              id: remoteEvpnGatewayVtepDetails
              name: remoteEvpnGatewayVtepDetails
              label: Remote EVPN Gateway VTEP Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnGwVtepPeerHostname
                    - evpnGwVtepPeerIpAddress
                    - evpnGwVtepPeerBgpAsnUpper
                    - evpnGwVtepPeerBgpAsn
            remoteEvpnGatewayVtepPeers:
              id: remoteEvpnGatewayVtepPeers
              name: remoteEvpnGatewayVtepPeers
              label: Remote EVPN Gateway VTEP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: remoteEvpnGatewayVtepDetails
                key: ''
            remoteEvpnGatewayVtepEvpnL2Enable:
              id: remoteEvpnGatewayVtepEvpnL2Enable
              name: enable
              label: Enable
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            remoteEvpnGatewayVtepEvpnL2Details:
              id: remoteEvpnGatewayVtepEvpnL2Details
              name: evpnL2
              label: EVPN L2
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepEvpnL2Enable
            remoteEvpnGatewayVtepEvpnL3Enable:
              id: remoteEvpnGatewayVtepEvpnL3Enable
              name: enable
              label: Enable
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            remoteEvpnGatewayVtepEvpnL3InterDomain:
              id: remoteEvpnGatewayVtepEvpnL3InterDomain
              name: interDomain
              label: Inter-Domain
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            remoteEvpnGatewayVtepEvpnL3Details:
              id: remoteEvpnGatewayVtepEvpnL3Details
              name: evpnL3
              label: EVPN L3
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepEvpnL3Enable
                    - remoteEvpnGatewayVtepEvpnL3InterDomain
            remoteEvpnGatewayVtepsDetails:
              id: remoteEvpnGatewayVtepsDetails
              name: remoteEvpnGatewayVtepsDetails
              label: Remote EVPN Gateway VTEPs Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - remoteEvpnGatewayVtepPeers
                    - remoteEvpnGatewayVtepEvpnL2Details
                    - remoteEvpnGatewayVtepEvpnL3Details
            evpnGatewayVteps:
              id: evpnGatewayVteps
              name: evpnGatewayVteps
              label: EVPN Gateway VTEPs
              description: Assign devices as EVPN-VXLAN gateways. This feature is only supported on select Jericho based platforms running EOS 4.26.1F or greater.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: remoteEvpnGatewayVtepsDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            evpnOverlayCoreBgpPeerGroupName:
              id: evpnOverlayCoreBgpPeerGroupName
              name: name
              label: Name
              description: Name of the peer group. If nothing is entered, the default name will be used.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnOverlayCoreBgpPeerGroupPassword:
              id: evpnOverlayCoreBgpPeerGroupPassword
              name: password
              label: Password
              description: Enter the encrypted password for the peer group.  If nothing is entered, no password will be used in the BGP peering.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            evpnOverlayCorePeerGroupSettings:
              id: evpnOverlayCorePeerGroupSettings
              name: evpnOverlayCorePeerGroup
              label: EVPN Overlay Core Peer Group
              description: Settings for the BGP peer group used to establish peerings between EVPN gateway VTEPs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnOverlayCoreBgpPeerGroupName
                    - evpnOverlayCoreBgpPeerGroupPassword
            bgpPeerGroupSettings:
              id: bgpPeerGroupSettings
              name: bgpPeerGroupSettings
              label: BGP Peer Group Settings
              description: Customize BGP peer group properties.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - evpnOverlayCorePeerGroupSettings
            pruneVlansToggle:
              id: pruneVlansToggle
              name: pruneVlansToggle
              label: Prune VLANs on L2 Trunks
              description: Allow only necessary VLANs based on what services are applied to switches.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            l2trunkSettings:
              id: l2trunkSettings
              name: l2trunkSettings
              label: L2 Trunk Settings
              description: Customize L2 trunk properties.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - pruneVlansToggle
            vlanVniSummaryToggle:
              id: vlanVniSummaryToggle
              name: vlanVniSummaryToggle
              label: Summarize VLAN to VNI Mappings
              description: Use ranges to summarize VLAN to VNI mappings under Vxlan interface.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            evpnSettings:
              id: evpnSettings
              name: evpnSettings
              label: VXLAN Settings
              description: Customize EVPN properties.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanVniSummaryToggle
            vlanSummaryToggle:
              id: vlanSummaryToggle
              name: vlanSummaryToggle
              label: Summarize VLAN Config
              description: Use ranges to summarize studio generated global VLAN config. If this toggle is off EOS will still summarize it.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSettings:
              id: vlanSettings
              name: vlanSettings
              label: VLAN Settings
              description: Customize VLAN properties.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSummaryToggle
            overlayLoopbackNumber:
              id: overlayLoopbackNumber
              name: overlayLoopbackNumber
              label: Overlay Loopback Interface Number
              description: Select the loopback interface number to be used
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '0'
                range: 0..8191
                static_options: null
                dynamic_options: null
            loopbackSettings:
              id: loopbackSettings
              name: loopbackSettings
              label: Loopback Settings
              description: Settings related to the loopbacks
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - overlayLoopbackNumber
            asnDotNotationAllow:
              id: asnDotNotationAllow
              name: asnDotNotationAllow
              label: Allow 4B ASN Dot Notation
              description: Allow 4B ASN Dot Notation for DC Nodes
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            asnSettings:
              id: asnSettings
              name: asnSettings
              label: ASN Preferences
              description: Select ASN Preferences for the DC
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - asnDotNotationAllow
            advancedSettings:
              id: advancedSettings
              name: advancedSettings
              label: Advanced Settings
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - bgpPeerGroupSettings
                    - l2trunkSettings
                    - evpnSettings
                    - vlanSettings
                    - loopbackSettings
                    - asnSettings
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenants
                    - vrfAttributeFormats
                    - vlanBasedMacVrfAttributeFormats
                    - vlanBundleMacVrfAttributeFormats
                    - evpnGatewayVteps
                    - advancedSettings
        layout:
          value: |
            {
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "tenants":{
                "key":"tenants",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanBasedVlans":{
                "key":"vlanBasedVlans",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlanMemberSwitches",
                  "vlanBasedVlanName",
                  "vlanVxlanToggle",
                  "vlanL3OrL2",
                  "vlanVrf",
                  "vlanSVIIpAddresses",
                  "vlanSVIIpAddressesV6",
                  "vlanDhcpServerDetails",
                  "vlanSviMtu",
                  "vlanSviArpDetails",
                  "eTreeDetails",
                  "etreeRootSwitches",
                  "vlanSviEosCliStatements",
                  "vlanSviBgpEosCliStatements",
                  "vlanEvpnMulticastDetails",
                  "vlanOverrideVariables",
                  "nodeVlanDetails",
                  "enableVlanIpVersion",
                  "vlanRedistributeLearnedToggle"
                ]
              },
              "vrfGroup":{
                "key":"vrfGroup",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfOverrideVNI",
                  "iBgpDetails",
                  "natSourceDetails",
                  "vrfL3InterfacesDevice",
                  "staticRoutesCollection",
                  "vrfRedistributeStaticRoutesToggle",
                  "externalBgpPeers",
                  "vrfRouterBgp",
                  "additionalRouteTargets",
                  "vrfEvpnMulticastDetails",
                  "vrfAssignDevicesResolver",
                  "vrfOverrideVariables",
                  "enableVrfIpVersion"
                ]
              },
              "vlanL3OrL2":{
                "key":"vlanL3OrL2",
                "valueToLabelMap":{
                  "True":"Routed",
                  "False":"Bridged"
                },
                "type":"INPUT"
              },
              "tenantDefinition":{
                "key":"tenantDefinition",
                "type":"INPUT",
                "order":[
                  "tenantName",
                  "vrfs",
                  "macVrfVniBase",
                  "vlans",
                  "vlanAwareBundles",
                  "tenantEvpnMulticastDetails"
                ]
              },
              "iBgpDetails":{
                "key":"iBgpDetails",
                "type":"INPUT",
                "order":[
                  "iBgpVlanId",
                  "iBgpSubnet",
                  "iBgpSubnetMask",
                  "iBgpSubnetV6",
                  "iBgpSubnetMaskV6"
                ]
              },
              "iBgpSubnet":{
                "key":"iBgpSubnet",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "iBgpSubnetMask":{
                "key":"iBgpSubnetMask",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "iBgpSubnetV6":{
                "key":"iBgpSubnetV6",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "iBgpSubnetMaskV6":{
                "key":"iBgpSubnetMaskV6",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "externalBgpPeersNextHopIpv6":{
                "key":"externalBgpPeersNextHopIpv6",
                "type":"INPUT",
                "dependency":{
                  "vrfName":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "vlanDhcpServerVrf":{
                "key":"vlanDhcpServerVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanDhcpServers":{
                "key":"vlanDhcpServers",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareEtreeRootSwitches":{
                "key":"vlanAwareEtreeRootSwitches",
                "type":"INPUT",
                "isPageLayout":false,
                "showDefaultRow":false
              },
              "vlanAwareEtreeRole":{
                "key":"vlanAwareEtreeRole",
                "dependency":{
                  "vlanAwareEtreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareLeafExportRouteTargetOffset":{
                "key":"vlanAwareLeafExportRouteTargetOffset",
                "dependency":{
                  "vlanAwareEtreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareLeafExportRouteTargetOffset":{
                "key":"vlanAwareLeafExportRouteTargetOffset",
                "dependency":{
                  "vlanAwareEtreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareVlanMemberSwitchApply":{
                "key":"vlanAwareVlanMemberSwitchApply",
                "dependency":{
                  "vlanAwareVlanMemberSwitchApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareVlanMemberSwitch":{
                "key":"vlanAwareVlanMemberSwitch",
                "type":"INPUT",
                "order":[
                  "vlanAwareVlanMemberSwitchHostname",
                  "vlanAwareL2VlanDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "vlanAwareL2VlanMemberSwitches":{
                "key":"vlanAwareL2VlanMemberSwitches",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vlanAwareL2VlanL2EvpnMulticastEnabled":{
                "key":"vlanAwareL2VlanL2EvpnMulticastEnabled",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vlanAwareL2VlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanAwareL2VlanAttributes":{
                "key":"vlanAwareL2VlanBasedVlans",
                "type":"INPUT",
                "order":[
                  "vlanAwareL2VlanMemberSwitches",
                  "vlanAwareL2VlanName",
                  "vlanAwareL2VlanVxlanToggle",
                  "vlanAwareEtreeDetails",
                  "vlanAwareEtreeRootSwitches",
                  "vlanAwareL2VlanEvpnMulticastDetails"
                ]
              },
              "vlanAwareBundleGroup":{
                "key":"vlanAwareBundleGroup",
                "type":"INPUT",
                "order":[
                  "vlanAwareBundleName",
                  "vlanAwareBundleVlanRange",
                  "vlanAwareBundleOverrideVariables",
                  "vlanAwareBundleRedistributeLearnedToggle",
                  "vlanAwareBundleBgpEosCliStatements",
                  "vlanAwareVlanAttributes"
                ]
              },
              "vlanAwareBundles":{
                "key":"vlanAwareBundles",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanMemberSwitches":{
                "key":"vlanMemberSwitches",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vlanVrf":{
                "key":"vlanVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfOverrideVariables":{
                "key":"vrfOverrideVariables",
                "type":"INPUT",
                "order":[
                  "vrfOverrideRouteDistinguisher",
                  "vrfOverrideRouteTarget"
                ]
              },
              "vlanMemberSwitchApply":{
                "key":"vlanMemberSwitchApply",
                "dependency":{
                  "vlanMemberSwitchApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSVIIpAddresses":{
                "key":"vlanSVIIpAddresses",
                "type":"INPUT",
                "order":[
                  "vlanSviVirtualIpAddress",
                  "vlanVirtualAddressConfigType",
                  "vlanPrimarySwitchSviIpAddress",
                  "vlanSecondarySwitchSviIpAddress"
                ]
              },
              "vlanSVIIpAddresses":{
                "key":"vlanSVIIpAddresses",
                "type":"INPUT",
                "dependency":{
                  "enableVlanIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSviVirtualIpAddress":{
                "key":"vlanSviVirtualIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanVirtualAddressConfigType":{
                "key":"vlanVirtualAddressConfigType",
                "valueToLabelMap":{
                  "True":"ip address virtual",
                  "False":"ip virtual-router address"
                },
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanPrimarySwitchSviIpAddress":{
                "key":"vlanPrimarySwitchSviIpAddress",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSecondarySwitchSviIpAddress":{
                "key":"vlanSecondarySwitchSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSVIIpAddressesV6":{
                "key":"vlanSVIIpAddressesV6",
                "type":"INPUT",
                "order":[
                  "vlanSviVirtualIpAddressV6",
                  "vlanVirtualAddressConfigTypeV6",
                  "vlanPrimarySwitchSviIpAddressV6",
                  "vlanSecondarySwitchSviIpAddressV6"
                ]
              },
              "vlanSVIIpAddressesV6":{
                "key":"vlanSVIIpAddressesV6",
                "type":"INPUT",
                "dependency":{
                  "enableVlanIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSviVirtualIpAddressV6":{
                "key":"vlanSviVirtualIpAddressV6",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanVirtualAddressConfigTypeV6":{
                "key":"vlanVirtualAddressConfigTypeV6",
                "valueToLabelMap":{
                  "True":"ipv6 address virtual",
                  "False":"ipv6 virtual-router address"
                },
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanPrimarySwitchSviIpAddressV6":{
                "key":"vlanPrimarySwitchSviIpAddressV6",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigTypeV6":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSecondarySwitchSviIpAddressV6":{
                "key":"vlanSecondarySwitchSviIpAddressV6",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigTypeV6":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "natSourceDetails":{
                "key":"natSourceDetails",
                "type":"INPUT",
                "order":[
                  "sourceNatDataCenterResolver",
                  "sourceNatCampusResolver",
                  "natInterface"
                ]
              },
              "campusSite":{
                "key":"campusSite",
                "type":"INPUT",
                "isPageLayout":false
              },
              "vlanSviMtu":{
                "key":"vlanSviMtu",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSviArpAgingTimeout":{
                "key":"vlanSviArpAgingTimeout",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfacesDevice":{
                "key":"vrfL3InterfacesDevice",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfacesCollection"
                ]
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfL3InterfaceIpAddress":{
                "key":"vrfL3InterfaceIpAddress",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfaceIpAddressV6":{
                "key":"vrfL3InterfaceIpAddressV6",
                "type":"INPUT",
                "dependency":{
                  "enableVrfIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "externalBgpPeers":{
                "key":"externalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeersDetails":{
                "key":"externalBgpPeersDetails",
                "type":"INPUT",
                "order":[
                  "externalBgpPeeringName",
                  "externalBgpPeersDevicesResolver",
                  "externalBgpPeersNeighborIpAddress",
                  "externalBgpPeersRemoteAsUpper",
                  "externalBgpPeersRemoteAs",
                  "externalBgpPeersDescription",
                  "externalBgpPeersPassword",
                  "externalBgpPeersSendCommunity",
                  "externalBgpPeersNextHopSelf",
                  "externalBgpPeersMaxRoutesGroup",
                  "externalBgpPeersUpdateSource",
                  "externalBgpPeersEbgpMultihop",
                  "externalBgpPeersWeight",
                  "externalBgpPeersNextHopGroup",
                  "externalBgpPeersRouteMapGroup",
                  "externalBgpPeersDefaultOriginate",
                  "externalBgpPeersLocalAsUpper",
                  "externalBgpPeersLocalAs"
                ]
              },
              "staticRoutesCollection":{
                "key":"staticRoutesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSviCliStatement":{
                "key":"vlanSviCliStatement",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfAssignDevicesGroup":{
                "key":"vrfAssignDevicesGroup",
                "type":"INPUT",
                "order":[
                  "vrfAssignHostname",
                  "vrfDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "vlanMemberSwitch":{
                "key":"vlanMemberSwitch",
                "type":"INPUT",
                "order":[
                  "vlanMemberSwitchHostname",
                  "vlanDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "additionalRouteTargetsApply":{
                "key":"additionalRouteTargetsApply",
                "dependency":{
                  "additionalRouteTargetsApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "externalBgpPeersApply":{
                "key":"externalBgpPeersApply",
                "dependency":{
                  "externalBgpPeersApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "staticRoutesApply":{
                "key":"staticRoutesApply",
                "dependency":{
                  "staticRoutesApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfAssignApply":{
                "key":"vrfAssignApply",
                "type":"INPUT",
                "dependency":{
                  "vrfAssignApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "staticRoutesNetworkServicesTagger":{
                "type":"TAGGER",
                "parentKey":"staticRoutesDevicesGroup",
                "key":"staticRoutesNetworkServicesTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  }
                ]
              },
              "vlanDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vlanMemberSwitch",
                "key":"vlanDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "vlanAwareL2VlanDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vlanAwareVlanMemberSwitch",
                "key":"vlanAwareL2VlanDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "externalBgpPeersSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"externalBgpPeersDevicesGroup",
                "key":"externalBgpPeersSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "additionalRouteTargetsSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"additionalRouteTargetsDevicesGroup",
                "key":"additionalRouteTargetsSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "vrfDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vrfAssignDevicesGroup",
                "key":"vrfDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "nodeVirtualSviIpAddress":{
                "key":"nodeVirtualSviIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "enableVlanIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeSviIpAddress":{
                "key":"nodeSviIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "enableVlanIpV4":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeVirtualSviIpAddressV6":{
                "key":"nodeVirtualSviIpAddressV6",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVirtualAddressConfigTypeV6":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "enableVlanIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeSviIpAddressV6":{
                "key":"nodeSviIpAddressV6",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "enableVlanIpV6":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeVlanDetails":{
                "key":"nodeVlanDetails",
                "type":"INPUT",
                "fieldOverrides":{
                  "label":"Device",
                  "description":"Add switches to set SVI IP addresses for.",
                  "addButtonLabel":"Device"
                }
              },
              "externalBgpPeersDefaultOriginate":{
                "key":"externalBgpPeersDefaultOriginate",
                "type":"INPUT",
                "order":[
                  "ebgpPeerDefaultOriginateEnable",
                  "externalBgpPeersDefaultOriginateAlways"
                ]
              },
              "externalBgpPeersDefaultOriginateAlways":{
                "key":"externalBgpPeersDefaultOriginateAlways",
                "type":"INPUT",
                "dependency":{
                  "ebgpPeerDefaultOriginateEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "etreeRootSwitches":{
                "key":"etreeRootSwitches",
                "type":"INPUT",
                "isPageLayout":false,
                "showDefaultRow":false
              },
              "etreeEnable":{
                "key":"etreeEnable",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "etreeRole":{
                "key":"etreeRole",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafExportRouteTargetOffset":{
                "key":"leafExportRouteTargetOffset",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "evpnGatewayVteps":{
                "key":"evpnGatewayVteps",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "remoteEvpnGatewayVtepEvpnL3InterDomain":{
                "key":"remoteEvpnGatewayVtepEvpnL3InterDomain",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "remoteEvpnGatewayVtepEvpnL3Enable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantEvpnMulticastDetails":{
                "key":"tenantEvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "tenantL2EvpnMulticastDetails",
                  "tenantL3EvpnMulticastDetails"
                ]
              },
              "vlanL3EvpnMulticastEnabled":{
                "key":"vlanL3EvpnMulticastEnabled",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanL2EvpnMulticastEnabled":{
                "key":"vlanL2EvpnMulticastEnabled",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3EvpnMulticastEnabled":{
                "key":"vrfL3EvpnMulticastEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastDetails":{
                "key":"tenantL3EvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "tenantL3EvpnMulticastEnabled",
                  "tenantL3EvpnMulticast",
                  "tenantEvpnPegResolver",
                  "tenantPimRpAddressesCollection"
                ]
              },
              "vrfPimRpsGroupName":{
                "key":"vrfPimRpsGroupName",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfPimRpsIpAddressesIpAddress":{
                "key":"vrfPimRpsIpAddressesIpAddress",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfPimRpsGroupAddressesGroupAddress":{
                "key":"vrfPimRpsGroupAddressesGroupAddress",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfEvpnMulticastDetails":{
                "key":"vrfEvpnMulticastDetails",
                "type":"INPUT",
                "order":[
                  "vrfL3EvpnMulticastEnabled",
                  "vrfEvpnPegResolver",
                  "vrfPimRpAddressesCollection"
                ]
              },
              "tenantL2EvpnMulticastGroupIpv4Pool":{
                "key":"tenantL2EvpnMulticastGroupIpv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL2EvpnMulticastGroupIpv4PoolOffset":{
                "key":"tenantL2EvpnMulticastGroupIpv4PoolOffset",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL2EvpnMulticastEnabledOnSvis":{
                "key":"tenantL2EvpnMulticastEnabledOnSvis",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL2EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastGroupIpv4Pool":{
                "key":"tenantL3EvpnMulticastGroupIpv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantL3EvpnMulticastGroupIpv4PoolOffset":{
                "key":"tenantL3EvpnMulticastGroupIpv4PoolOffset",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantEvpnPegTransitMode":{
                "key":"tenantEvpnPegTransitMode",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsGroupName":{
                "key":"tenantPimRpsGroupName",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsIpAddressesIpAddress":{
                "key":"tenantPimRpsIpAddressesIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "tenantPimRpsGroupAddressesGroupAddress":{
                "key":"tenantPimRpsGroupAddressesGroupAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfEvpnPegTransitMode":{
                "key":"vrfEvpnPegTransitMode",
                "dependency":{
                  "tenantL3EvpnMulticastEnabled":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3EvpnMulticastEnabled":{
                    "value":[
                      "No"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "externalBgpPeersRemoteAsUpper":{
                "key":"externalBgpPeersRemoteAsUpper",
                "type":"INPUT",
                "dependency":{
                  "asnDotNotationAllow":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "externalBgpPeersLocalAsUpper":{
                "key":"externalBgpPeersLocalAsUpper",
                "type":"INPUT",
                "dependency":{
                  "asnDotNotationAllow":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "evpnGwVtepPeerBgpAsnUpper":{
                "key":"evpnGwVtepPeerBgpAsnUpper",
                "type":"INPUT",
                "dependency":{
                  "asnDotNotationAllow":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSviBgpEosCliStatements":{
                "key":"vlanSviBgpEosCliStatements",
                "type":"INPUT",
                "isMultiLine":true
              },
              "vlanAwareBundleBgpEosCliStatements":{
                "key":"vlanAwareBundleBgpEosCliStatements",
                "type":"INPUT",
                "isMultiLine":true
              }
            }

-   service: arista.studio_build.v1.DependenciesConfigService
    method: Set
    body:
        value:
            key:
                studio_id: studio-evpn-services
                workspace_id: *workspace_id
            dependency_list:
                values:
                    - dependency_type: DEPENDENCY_TYPE_STUDIO
                      id: studio-l3ls
                      dependency_validation: DEPENDENCY_VALIDATION_OPTIONAL
