- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: studio-evpn-services
        workspace_id: &workspace_id ws-evpn-services
      display_name: EVPN Services
      description: Define and configure EVPN services for an L3 network fabric, including configuration of VRFs, VLANs, VNIs and associated IP addressing
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import ipaddress
          import json
          import re
          from itertools import count, groupby
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          veos_regex = r'(v|c)EOS(-)*(Lab)*'


          def convert(text):
              return int(text) if text.isdigit() else text.lower()


          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]


          def natural_sort(iterable):
              if iterable is None:
                  return list()
              return sorted(iterable, key=alphanum_key)


          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",")]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          numbers.append(i)
                  else:
                      numbers.append(int(segment))
              return numbers


          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))


          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None


          def check_vni_overlap(vrfs, vlans):
              '''
              Summary:
                  Asserts errors if vlans or vnis use overlapping vni numbers
              Returns
                  None
              '''
              for tenant in vlans.keys():
                  vnis_seen = {}
                  for vlan, vlan_details in vlans[tenant].items():
                      assert vnis_seen.get(vlan_details['vni']) is None, f"VNI {vlan_details['vni']} found in multiple places -> " \
                                                                         f"{vnis_seen[vlan_details['vni']]['error_name']} in tenant " \
                                                                         f"{vnis_seen[vlan_details['vni']]['tenant']} and " \
                                                                         f"{vlan_details['error_name']} in tenant " \
                                                                         f"{vlan_details['tenant']}. Please correct the VNI " \
                                                                         f"conflict before moving forward."
                      vnis_seen[vlan_details['vni']] = vlan_details
              for tenant in vrfs.keys():
                  vnis_seen = {}
                  for vrf, vrf_details in vrfs[tenant].items():
                      assert vnis_seen.get(vrf_details['vni']) is None, f"VNI {vrf_details['vni']} found in multiple places -> " \
                                                                        f"{vnis_seen[vrf_details['vni']]['error_name']} in tenant " \
                                                                        f"{vnis_seen[vrf_details['vni']]['tenant']} and " \
                                                                        f"{vrf_details['error_name']} in tenant " \
                                                                        f"{vrf_details['tenant']}. Please correct the VNI " \
                                                                        f"conflict before moving forward."
                      vnis_seen[vrf_details['vni']] = vrf_details


          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, "MLAG Subnet mask length must be longer than " \
                                                                "the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[int(switch_facts['mlag_primary_id']) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return


          def normalize_tenant_info(switch_facts, switch_vrfs, switch_vlans, switch_vlan_bundles):
              switch_facts['tenants'] = {}
              # Normalize VRFs
              for vrf, info in switch_vrfs.items():
                  # If tenant not already created in tenants, create it
                  if not switch_facts['tenants'].get(info['tenant']):
                      switch_facts['tenants'][info['tenant']] = {
                          "vrfs": {
                              "default": {
                                  "svis": {},
                                  "vrf_vni": None,
                                  "l3_interfaces": [],
                                  "static_routes": [],
                                  "redistribute_static": None,
                                  "bgp_peers": {},
                                  "additional_route_targets": []
                              }
                          },
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  switch_facts['tenants'][info['tenant']]['vrfs'][vrf] = {
                      "svis": {},
                      "vrf_vni": info['vni'],
                      "l3_interfaces": [],
                      "static_routes": [],
                      "redistribute_static": None,
                      "bgp_peers": {},
                      "additional_route_targets": []
                  }
                  # normalize mlag ibgp details
                  if info.get('ibgp_details') and info['ibgp_details'].get('iBgpSubnet') and switch_facts.get('mlag'):
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['enable_mlag_ibgp_peering_vrfs'] = True
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['mlag_ibgp_peering_vlan'] \
                          = info['ibgp_details']['iBgpVlanId']
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['mlag_ibgp_peering_subnet'] \
                          = info['ibgp_details']['iBgpSubnet']
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['mlag_ibgp_peering_subnet_mask'] \
                          = info['ibgp_details']['iBgpSubnetMask']
                  # normalize source nat details
                  if info['nat_source_details'].get('natInterface'):
                      nat_subnet = info['nat_source_details']['campus'].resolve(
                          device=switch_facts['serial_number'])['site'].resolve(
                          device=switch_facts['serial_number'])['subnet']
                      if nat_subnet is None or nat_subnet.strip() == "":
                          nat_subnet = info['nat_source_details']['dataCenter'].resolve(
                              device=switch_facts['serial_number'])['dcPoD'].resolve(
                              device=switch_facts['serial_number'])['subnet']
                      if nat_subnet is not None and nat_subnet.strip() != "":
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['vtep_diagnostic'] = {
                              "loopback": "".join(re.findall(r'\d', info['nat_source_details']['natInterface'])),
                              "loopback_ip_range": nat_subnet
                          }

                  # normalize l3 interfaces
                  for iface in info.get('l3_interfaces').resolve(device=switch_facts['serial_number'])['interfaces']:
                      l3_interface = {}
                      l3_interface['interfaces'] = [iface['name']]
                      l3_interface['ip_addresses'] = [iface['ipAddress']]
                      l3_interface['nodes'] = [switch_facts['serial_number']]
                      l3_interface['description'] = iface['description']
                      l3_interface['enabled'] = iface['enabled']
                      l3_interface['mtu'] = iface['mtu']
                      l3_interface['encapsulation_dot1q_vlan'] = None
                      l3_interface['eos_cli'] = iface['eosCli']
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['l3_interfaces'].append(l3_interface)

                  # normalize static routes
                  for sr in info.get('static_routes'):
                      # if static route is to be configured on switch
                      if device_matches_resolver_query(sr['devices'], switch_facts['serial_number']):
                          static_route = {}
                          static_route['destination_address_prefix'] = sr['routeDetails'].get('destinationAddressPrefix')
                          static_route['gateway'] = sr['routeDetails'].get('gateway')
                          static_route['distance'] = sr['routeDetails'].get('distance')
                          static_route['tag'] = sr['routeDetails'].get('tag')
                          static_route['name'] = sr['description'].replace(" ", "_")
                          static_route['metric'] = sr['routeDetails'].get('metric')
                          static_route['interface'] = sr['routeDetails'].get('interface')
                          static_route['nodes'] = [switch_facts['serial_number']]
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['static_routes'].append(static_route)

                  # normalize redistribute routes
                  switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['redistribute_static'] = info.get('redistribute_static_routes')

                  # normalize external bgp peers
                  for bgp_peer in info.get('external_bgp_peers'):
                      # if bgp peer is to be configured on switch
                      if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                          peer_info = {}
                          peer_info['remote_as'] = bgp_peer['remoteAs']
                          if bgp_peer.get('description') and bgp_peer['description'].strip() != "":
                              peer_info['description'] = bgp_peer['description']
                          if bgp_peer.get('password') and bgp_peer['password'].strip() != "":
                              peer_info['password'] = bgp_peer['password']
                          if bgp_peer.get('sendCommunity') and bgp_peer['sendCommunity'].strip() != "":
                              peer_info['send_community'] = bgp_peer['sendCommunity']
                          if bgp_peer.get('nextHopSelf') and bgp_peer['nextHopSelf'].strip() != "":
                              peer_info['next_hop_self'] = bgp_peer['nextHopSelf']
                          if bgp_peer['maxRoutes'].get('maximumRoutes'):
                              peer_info['maximum_routes'] = bgp_peer['maxRoutes'].get('maximumRoutes')
                          if bgp_peer['maxRoutes'].get('warningLimit'):
                              peer_info['warning_limit_routes'] = bgp_peer['maxRoutes'].get('warningLimit')
                          if bgp_peer['defaultOriginate'].get('ebgpPeerDefaultOriginateEnable'):
                              peer_info['default_originate'] = {
                                  "always": bgp_peer['defaultOriginate'].get('always')
                              }
                          if bgp_peer.get('updateSource') and bgp_peer['updateSource'].strip() != "":
                              peer_info['update_source'] = bgp_peer['updateSource']
                          if bgp_peer.get('ebgpMultihop'):
                              peer_info['ebgp_multihop'] = bgp_peer['ebgpMultihop']

                          peer_info['nodes'] = [switch_facts['serial_number']]

                          if bgp_peer['nextHop'].get('iPv4NextHop') and bgp_peer['nextHop']['iPv4NextHop'].strip() != "":
                              peer_info['set_ipv4_next_hop'] = bgp_peer['nextHop']['iPv4NextHop']
                          if bgp_peer['nextHop'].get('iPv6NextHop') and bgp_peer['nextHop']['iPv6NextHop'].strip() != "":
                              peer_info['set_ipv6_next_hop'] = bgp_peer['nextHop']['iPv6NextHop']
                          if bgp_peer['routeMap'].get('routeMapOut') and bgp_peer['routeMap']['routeMapOut'].strip() != "":
                              peer_info['route_map_out'] = bgp_peer['routeMap']['routeMapOut']
                          if bgp_peer['routeMap'].get('routeMapIn') and bgp_peer['routeMap']['routeMapIn'].strip() != "":
                              peer_info['route_map_in'] = bgp_peer['routeMap']['routeMapIn']
                          if bgp_peer.get('weight'):
                              peer_info['weight'] = bgp_peer['weight']
                          if bgp_peer.get('localAs'):
                              peer_info['local_as'] = bgp_peer['localAs']
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['bgp_peers'][bgp_peer['neighborIpAddress']] = peer_info

                  # normalize additional route targets
                  for rt in info.get('additional_route_targets'):
                      # if additional route target is to be configured on switch
                      if device_matches_resolver_query(rt['devices'], switch_facts['serial_number']):
                          route_target = {}
                          route_target['type'] = rt['type']
                          route_target['address_family'] = rt['addressFamily']
                          route_target['route_target'] = rt['routeTarget']
                          route_target['nodes'] = [switch_facts['serial_number']]
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['additional_route_targets'].append(route_target)

                  # normalize rd and rt
                  switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['route_distinguisher'] = info['route_distinguisher']
                  switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['route_target'] = info['route_target']

              # Normalize VLANs
              for vlan, info in switch_vlans.items():
                  # If tenant not already created in tenants, create it
                  if not switch_facts['tenants'].get(info['tenant']):
                      switch_facts['tenants'][info['tenant']] = {
                          "vrfs": {
                              "default": {
                                  "svis": {},
                                  "vrf_vni": None,
                                  "l3_interfaces": [],
                                  "static_routes": [],
                                  "redistribute_static": None,
                                  "bgp_peers": {},
                                  "additional_route_targets": []
                              }
                          },
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  # Check if VLAN is L2 or L3
                  # If this is an L3 VLAN
                  if not info['l2_only']:
                      if info['svi_ip_addresses'].get('vrf') and info['svi_ip_addresses']['vrf'].strip() != "None":
                          vrf = info['svi_ip_addresses'].get('vrf')
                      else:
                          vrf = "default"
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)] = {
                          "enabled": True,
                          "vxlan": info['vxlan'],
                          "vni": info['vni'],
                          "eos_cli": info['eos_cli']
                      }
                      # normalize name
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['name'] \
                          = info['name'] if info['name'].strip() != "" else None
                      # set VIP
                      if info['vxlan'] == True:
                          svi_vip = info['svi_ip_addresses']['sviVirtualIpAddress']
                      else:
                          if info['node_svi_details'].resolve(device=switch_facts['serial_number'])['sviIpInfo']['virtualIpAddress'].strip() != "":
                              svi_vip = info['node_svi_details'].resolve(device=switch_facts['serial_number'])['sviIpInfo']['virtualIpAddress']
                          else:
                              svi_vip = None
                      # set IP address
                      if info['vxlan'] == True:
                          if info['svi_ip_addresses']['virtualAddressConfigType'] is True:
                              # configure ip address virtual
                              (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis']
                              [int(vlan)]['ip_address_virtual']) = svi_vip
                          else:
                              # configure ip virtual-router address and real ip address
                              svi_network = ipaddress.ip_interface(svi_vip).network
                              first_host = list(svi_network.hosts())[0]
                              last_host = list(svi_network.hosts())[-1]
                              if str(first_host) == svi_vip.split("/")[0]:
                                  position = "start"
                              elif str(last_host) == svi_vip.split("/")[0]:
                                  position = "end"
                              else:
                                  assert False, f"Error: {vlan}'s virtual IP address must be either the " \
                                              "first or last host address in the subnet if 'ip virtual-router address'" \
                                              " config type is set"
                              if switch_facts.get('mlag_role') and switch_facts['mlag_role'] == "secondary":
                                  # take higher host address closest to vip
                                  if position == "start":
                                      svi_ip = list(svi_network.hosts())[2]
                                  else:
                                      svi_ip = list(svi_network.hosts())[-2]
                              else:
                                  # take lower host address closest to vip
                                  if position == "start":
                                      svi_ip = list(svi_network.hosts())[1]
                                  else:
                                      svi_ip = list(svi_network.hosts())[-3]
                              (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis']
                              [int(vlan)]['ip_virtual_router_addresses']) = [svi_vip]
                              (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis']
                              [int(vlan)]['ip_address']) = f"{svi_ip}/{svi_network.prefixlen}"
                      elif info['vxlan'] == False:
                          if svi_vip is not None:
                              (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis']
                                  [int(vlan)]['ip_virtual_router_addresses']) = [svi_vip]
                          svi_ip = info['node_svi_details'].resolve(device=switch_facts['serial_number'])['sviIpInfo']['ipAddress']
                          (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis']
                              [int(vlan)]['ip_address']) = f"{svi_ip}"

                      # normalize ip helper info
                      if len(info['dhcp_server_details']) > 0:
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['ip_helpers'] = {}
                          for dhcp_info in info['dhcp_server_details']:
                              (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]
                              ['svis'][int(vlan)]['ip_helpers'][dhcp_info['dhcpServer']]) = {}
                              if dhcp_info.get('sourceInterface') and dhcp_info.get('sourceInterface').strip() != "":
                                  # set source interface associated with vrf
                                  (switch_facts['tenants'][info['tenant']]['vrfs'][vrf]
                                  ['svis'][int(vlan)]['ip_helpers'][dhcp_info['dhcpServer']]
                                  ['source_interface']) = dhcp_info['sourceInterface']

                      # normalize mtu
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['mtu'] = info['mtu']
                      # normalize arp
                      if info.get('arp'):
                          switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['arp'] = {}
                          if info['arp'].get('arpAgingTimeout'):
                              switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['arp']['aging_timeout'] \
                                  = info['arp']['arpAgingTimeout']

                      # normalize vni, rd, rt
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['vni_override'] \
                          = info.get('vni_override')
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['route_distinguisher'] \
                          = info.get('route_distinguisher')
                      switch_facts['tenants'][info['tenant']]['vrfs'][vrf]['svis'][int(vlan)]['route_target'] \
                          = info.get('route_target')
                  else:
                      # If this is an L2 VLAN
                      switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)] = {
                          "vxlan": info['vxlan'],
                          "vni": info['vni'],
                          "vni_override": info.get('vni_override')
                      }
                      # normalize name
                      switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['name'] \
                          = info['name'] if info['name'].strip() != "" else None
                      # normalize rd
                      switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['route_distinguisher'] \
                          = info['route_distinguisher']
                      # normalize rt
                      switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['route_target'] = \
                          info['route_target']
                      # normalize etree inputs
                      if info['etree_details'].get('etreeEnable'):
                          switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['etree_leaf_export_rt_offset'] = info['etree_details']['leafExportRouteTargetOffset']
                          if info['etree_root_switches'].resolve(device=switch_facts['serial_number'])['role'] == 'Root':
                              switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['etree_role'] = 'root'
                          else:
                              switch_facts['tenants'][info['tenant']]['l2vlans'][int(vlan)]['etree_role'] = 'leaf'

              # Normalize vlan_aware_bundles
              for vlan_aware_bundle, info in switch_vlan_bundles.items():
                  # If tenant not already created in tenants, create it
                  if not switch_facts['tenants'].get(info['tenant']):
                      switch_facts['tenants'][info['tenant']] = {
                          "vrfs": {},
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  switch_facts['tenants'][info['tenant']]['vlan_aware_bundles'][vlan_aware_bundle] = {
                      "vlan_range": info['vlan_range'],
                      "route_distinguisher": info['route_distinguisher'],
                      "route_target": info['route_target'],
                      "first_vlan": info['first_vlan'],
                      "first_vni": info['first_vni'],
                      "last_vlan": info['last_vlan'],
                      "last_vni": info['last_vni']
                  }

              return switch_facts


          def set_base_config(config, switch_facts):
              # Set router-bgp
              if switch_facts['network_services'].get('l3'):
                  config['ip_routing'] = True
                  config['router_bgp']['as'] = switch_facts['bgp_as']
                  config['router_bgp']['router_id'] = switch_facts['router_id']
              return config


          def set_network_services_config(config, switch_facts):
              # Configure vlans
              if switch_facts['network_services'].get('l2'):
                  # Enable dhcp smart relay
                  config['ip_dhcp_relay'] = {
                      "information_option": True
                  }
                  # Section commented out for now until more detail is found on which platforms
                  # support dhcp snooping
                  # Enable dhcp snooping
                  # config['ip_dhcp_snooping'] = {
                  #     "information_option": True,
                  #     "vlans": []
                  # }
                  for tenant in switch_facts['tenants'].keys():
                      # Set l3 vlan config
                      for vrf in switch_facts['tenants'][tenant]['vrfs'].keys():
                          # Create vlans
                          for svi in switch_facts['tenants'][tenant]['vrfs'][vrf]['svis'].keys():
                              # Create L3 vlans
                              config['vlans'][svi] = {
                                  "tenant": tenant,
                                  "name": switch_facts['tenants'][tenant]['vrfs'][vrf]['svis'][svi]['name']
                              }
                              # Create L3 SVI with helper address pointing towards CVP
                              config['vlan_interfaces'][f"Vlan{svi}"] = {}
                              # Section commented out for now until more detail is found on which platforms
                              # support dhcp snooping
                              # if vrf == "default":
                              #     config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'] = {
                              #         "127.0.0.1": {}
                              #     }
                              #     # enable snooping on that vlan
                              #     config['ip_dhcp_snooping']['vlans'].append(svi)

                          # Set vrf ibgp peering vlan params
                          if switch_facts.get('mlag') and switch_facts['network_services'].get('l3') \
                                  and switch_facts['tenants'][tenant]['vrfs'][vrf].get('enable_mlag_ibgp_peering_vrfs'):
                              ibgp_vlan = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_vlan']
                              config['vlans'][ibgp_vlan] = {
                                  "tenant": tenant,
                                  "name": f"MLAG_iBGP_{vrf}",
                                  "trunk_groups": ['MLAG_VRF_PEER']
                              }

                      # Set l2 vlan config
                      for vlan, info in switch_facts['tenants'][tenant]['l2vlans'].items():
                          config['vlans'][vlan] = {
                              "tenant": tenant,
                              "name": info['name']
                          }
                          if info.get('etree_role') and info['etree_role'] == "leaf" and switch_facts.get('vtep'):
                              config['vlans'][vlan]['etree'] = {'role': 'leaf'}
                          # Section commented out for now until more detail is found on which platforms
                          # support dhcp snooping
                          # Create L2 SVI with helper address pointing towards CVP
                          # config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'] = {
                          #     "127.0.0.1": {}
                          # }
                          # # enable snooping on the vlan
                          # config['ip_dhcp_snooping']['vlans'].append(vlan)

              if switch_facts['network_services'].get('l3'):
                  for tenant in switch_facts['tenants'].keys():
                      for vrf, info in switch_facts['tenants'][tenant]['vrfs'].items():
                          # configure vrfs
                          config['vrfs'][vrf] = {
                              "tenant": tenant,
                              "ip_routing": True
                          }
                          # configure static routes
                          if info.get('static_routes') is not None:
                              for static_route in info['static_routes']:
                                  sr = {
                                      "destination_address_prefix": static_route['destination_address_prefix'],
                                      "vrf": vrf
                                  }
                                  if static_route.get('gateway') and static_route['gateway'].strip() != "":
                                      sr['gateway'] = static_route['gateway']
                                  if static_route.get('distance') and static_route['distance'].strip() != "":
                                      sr['distance'] = static_route['distance']
                                  if static_route.get('tag') and static_route['tag'].strip() != "":
                                      sr['tag'] = static_route['tag']
                                  if static_route.get('name') and static_route['name'].strip() != "":
                                      sr['name'] = static_route['name']
                                  if static_route.get('metric') and static_route['metric'].strip() != "":
                                      sr['metric'] = static_route['metric']
                                  if static_route.get('interface') and static_route['interface'].strip() != "":
                                      sr['interface'] = static_route['interface']
                                  config['static_routes'].append(sr)

                          # configure ethernet interfaces
                          if info.get('l3_interfaces') is not None:
                              l3_interface_subif_parents = []
                              for l3_iface in info['l3_interfaces']:
                                  eth_iface = {}
                                  l3_interface_subif_id = None
                                  if "." in l3_iface['interfaces'][0]:
                                      if l3_iface.get('encapsulation_dot1q_vlan'):
                                          l3_interface_subif_id = l3_iface['encapsulation_dot1q_vlan']
                                      else:
                                          l3_interface_subif_id = l3_iface['interfaces'][0].split('.')[1]
                                      l3_interface_subif_parents.append(l3_iface['interfaces'][0].split('.')[0])
                                  if l3_interface_subif_id is not None:
                                      eth_iface['type'] = "l3dot1q"
                                      eth_iface['encapsulation_dot1q_vlan'] = l3_interface_subif_id
                                  else:
                                      eth_iface['type'] = "routed"
                                  eth_iface['peer_type'] = "l3_interface"
                                  eth_iface['vrf'] = vrf
                                  eth_iface['ip_address'] = l3_iface['ip_addresses'][0]
                                  if l3_iface.get('mtu'):
                                      eth_iface['mtu'] = l3_iface['mtu']
                                  if l3_iface.get('enabled'):
                                      eth_iface['shutdown'] = False
                                  else:
                                      eth_iface['shutdown'] = True
                                  if l3_iface.get('description') and l3_iface['description'].strip() != "":
                                      eth_iface['description'] = l3_iface['description']
                                  if l3_iface.get('eos_cli'):
                                      eth_iface['eos_cli'] = l3_iface['eos_cli']
                                  config['ethernet_interfaces'][l3_iface['interfaces'][0]] = eth_iface
                              for parent_iface in l3_interface_subif_parents:
                                  config['ethernet_interfaces'][parent_iface] = {
                                      "type": "routed",
                                      "peer_type": "l3_interface",
                                      "shutdown": False
                                  }

                          # configure route maps
                          if info.get('bgp_peers'):
                              for peer, peer_info in info['bgp_peers'].items():
                                  if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                      config['route_maps'][f"RM-{vrf}-{peer}-SET-NEXT-HOP-OUT"] = {
                                          "sequence_numbers": {
                                              10: {
                                                  "type": "permit",
                                                  "set": []
                                              }
                                          }
                                      }
                                      if peer_info.get('set_ipv4_next_hop'):
                                          (config['route_maps'][f"RM-{vrf}-{peer}-SET-NEXT-HOP-OUT"]
                                          ['sequence_numbers'][10]['set']).append(f"ip next-hop {peer_info['set_ipv4_next_hop']}")
                                      elif peer_info.get('set_ipv6_next_hop'):
                                          (config['route_maps'][f"RM-{vrf}-{peer}-SET-NEXT-HOP-OUT"]
                                          ['sequence_numbers'][10]['set']).append(f"ipv6 next-hop {peer_info['set_ipv6_next_hop']}")

                  # if mlag is enabled
                  if switch_facts.get('mlag'):
                      # Get mlag_peer_switch facts
                      mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts['mlag_peer_serial_number'])
                      mlag_peer_switch_facts = set_switch_facts(mlag_peer_switch_facts)
                      # Initialize mlag port-channel interface for ibgp trunk groups
                      config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"] = {"trunk_groups": []}

                  # configure interfaces
                  for tenant in switch_facts['tenants'].keys():
                      for vrf in switch_facts['tenants'][tenant]['vrfs'].keys():
                          # set and configure vtep diagnostic loopback interfaces
                          if switch_facts['tenants'][tenant]['vrfs'][vrf].get('vtep_diagnostic'):
                              loopback_id = switch_facts['tenants'][tenant]['vrfs'][vrf]['vtep_diagnostic']['loopback']
                              loopback_description = f"{vrf}_VTEP_DIAGNOSTICS"
                              loopback_ipv4_pool = switch_facts['tenants'][tenant]['vrfs'][vrf]['vtep_diagnostic']['loopback_ip_range']
                              loopback_ip_host_addresses = list(ipaddress.ip_network(loopback_ipv4_pool).hosts())
                              loopback_ip = str(loopback_ip_host_addresses[int(switch_facts['id']) - 1])
                              config['loopback_interfaces'][f"Loopback{loopback_id}"] = {
                                  "description": loopback_description,
                                  "shutdown": False,
                                  "vrf": vrf,
                                  "ip_address": f"{loopback_ip}/32"
                              }
                              # Set virtual-source-nat-vrfs
                              config['virtual_source_nat_vrfs'][vrf] = {
                                  "ip_address": loopback_ip
                              }

                          if switch_facts['network_services'].get('l2') and switch_facts['network_services'].get('l3'):
                              # configure svis
                              for svi, info in switch_facts['tenants'][tenant]['vrfs'][vrf]['svis'].items():
                                  config['vlan_interfaces'][f"Vlan{svi}"]['tenant'] = tenant
                                  config['vlan_interfaces'][f"Vlan{svi}"]['vrf'] = vrf

                                  # Configure VIP and IP
                                  if info.get('ip_address_virtual'):
                                      config['vlan_interfaces'][f"Vlan{svi}"]['ip_address_virtual'] \
                                          = info['ip_address_virtual']
                                  if info.get('ip_virtual_router_addresses'):
                                      config['vlan_interfaces'][f"Vlan{svi}"]['ip_virtual_router_addresses'] \
                                          = info['ip_virtual_router_addresses']
                                  if info.get('ip_address'):
                                      config['vlan_interfaces'][f"Vlan{svi}"]['ip_address'] \
                                          = info['ip_address']

                                  if info.get('ip_helpers'):
                                      config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'] = {}
                                      for helper_address, dhcp_info in info['ip_helpers'].items():
                                          config['vlan_interfaces'][f"Vlan{svi}"]['ip_helpers'][helper_address] = {
                                              "source_interface": dhcp_info.get('source_interface')
                                          }
                                  # if mtu
                                  if info.get('mtu'):
                                      config['vlan_interfaces'][f"Vlan{svi}"]['mtu'] = info['mtu']
                                  # if arp aging timeout
                                  if info.get('arp'):
                                      if info['arp'].get('aging_timeout'):
                                          config['vlan_interfaces'][f"Vlan{svi}"]['arp_aging_timeout'] = info['arp']['aging_timeout']
                                  # configure eos_cli statements
                                  config['vlan_interfaces'][f"Vlan{svi}"]['eos_cli'] = info['eos_cli']

                          # configure vrf ibgp mlag peer interface
                          if switch_facts.get('mlag') \
                                  and switch_facts['tenants'][tenant]['vrfs'][vrf].get('enable_mlag_ibgp_peering_vrfs'):
                              ibgp_vlan = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_vlan']
                              ibgp_peering_subnet = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_subnet']
                              ibgp_peering_subnet_mask = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_subnet_mask']
                              mlag_ip = str(get_mlag_ip(
                                      switch_facts,
                                      ibgp_peering_subnet,
                                      ibgp_peering_subnet_mask,
                                      switch_facts['mlag_role']
                                      )
                                  )
                              config['vlan_interfaces'][f"Vlan{ibgp_vlan}"] = {
                                  "tenant": tenant,
                                  "type": "underlay_peering",
                                  "shutdown": False,
                                  "mtu": 9214,
                                  "description": f"MLAG_PEER_L3_iBGP:{vrf}",
                                  "vrf": vrf,
                                  "ip_address": f"{mlag_ip}/{ibgp_peering_subnet_mask}"
                              }
                              # Reset mtu to 1500 if veos
                              if re.match(veos_regex, switch_facts['platform']):
                                  config['vlan_interfaces'][f"Vlan{ibgp_vlan}"]['mtu'] = None
                              if "MLAG_VRF_PEER" not in (config['port_channel_interfaces']
                                                        [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                                                        ['trunk_groups']):
                                  (config['port_channel_interfaces']
                                  [f"Port-Channel{switch_facts['mlag_port_channel_id']}"]
                                  ['trunk_groups']).append("MLAG_VRF_PEER")

              # Assume this is a VTEP if below criteria is met
              if switch_facts.get('vtep'):
                  # Perform vtep logic (set rds and rts)
                  ip_vrf_admin_field_key_words = {
                      "VNI": "vrf_info['vrf_vni']",
                      "Router-ID": "switch_facts['router_id']"
                  }
                  vlan_based_mac_vrf_admin_field_key_words = {
                      "VNI": "vlan_info['vni']",
                      "VLAN": "vlan",
                      "Router-ID": "switch_facts['router_id']"
                  }
                  vlan_aware_mac_vrf_admin_field_key_words = {
                      "First-VLAN": "bundle_info['first_vlan']",
                      "First-VNI": "bundle_info['first_vni']",
                      "Last-VLAN": "bundle_info['last_vlan']",
                      "Last-VNI": "bundle_info['last_vni']",
                      "Router-ID": "switch_facts['router_id']"
                  }
                  for tenant in switch_facts['tenants'].keys():
                      # Set vrfs
                      for vrf, vrf_info in switch_facts['tenants'][tenant]['vrfs'].items():
                          if vrf != "default":
                              # Set vrf rd
                              switch_rd = []
                              for rd_segment in vrf_info['route_distinguisher'].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rd_segment):
                                      switch_rd.append(str(eval(ip_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vrf_info['route_distinguisher'] = ":".join(switch_rd)
                              # Set vrf rt
                              switch_rt = []
                              for rt_segment in vrf_info['route_target'].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rt_segment):
                                      switch_rt.append(str(eval(ip_vrf_admin_field_key_words[rt_segment])))
                                  else:
                                      switch_rt.append(rt_segment)
                              vrf_info['route_target'] = ":".join(switch_rt)
                          # Set L3 vlans
                          for svi, vlan_info in switch_facts['tenants'][tenant]['vrfs'][vrf]['svis'].items():
                              # Set vlan rd
                              switch_rd = []
                              for rd_segment in vlan_info['route_distinguisher'].split(":"):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                      switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vlan_info['route_distinguisher'] = ":".join(switch_rd)
                              # Set vlan rts
                              switch_rt = []  # For both import/export rt

                              for i, rt_segment in enumerate(vlan_info['route_target'].split(":")):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                      rt_segment = str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment]))
                                  switch_rt.append(rt_segment)

                              vlan_info['route_target'] = ":".join(switch_rt)

                      # Set l2 vlans
                      for vlan, vlan_info in switch_facts['tenants'][tenant]['l2vlans'].items():
                          # Set vlan rd
                          switch_rd = []
                          for rd_segment in vlan_info['route_distinguisher'].split(":"):
                              if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                  switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                              else:
                                  switch_rd.append(rd_segment)
                          vlan_info['route_distinguisher'] = ":".join(switch_rd)
                          # Set vlan rt
                          switch_rt = []  # For both import/export rt
                          switch_import_rt = []  # For only import rt
                          switch_export_rt = []  # For only export rt
                          for i, rt_segment in enumerate(vlan_info['route_target'].split(":")):
                              if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                  rt_segment = str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment]))
                              # Format for etree switches
                              if not vlan_info.get('etree_role'):
                                  switch_rt.append(rt_segment)
                              else:
                                  leaf_rt_segment = str(vlan_info['etree_leaf_export_rt_offset'] + int(rt_segment)) if i % 2 == 1 else rt_segment
                                  if vlan_info["etree_role"] == 'root':
                                      switch_rt.append(rt_segment)
                                      switch_import_rt.append(leaf_rt_segment)
                                  else:
                                      switch_import_rt.append(rt_segment)
                                      switch_export_rt.append(leaf_rt_segment)
                                      switch_rt = []

                          vlan_info['route_target'] = ":".join(switch_rt) if len(switch_rt) > 0 else None
                          vlan_info['import_route_target'] = ":".join(switch_import_rt) if len(switch_import_rt) > 0 else None
                          vlan_info['export_route_target'] = ":".join(switch_export_rt) if len(switch_export_rt) > 0 else None

                      # Set vlan_aware_bundles
                      for bundle, bundle_info in switch_facts['tenants'][tenant]['vlan_aware_bundles'].items():
                          # Set bundle rd
                          switch_rd = []
                          for rd_segment in bundle_info['route_distinguisher'].split(":"):
                              if vlan_aware_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                  switch_rd.append(str(eval(vlan_aware_mac_vrf_admin_field_key_words[rd_segment])))
                              else:
                                  switch_rd.append(rd_segment)
                          bundle_info['route_distinguisher'] = ":".join(switch_rd)
                          # Set bundle rt
                          switch_rt = []
                          for rt_segment in bundle_info['route_target'].split(":"):
                              if vlan_aware_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                  switch_rt.append(str(eval(vlan_aware_mac_vrf_admin_field_key_words[rt_segment])))
                              else:
                                  switch_rt.append(rt_segment)
                          bundle_info['route_target'] = ":".join(switch_rt)

                  # Set bgp
                  if switch_facts['network_services'].get('l3'):
                      config['router_bgp']['vrfs'] = {}
                      config['router_bgp']['vlans'] = {}
                      config['router_bgp']['vlan_aware_bundles'] = {}
                      for tenant in switch_facts['tenants'].keys():
                          # Set vrfs
                          for vrf, vrf_info in switch_facts['tenants'][tenant]['vrfs'].items():
                              address_family_ipv4_neighbors = []
                              address_family_ipv6_neighbors = []
                              try:
                                  if vrf == "default":
                                      route_distinguisher = None
                                      route_targets = None
                                  else:
                                      route_distinguisher = vrf_info['route_distinguisher']
                                      route_targets = {
                                          "import": {
                                              "evpn": [vrf_info['route_target']]
                                          },
                                          "export": {
                                              "evpn": [vrf_info['route_target']]
                                          }
                                      }
                                      # additional route targets
                                      if vrf_info.get('additional_route_targets'):
                                          for rt in natural_sort(vrf_info['additional_route_targets']):
                                              if rt.get('address_family') \
                                                      and rt.get('route_target') \
                                                      and rt.get('type'):
                                                  if rt['address_family'] in route_targets[rt['type']].keys():
                                                      route_targets[rt['type']][rt['address_family']].append(rt['route_target'])
                                                  else:
                                                      route_targets[rt['type']].update({rt['address_family']: rt['route_target']})
                              except Exception as e:
                                  assert False, f"{switch_facts['hostname']} is having an issue with {vrf} vrf: {e}"
                              # initialize vrf
                              config['router_bgp']['vrfs'][vrf] = {
                                  "router_id": switch_facts['router_id'],
                                  "rd": route_distinguisher,
                                  "route_targets": route_targets,
                                  "neighbors": {},
                                  "redistribute_routes": {
                                      "connected": {}
                                      # "attached-host": {}
                                  },
                                  "address_families": {
                                      "ipv4": {"neighbors": {}, "networks": {}},
                                      "ipv6": {"neighbors": {}, "networks": {}}
                                  }
                              }
                              # get and set mlag peer config
                              if switch_facts.get('mlag') \
                                      and switch_facts['tenants'][tenant]['vrfs'][vrf].get('enable_mlag_ibgp_peering_vrfs'):
                                  ibgp_vlan = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_vlan']
                                  ibgp_peering_subnet = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_subnet']
                                  ibgp_peering_subnet_mask \
                                      = switch_facts['tenants'][tenant]['vrfs'][vrf]['mlag_ibgp_peering_subnet_mask']
                                  mlag_peer_ip = str(get_mlag_ip(
                                          switch_facts,
                                          ibgp_peering_subnet,
                                          ibgp_peering_subnet_mask,
                                          mlag_peer_switch_facts['mlag_role']
                                          )
                                      )
                                  # Add mlag_ip to nieghbors and address family
                                  config['router_bgp']['vrfs'][vrf]['neighbors'][mlag_peer_ip] = {
                                      "remote_as": switch_facts['bgp_as'],
                                      "description": mlag_peer_switch_facts['hostname'],
                                      "send_community": "all",
                                      "next_hop_self": True,
                                  }
                                  address_family_ipv4_neighbors.append(mlag_peer_ip)
                              # set external bgp peers
                              if vrf_info.get('bgp_peers'):
                                  for peer, peer_info in vrf_info['bgp_peers'].items():
                                      if validIPAddress(peer) is True:
                                          address_family_ipv4_neighbors.append(peer)
                                      elif validIPAddress(peer) is False:
                                          address_family_ipv6_neighbors.append(peer)
                                      else:
                                          continue
                                      if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                          peer_info.update({"route_map_out": f"RM-{vrf}-{peer}-SET-NEXT-HOP-OUT"})
                                          if peer_info.get('default_originate'):
                                              if not peer_info['default_originate'].get('route_map'):
                                                  peer_info['default_originate'].update(
                                                      {"route_map": f"RM-{vrf}-{peer}-SET-NEXT-HOP-OUT"}
                                                  )
                                          if peer_info.get('set_ipv4_next_hop'):
                                              peer_info.pop("set_ipv4_next_hop")
                                          if peer_info.get('set_ipv6_next_hop'):
                                              peer_info.pop("set_ipv6_next_hop")
                                      config['router_bgp']['vrfs'][vrf]['neighbors'][peer] = peer_info
                              # redistribute static routes
                              if vrf_info.get('redistribute_static'):
                                  config['router_bgp']['vrfs'][vrf]['redistribute_routes']['static'] = {}
                              # activate neighbors for ipv4 address family
                              if len(address_family_ipv4_neighbors) > 0:
                                  for neighbor in address_family_ipv4_neighbors:
                                      config['router_bgp']['vrfs'][vrf]['address_families']['ipv4']['neighbors'][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config['router_bgp']['vrfs'][vrf]['address_families']['ipv4'])
                              # activate neighbors for ipv6 address family
                              if len(address_family_ipv6_neighbors) > 0:
                                  for neighbor in address_family_ipv6_neighbors:
                                      config['router_bgp']['vrfs'][vrf]['address_families']['ipv6']['neighbors'][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config['router_bgp']['vrfs'][vrf]['address_families']['ipv6'])

                              # Set l3 vlans
                              for vlan, vlan_info in vrf_info['svis'].items():
                                  if vlan_info['vxlan'] == False:
                                      continue
                                  vlan_in_bundle = False
                                  for bundle_info in switch_facts['tenants'][tenant]['vlan_aware_bundles'].values():
                                      if vlan in string_to_list(bundle_info['vlan_range']):
                                          vlan_in_bundle = True
                                          break
                                  if vlan_in_bundle is True:
                                      continue
                                  config['router_bgp']['vlans'][vlan] = {
                                      "tenant": tenant,
                                      "rd": vlan_info['route_distinguisher'],
                                      "route_targets": {},
                                      "redistribute_routes": {
                                          "learned": {}
                                      }
                                  }
                                  # Set route targets
                                  config['router_bgp']['vlans'][vlan]['route_targets']['both'] = [vlan_info['route_target']] if vlan_info.get('route_target') else None
                                  config['router_bgp']['vlans'][vlan]['route_targets']['import'] = [vlan_info['import_route_target']] if vlan_info.get('import_route_target') else None
                                  config['router_bgp']['vlans'][vlan]['route_targets']['export'] = [vlan_info['export_route_target']] if vlan_info.get('export_route_target') else None

                          # Set l2 vlans
                          for vlan, vlan_info in switch_facts['tenants'][tenant]['l2vlans'].items():
                              if vlan_info['vxlan'] == False:
                                  continue
                              vlan_in_bundle = False
                              for bundle_info in switch_facts['tenants'][tenant]['vlan_aware_bundles'].values():
                                  if vlan in string_to_list(bundle_info['vlan_range']):
                                      vlan_in_bundle = True
                                      break
                              if vlan_in_bundle is True:
                                  continue
                              config['router_bgp']['vlans'][vlan] = {
                                  "tenant": tenant,
                                  "rd": vlan_info['route_distinguisher'],
                                  "route_targets": {},
                                  "redistribute_routes": {
                                      "learned": {}
                                  }
                              }
                              # Set route targets
                              config['router_bgp']['vlans'][vlan]['route_targets']['both'] = [vlan_info['route_target']] if vlan_info.get('route_target') else None
                              config['router_bgp']['vlans'][vlan]['route_targets']['import'] = [vlan_info['import_route_target']] if vlan_info.get('import_route_target') else None
                              config['router_bgp']['vlans'][vlan]['route_targets']['export'] = [vlan_info['export_route_target']] if vlan_info.get('export_route_target') else None
                          # Set vlan aware bundles
                          for bundle, bundle_info in switch_facts['tenants'][tenant]['vlan_aware_bundles'].items():
                              config['router_bgp']['vlan_aware_bundles'][bundle] = {
                                  "rd": bundle_info['route_distinguisher'],
                                  "route_targets": {
                                      "both": [bundle_info['route_target']]
                                  },
                                  "vlan": bundle_info['vlan_range'],
                                  "redistribute_routes": [
                                      "learned"
                                  ]
                              }


                  # Set vxlan interface
                  config['vxlan_interface'] = {"Vxlan1": {"vxlan": {"vrfs": {}, "vlans": {}}}}
                  for tenant in switch_facts['tenants'].keys():
                      for vrf in switch_facts['tenants'][tenant]['vrfs'].keys():
                          if vrf != "default":
                              # map vrfs to vnis
                              config['vxlan_interface']['Vxlan1']['vxlan']['vrfs'][vrf] = {
                                  "vni": switch_facts['tenants'][tenant]['vrfs'][vrf]['vrf_vni']
                              }

                          # map l3vlans to vnis
                          for svi, info in switch_facts['tenants'][tenant]['vrfs'][vrf]['svis'].items():
                              if info.get('vni') is None or info['vxlan'] == False:
                                  continue
                              if info.get('vni_override') is not None:
                                  info['vni'] = info['vni_override']
                              config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][svi] = {
                                  "vni": info['vni']
                              }

                      # map l2vlans to vnis
                      for l2vlan, info in switch_facts['tenants'][tenant]['l2vlans'].items():
                          if not info.get('vni'):
                              continue
                          config['vxlan_interface']['Vxlan1']['vxlan']['vlans'][l2vlan] = {
                              "vni": info['vni']
                          }
              # clean up unnecessary config elements
              if switch_facts.get('mlag') \
                      and config['port_channel_interfaces'].get(f"Port-Channel{switch_facts['mlag_port_channel_id']}") \
                      and len(
                          config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"]['trunk_groups']
                          ) == 0:
                  del(config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"])

              # Clear dhcp snooping config if veos
              if re.match(veos_regex, switch_facts['platform']) and config.get('ip_dhcp_snooping'):
                  del config['ip_dhcp_snooping']

              return config


          def get_tag_values_applied_to_device(tag_assignment_key):
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\" AND device:{device_id}"
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags


          def get_tag_value(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value = device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return tag_values[0].value


          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value = device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [tag_value.value for tag_value in tag_values]


          def check_config_parameters(switch_facts):
              if switch_facts.get('vtep'):
                  assert switch_facts.get('bgp_as') is not None, f"BGP ASN is not set.  Please apply a 'router_bgp.as' tag to " \
                                                                  f"{switch_facts['hostname']} in the Tags section of Provisioning " \
                                                                  f"with the appropriate workspace selected."
                  assert switch_facts.get('router_id') is not None, f"BGP Router ID is not set.  Please apply a 'router_bgp.router_id' " \
                                                                  f"tag to {switch_facts['hostname']} in the Tags section of " \
                                                                  f"Provisioning with the appropriate workspace selected."
              if switch_facts.get('mlag') is True:
                  assert switch_facts.get('mlag_port_channel_id') is not None, f"MLAG Peer Link is not set.  Please apply a " \
                                                                              f"'mlag_configuration.peer_link' tag to " \
                                                                              f"{switch_facts['hostname']} in the Tags " \
                                                                              f"'section of Provisioning with the appropriate " \
                                                                              f"workspace selected"


          def get_interfaces_info(switch_facts):
              device_id = switch_facts['serial_number']
              interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None and "Ethernet" in i.name:
                      interfaces[i.name] = {
                          "neighborId": peer_device.id,
                          "neighborHostname": peer_device.hostName,
                          "neighborInterface": peer_interface.name
                      }
              return interfaces


          def get_mlag_peer(switch_facts):
              mlag_peer_switch_serial_number = None
              if switch_facts.get('mlag'):
                  # Get MLAG peer from interface's neighbor details
                  # Assumption is that this switch's MLAG peer should be the only neighbor switch with
                  # mlag enabled and the same services running
                  for info in switch_facts['interfaces'].values():
                      neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                      if neighbor_switch_facts.get('mlag') \
                              and switch_facts['network_services'].get('l2') == neighbor_switch_facts['network_services'].get('l2') \
                              and switch_facts['network_services'].get('l3') == neighbor_switch_facts['network_services'].get('l3'):
                          mlag_peer_switch_serial_number = neighbor_switch_facts['serial_number']
                          break
              return mlag_peer_switch_serial_number


          def get_gateway_switches(switch_facts):
              gateway_switches = []
              # Shouldn't have to worry about uplink switches on l3 switches since they
              # are the gateway in this context
              if switch_facts['network_services'].get('l2'):
                  # if the switch has l3 network services tag, we assume it is the gateway
                  if switch_facts['network_services'].get('l3'):
                      gateway_switches = [switch_facts['serial_number']]
                  # if the switch does NOT have l3 network services tag, we assume it needs to find a gateway
                  else:
                      # Get uplink switches using neighbor details
                      uplink_switches = []
                      for info in switch_facts['interfaces'].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                          if neighbor_switch_facts['network_services'].get('l3'):
                              uplink_switches.append(neighbor_switch_facts)
                      # Assume switch is a campus pod member switch in an L2 campus topology if it has no L3
                      # uplink switches and that both neighbors are uplink switches (very use-case specific code)
                      if len(uplink_switches) == 0:
                          for info in switch_facts['interfaces'].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info['neighborId'])
                              if neighbor_switch_facts:
                                  uplink_switches.append(neighbor_switch_facts)
                      for uplink_switch_facts in uplink_switches:
                          if uplink_switch_facts['network_services'].get('l3'):
                              gateway_switches.append(uplink_switch_facts['serial_number'])
                          else:
                              uplink_switch_facts['interfaces'] = get_interfaces_info(uplink_switch_facts)
                              uplink_gateway_switches = get_gateway_switches(uplink_switch_facts)
                              for switch_sn in uplink_gateway_switches:
                                  if switch_sn not in gateway_switches:
                                      gateway_switches.append(switch_sn)
              return gateway_switches


          def get_switch_basics_from_tags(device_id):
              switch_facts = {"serial_number": device_id}
              switch_facts['network_services'] = {}
              tags_to_facts = {
                  "hostname": "hostname",
                  "model": "platform"
              }

              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              for label in tags_to_facts.keys():
                  if label == "hostname":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.hostName:
                              switch_facts[tags_to_facts[label]] = dev.hostName
                      continue
                  elif label == "model":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.modelName:
                              switch_facts[tags_to_facts[label]] = dev.modelName
                      continue

              # Set role if one exists
              roles_applied_to_switch = role_dict.get(device_id)
              if roles_applied_to_switch and len(roles_applied_to_switch) > 0:
                  switch_facts['type'] = roles_applied_to_switch[0]
              else:
                  switch_facts['type'] = None

              # Set node_id from NodeId tag
              switch_facts['id'] = node_id_dict.get(device_id)
              # If NodeId tag isn't set, check for old leaf-number or spine-number tags
              if switch_facts.get('id') is None and switch_facts.get('type') in ["Leaf", "Spine"]:
                  id_tag_type = {"Leaf": "Leaf-Number", "Spine": "Spine-Number", "Super-Spine": None}
                  node_id = get_tag_value(device_id=device_id, label=id_tag_type[switch_facts['type']], workspace_id=workspace_id)
                  if node_id is not None:
                      switch_facts['id'] = int(node_id)

              # Set network_services
              if network_services_dict.get(device_id):
                  # Set l2 network_services
                  if 'L2' in network_services_dict.get(device_id):
                      switch_facts['network_services']['l2'] = True
                  else:
                      switch_facts['network_services']['l2'] = False
                  # Set l3 network_services
                  if 'L3' in network_services_dict.get(device_id):
                      switch_facts['network_services']['l3'] = True
                  else:
                      switch_facts['network_services']['l3'] = False

              # Set l3 network services if not already set
              if not switch_facts['network_services'].get('l3') and switch_facts.get('type'):
                  if switch_facts['type'] in ["Leaf", "Spine", "Super-Spine"]:
                      switch_facts['network_services']['l3'] = True
                  else:
                      switch_facts['network_services']['l3'] = False
              # Set l2 network services if not already set
              if not switch_facts['network_services'].get('l2') and switch_facts.get('type'):
                  if switch_facts['type'] in ["Leaf", "L2-Leaf"]:
                      switch_facts['network_services']['l2'] = True
                  else:
                      switch_facts['network_services']['l2'] = False

              # normalize vtep
              if vtep_dict.get(device_id):
                  if re.match(r'true', vtep_dict[device_id], flags=re.IGNORECASE):
                      switch_facts['vtep'] = True
                  else:
                      switch_facts['vtep'] = False
              else:
                  switch_facts['vtep'] = False

              # Set vtep if not already set
              if not switch_facts.get('vtep') and switch_facts.get('type'):
                  if switch_facts['type'] in ['Leaf']:
                      switch_facts['vtep'] = True
                  else:
                      switch_facts['vtep'] = False

              # Set BGP ASN
              switch_facts['bgp_as'] = bgp_as_dict[device_id] if bgp_as_dict.get(device_id) else None

              # Set Router ID
              switch_facts['router_id'] = router_id_dict[device_id] if router_id_dict.get(device_id) else None

              # normalize mlag_port_channel_id and turn mlag on/off
              if mlag_peer_link_dict.get(device_id) and mlag_peer_link_dict[device_id].strip() != "":
                  switch_facts['mlag_port_channel_id'] = "".join(re.findall(r'\d', mlag_peer_link_dict[device_id]))
                  switch_facts['mlag'] = True
              else:
                  switch_facts['mlag'] = False

              # Set other keys
              if switch_facts['network_services'].get('l3'):
                  switch_facts['uplink_type'] = "p2p"
              else:
                  switch_facts['uplink_type'] = "port-channel"

              return switch_facts


          def set_switch_facts(switch_facts):
              # Get interface info from studio topology tags
              switch_facts['interfaces'] = get_interfaces_info(switch_facts)

              # Get gateway details
              switch_facts['gateway_switches'] = get_gateway_switches(switch_facts)

              # Set mlag relevant facts
              if switch_facts.get('mlag'):
                  switch_facts['mlag_peer_serial_number'] = get_mlag_peer(switch_facts)
                  mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts['mlag_peer_serial_number'])
                  if int(switch_facts['id']) < int(mlag_peer_switch_facts['id']):
                      switch_facts['mlag_role'] = "primary"
                      switch_facts['mlag_primary_id'] = int(switch_facts['id'])
                  else:
                      switch_facts['mlag_role'] = "secondary"
                      switch_facts['mlag_primary_id'] = int(mlag_peer_switch_facts['id'])
              else:
                  switch_facts['mlag_role'] = None
              return switch_facts


          # returns dictionary of device to label value based on workspace tag assignments
          def populate_single_value_dict(workspace_id, label):
              sv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      sv_dict[match.device.device_id] = tag.value
              return sv_dict


          # returns dictionary of device to label values based on workspace tag assignments
          def populate_multi_value_dict(workspace_id, label):
              mv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      mv_dict.setdefault(match.device.device_id, []).append(tag.value)
              return mv_dict


          def clean_config(config):
              # remove default vrf dictionary
              if config.get('vrfs') and config['vrfs'].get('default'):
                  del config['vrfs']['default']
              # remove any empty SVIs
              svis_to_delete = []
              for svi, info in config['vlan_interfaces'].items():
                  if len(info.keys()) == 0:
                      svis_to_delete.append(svi)
              for svi in svis_to_delete:
                  del config['vlan_interfaces'][svi]

              # remove default vrf from L3 vrfs in bgp config
              if config.get('router_bgp') and config['router_bgp'].get('vrfs') and config['router_bgp']['vrfs'].get('default'):
                  del config['router_bgp']['vrfs']['default']

              return config


          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          workspace_id = ctx.studio.workspaceId
          my_device = ctx.getDevice()
          my_device_id = my_device.id

          if not tenants:
              return  # type: ignore

          config = {}

          # Pre-populate dictionaries used for getting switch facts
          node_id_dict = populate_single_value_dict(workspace_id, 'NodeId')
          network_services_dict = populate_multi_value_dict(workspace_id, 'NetworkServices')
          vtep_dict = populate_single_value_dict(workspace_id, 'Vtep')
          bgp_as_dict = populate_single_value_dict(workspace_id, 'router_bgp.as')
          router_id_dict = populate_single_value_dict(workspace_id, 'router_bgp.router_id')
          mlag_peer_link_dict = populate_single_value_dict(workspace_id, 'mlag_configuration.peer_link')
          role_dict = populate_multi_value_dict(workspace_id, 'Role')

          my_switch_facts = get_switch_basics_from_tags(my_device_id)
          my_switch_facts = set_switch_facts(my_switch_facts)
          check_config_parameters(my_switch_facts)

          vlan_based_mac_vrf_attribute_formats = vlanBasedMacVrfAttributeFormats
          vlan_bundle_mac_vrf_attribute_formats = vlanBundleMacVrfAttributeFormats
          vrf_attribute_formats = vrfAttributeFormats

          vrfs = {}
          vlans = {}
          vlan_aware_bundles = {}

          # Get VLANs and VRFs from input
          for tenant in tenants:
              for vrf in tenant['vrfs']:
                  if not vrfs.get(tenant['name']):
                      vrfs[tenant['name']] = {}
                  vrfs[tenant['name']][vrf['name']] = {
                      "tenant": tenant['name'],
                      "nat_source_details": vrf['natSourceDetails'],
                      "ibgp_details": vrf['iBgpDetails'],
                      "vni": vrf['vni'],
                      "l3_interfaces": vrf['l3Interfaces'],
                      "static_routes": vrf['staticRoutes'],
                      "redistribute_static_routes": vrf['redistributeStaticRoutes'],
                      "external_bgp_peers": vrf['externalBgpPeers'],
                      "additional_route_targets": vrf['additionalRouteTargets'],
                      "route_distinguisher": vrf_attribute_formats['vrfRouteDistinguisherFormat'],
                      "route_target": vrf_attribute_formats['vrfRouteTargetFormat'],
                      "devices": vrf['devices'],
                      "error_name": f"VRF {vrf['name']}"  # Set for error asserting purposes
                  }
                  if vrf['overrideVariables']['routeDistinguisher'] is not None \
                          and vrf['overrideVariables']['routeDistinguisher'].strip() != "":
                      vrfs[tenant['name']][vrf['name']]['route_distinguisher'] = vrf['overrideVariables']['routeDistinguisher']
                  if vrf['overrideVariables']['routeTarget'] is not None and vrf['overrideVariables']['routeTarget'].strip() != "":
                      vrfs[tenant['name']][vrf['name']]['route_target'] = vrf['overrideVariables']['routeTarget']

              for vlan in tenant['vlans']:
                  if not vlans.get(tenant['name']):
                      vlans[tenant['name']] = {}
                  # Format vrf as member of svi_address_details for backwards compatibility
                  # Fix once we can handle field change in upgrade script
                  svi_ip_info = vlan['sviIpAddresses']
                  svi_ip_info['vrf'] = vlan['vrf']
                  vlans[tenant['name']][vlan['vlanId']] = {
                      "tenant": tenant['name'],
                      "name": vlan['name'],
                      "vxlan": vlan['vxlan'],
                      "l2_only": not(vlan['l3OrL2']),
                      # "svi_ip_addresses": vlan['sviIpAddresses'],
                      "svi_ip_addresses": svi_ip_info,
                      "node_svi_details": vlan['nodes'],
                      "dhcp_server_details": vlan['dhcpServerDetails'],
                      "vni": int(vlan['vlanId']) + int(tenant['macVrfVniBase']),
                      "member_switches": vlan['switches'],
                      "etree_details": vlan['eTreeDetails'],
                      "etree_root_switches": vlan["eTreeRootSwitches"],
                      "arp": vlan['arp'],
                      "mtu": vlan['mtu'],
                      "eos_cli": vlan['eosCli'],
                      "route_distinguisher": vlan_based_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat'],
                      "route_target": vlan_based_mac_vrf_attribute_formats['macVrfRouteTargetFormat'],
                      "tenant": tenant['name'],  # Set for error asserting purposes
                      "error_name": f"Vlan{vlan['vlanId']}"  # Set for error asserting purposes
                  }
                  if vlan.get('overrideVariables'):
                      if vlan['overrideVariables']['vni'] is not None:
                          vlans[tenant['name']][vlan['vlanId']]['vni_override'] = int(vlan['overrideVariables']['vni'])
                      else:
                          vlans[tenant['name']][vlan['vlanId']]['vni_override'] = None
                      if vlan['overrideVariables']['routeDistinguisher'] is not None \
                              and vlan['overrideVariables']['routeDistinguisher'].strip() != "":
                          vlans[tenant['name']][vlan['vlanId']]['route_distinguisher'] = vlan['overrideVariables']['routeDistinguisher']
                      if vlan['overrideVariables']['routeTarget'] is not None \
                              and vlan['overrideVariables']['routeTarget'].strip() != "":
                          vlans[tenant['name']][vlan['vlanId']]['route_target'] = vlan['overrideVariables']['routeTarget']

              for vlan_aware_bundle in tenant['vlanAwareBundles']:
                  if not vlan_aware_bundles.get(tenant['name']):
                      vlan_aware_bundles[tenant['name']] = {}
                  vlan_range = string_to_list(vlan_aware_bundle['vlanRange'])
                  first_vlan = vlan_range[0]
                  last_vlan = vlan_range[-1]
                  vlan_range = list_compress(vlan_range)
                  vlan_aware_bundles[tenant['name']][vlan_aware_bundle['name']] = {
                      "vlan_range": vlan_range,
                      "route_distinguisher": vlan_bundle_mac_vrf_attribute_formats['macVrfRouteDistinguisherFormat'],
                      "route_target": vlan_bundle_mac_vrf_attribute_formats['macVrfRouteTargetFormat'],
                      "tenant": tenant['name'],
                      "first_vlan": first_vlan,
                      "last_vlan": last_vlan,
                      "first_vni": vlans[first_vlan]["vni"] if vlans.get(first_vlan) else int(first_vlan) + int(tenant['macVrfVniBase']),
                      "last_vni": vlans[last_vlan]["vni"] if vlans.get(last_vlan) else int(last_vlan) + int(tenant['macVrfVniBase'])
                  }
                  if vlan_aware_bundle['overrideVariables']['routeDistinguisher'] is not None \
                          and vlan_aware_bundle['overrideVariables']['routeDistinguisher'].strip() != "":
                      vlan_aware_bundles[tenant['name']][vlan_aware_bundle['name']]['route_distinguisher'] \
                          = vlan_aware_bundle['overrideVariables']['routeDistinguisher']
                  if vlan_aware_bundle['overrideVariables']['routeTarget'] is not None \
                          and vlan_aware_bundle['overrideVariables']['routeTarget'].strip() != "":
                      vlan_aware_bundles[tenant['name']][vlan_aware_bundle['name']]['route_target'] \
                          = vlan_aware_bundle['overrideVariables']['routeTarget']

          # Check for duplicate VNIs
          check_vni_overlap(vrfs, vlans)

          # Check which VRFs, VLANs, and VLAN Aware Bundles have been applied to my_switch
          my_switch_vrfs = {}
          my_switch_vlans = {}
          my_switch_vlan_bundles = {}

          # Get VLANs that should be configured on this switch
          for tenant in vlans.keys():
              for vlan, vlan_details in vlans[tenant].items():
                  for gateway_id in my_switch_facts['gateway_switches']:
                      if device_matches_resolver_query(vlan_details['member_switches'], gateway_id):
                          my_switch_vlans[vlan] = vlan_details
                          if vlan_details['svi_ip_addresses'].get('vrf') is not None \
                                  and vlan_details['svi_ip_addresses']['vrf'].strip() not in ["", "None"]:
                              my_switch_vrfs[vlan_details['svi_ip_addresses']['vrf']] = vrfs[tenant][vlan_details['svi_ip_addresses']['vrf']]
                          if vlan_aware_bundles.get(tenant):
                              for bundle, bundle_details in vlan_aware_bundles[tenant].items():
                                  if vlan in string_to_list(bundle_details['vlan_range']):
                                      my_switch_vlan_bundles[bundle] = bundle_details
                                      break
                              break

          # Get VRFs that should be configured on the switch
          for tenant in vrfs.keys():
              for vrf, info in vrfs[tenant].items():
                  # check if device is specified in Applied Devices
                  if device_matches_resolver_query(info['devices'], my_switch_facts['serial_number']):
                      my_switch_vrfs[vrf] = info
                      continue

                  # check if any l3 interfaces resolve
                  if len(info.get('l3_interfaces').resolve(device=my_switch_facts['serial_number'])['interfaces']) > 0:
                      my_switch_vrfs[vrf] = info
                      continue

                  # check if apply column resolves for any static routes
                  for sr in info.get('static_routes'):
                      # if static route is to be configured on switch
                      if device_matches_resolver_query(sr['devices'], my_switch_facts['serial_number']):
                          my_switch_vrfs[vrf] = info
                          break
                  if my_switch_vrfs.get(vrf):
                      continue
                  # check if apply column resolves for external bgp neighbors
                  for bgp_peer in info.get('external_bgp_peers'):
                      # if bgp peer is to be configured on switch
                      if device_matches_resolver_query(bgp_peer['devices'], my_switch_facts['serial_number']):
                          my_switch_vrfs[vrf] = info
                          break
                  if my_switch_vrfs.get(vrf):
                      continue
                  # check if apply column resolves for additional route targets
                  for rt in info.get('additional_route_targets'):
                      # if additional route target is to be configured on switch
                      if device_matches_resolver_query(rt['devices'], my_switch_facts['serial_number']):
                          my_switch_vrfs[vrf] = info
                          break

          my_switch_facts = normalize_tenant_info(my_switch_facts, my_switch_vrfs, my_switch_vlans, my_switch_vlan_bundles)
          if len(my_switch_facts['tenants'].keys()) > 0:
              my_config = {
                  "vrfs": {},
                  "vlans": {},
                  "vlan_interfaces": {},
                  "port_channel_interfaces": {},
                  "ethernet_interfaces": {},
                  "loopback_interfaces": {},
                  "virtual_source_nat_vrfs": {},
                  "static_routes": [],
                  "route_maps": {},
                  "router_bgp": {
                      "peer_groups": {},
                  }
              }
              my_config = set_base_config(my_config, my_switch_facts)
              my_config = set_network_services_config(my_config, my_switch_facts)
              my_config = clean_config(my_config)
          else:
              my_config = {}
          config = my_config
          switch_facts = my_switch_facts
          ctx.info(json.dumps(switch_facts, indent=2))
          %>
          ## eos - ip dhcp relay
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - ip dhcp snooping
          %if config.get("ip_dhcp_snooping"):
          ip dhcp snooping
          !
          %   if config["ip_dhcp_snooping"].get("information_option"):
          ip dhcp snooping information option
          %   endif
          %   if config["ip_dhcp_snooping"].get("vlans"):
          %       for vlan in config["ip_dhcp_snooping"]["vlans"]:
          ip dhcp snooping vlan ${vlan}
          %       endfor
          %   endif
          !
          %endif
          ## eos - IP IGMP Snooping
          % if config.get("ip_igmp_snooping"):
          %    if not config["ip_igmp_snooping"].get("globally_enabled"):
          no ip igmp snooping
          %    elif config["ip_igmp_snooping"].get("vlans"):
          %      for vlan in natural_sort(config["ip_igmp_snooping"]["vlans"].keys()):
          %          if config["ip_igmp_snooping"]["vlans"]["enabled"]["querier"] == False:
          no ip igmp snooping vlan ${ vlan } querier
          %          endif %}
          !
          %      endfor %}
          !
          %    endif
          %endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          %          if config["vlans"][vlan].get("etree") is not None and config["vlans"][vlan]["etree"]["role"] == "leaf":
             e-tree role ${ config["vlans"][vlan]["etree"]["role"] }
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          %   endfor
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface]["type"] == "l3dot1q" and config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
             encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
             ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %    if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %       for statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %    endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
             ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          !
          %   endfor
          %endif
          ## vlan-interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface]["vrf"] != "default":
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
             ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config["vlan_interfaces"][vlan_interface]["ip_address_secondaries"]:
             ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses") is not None:
          %         for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface]["ip_virtual_router_addresses"]:
             ip virtual-router address ${ ip_virtual_router_address }
          %         endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
             ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config["vlan_interfaces"][vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("arp_aging_timeout") is not None:
             arp aging timeout ${ config.get("vlan_interfaces")[vlan_interface]["arp_aging_timeout"] }
          %    endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("igmp"):
             ip igmp
          %       if config.get("vlan_interfaces")[vlan_interface]["igmp"].get("query_interval"):
             ip igmp query-interval ${config.get("vlan_interfaces")[vlan_interface]["igmp"]["query_interval"]}
          %       endif
          %     endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("multicast"):
          %       if config.get("vlan_interfaces")[vlan_interface]["multicast"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("static"):
             multicast ipv4 static
          %           endif
          %       endif
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("pim"):
          %       if config.get("vlan_interfaces")[vlan_interface]["pim"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("local_interface"):
             pim ipv4 local-interface ${config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"]["local_interface"]}
          %           endif
          %       endif
          %    endif
          %    if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %       for statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
             ${statement}
          %       endfor
          %    endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["source_interface"] }
          %     endif
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys()):
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan].get("multicast"):
             vxlan vlan ${ vlan } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["multicast"]["group"]}
          %               endif
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in natural_sort(config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys()):
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf].get("multicast"):
             vxlan vlan ${ vrf } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["multicast"]["group"]}
          %               endif
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - IP Routing
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          %   for vrf in config.get("vrfs"):
          %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % if config.get("static_routes"):
          %     for static_route in config["static_routes"]:
          <%         static_route_cli = "ip route" %>
          %         if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%             static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %         endif
          %         if static_route.get("destination_address_prefix"):
          <%             static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %         endif
          %         if static_route.get("interface"):
          <%             static_route_cli = static_route_cli + " " + static_route["interface"].upper() %>
          %         endif
          %         if static_route.get("gateway"):
          <%             static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %         endif
          %         if static_route.get("distance"):
          <%             static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %         endif
          %         if static_route.get("tag"):
          <%             static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %         endif
          %         if static_route.get("name"):
          <%             static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %         endif
          %         if static_route.get("metric"):
          <%             static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %         endif
          ${ static_route_cli }
          !
          %    endfor %}
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in natural_sort(config["route_maps"].keys()):
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## router-bgp
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in config["router_bgp"]["neighbors"].keys():
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
             neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
             neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor].remote_as }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in natural_sort(config["router_bgp"]["vlans"]):
             !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].get("rd") is not None:
                rd ${ config["router_bgp"]["vlans"][vlan]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in natural_sort(config["router_bgp"]["vrfs"].keys()):
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast"):
                evpn multicast
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
                neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
                !
                address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                   neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                   ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
      input_schema:
        fields:
          values:
            tenantName:
              id: tenantName
              name: name
              label: Name
              description: Specify a tenant name.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfName:
              id: vrfName
              name: name
              label: Name
              description: VRF Name
              required: true
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            iBgpSubnet:
              id: iBgpSubnet
              name: iBgpSubnet
              label: Peering Subnet
              description: Define the subnet of the host IP address for the iBGP peering of SVIs with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            iBgpVlanId:
              id: iBgpVlanId
              name: iBgpVlanId
              label: Peering VLAN
              description: Determine the VLAN used for iBGP peering with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            iBgpSubnetMask:
              id: iBgpSubnetMask
              name: iBgpSubnetMask
              label: Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            iBgpDetails:
              id: iBgpDetails
              name: iBgpDetails
              label: MLAG L3 Peering
              description: Create an iBGP peering between MLAG peers for this VRF.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - iBgpSubnet
                    - iBgpVlanId
                    - iBgpSubnetMask
            natInterface:
              id: natInterface
              name: natInterface
              label: Source NAT Loopback ID
              description: Define the loopback interface used for sourcing pings within this VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSourceNatSubnet:
              id: campusSourceNatSubnet
              name: subnet
              label: Subnet
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSite:
              id: campusSite
              name: site
              label: Site
              description: Set the source NAT interface IPv4 pool for the site. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Sites, enter a unique IPv4 pool per Site.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            sourceNatCampusResolver:
              id: sourceNatCampusResolver
              name: campus
              label: Campus Source NAT Subnets
              description: Select the campus for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSite
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            dataCenterSourceNatSubnet:
              id: dataCenterSourceNatSubnet
              name: subnet
              label: IPv4 Pool
              description: Enter an IPv4 pool in CIDR notation (i.e. 172.16.254.0/26).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            dataCenterPod:
              id: dataCenterPod
              name: dcPoD
              label: DC PoD
              description: Set the source NAT interface IPv4 pool for the data center Pod. The NodeId tag is used to assign an IP address to the source NAT loopback interface for this VRF. To avoid duplicate addresses being allocated across Pods, enter a unique IPv4 pool per DC-Pod.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC-Pod
                tag_filter_query: null
            sourceNatDataCenterResolver:
              id: sourceNatDataCenterResolver
              name: dataCenter
              label: Data Center Source NAT Subnets
              description: Select the data center for which to assign a source NAT interface IPv4 pool.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterPod
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC
                tag_filter_query: null
            natSourceDetails:
              id: natSourceDetails
              name: natSourceDetails
              label: Virtual Source NAT
              description: This will create a loopback with virtual source-nat enable to perform diagnostics from the switch.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - natInterface
                    - sourceNatCampusResolver
                    - sourceNatDataCenterResolver
            vrfOverrideRouteDistinguisher:
              id: vrfOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideRouteTarget:
              id: vrfOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideVariables:
              id: vrfOverrideVariables
              name: overrideVariables
              label: Override VRF Attributes
              description: Enter values specific to this VRF to override the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOverrideRouteDistinguisher
                    - vrfOverrideRouteTarget
            vrfOverrideVNI:
              id: vrfOverrideVNI
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay.
              required: true
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Name
              description: Name of the interface or subinterface to configure (i.e. Ethernet1 or Ethernet1.100).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: Raw EOS CLI statements to be configured under the interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: This will create an IP routed interface inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: Non-selectively redistributes static routes
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            additionalRouteTargetsRouteTarget:
              id: additionalRouteTargetsRouteTarget
              name: routeTarget
              label: Route Target
              description: Use the format <integer>:<integer>.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsType:
              id: additionalRouteTargetsType
              name: type
              label: Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - import
                    - export
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsAddressFamily:
              id: additionalRouteTargetsAddressFamily
              name: addressFamily
              label: Address Family
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: evpn
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsApply:
              id: additionalRouteTargetsApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            additionalRouteTargetsHostname:
              id: additionalRouteTargetsHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            additionalRouteTargetsDevicesGroup:
              id: additionalRouteTargetsDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsHostname
            additionalRouteTargetsDevicesResolver:
              id: additionalRouteTargetsDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure route targets on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            additionalRouteTargetsDetails:
              id: additionalRouteTargetsDetails
              name: routeTargetDetails
              label: Route Target Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsRouteTarget
                    - additionalRouteTargetsType
                    - additionalRouteTargetsAddressFamily
                    - additionalRouteTargetsDevicesResolver
            additionalRouteTargets:
              id: additionalRouteTargets
              name: additionalRouteTargets
              label: Additional Route Targets
              description: Configure extra route-targets for this VRF. Useful for route-leaking or gateway between address families.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: additionalRouteTargetsDetails
                key: ''
            externalBgpPeersNeighborIpAddress:
              id: externalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRemoteAs:
              id: externalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersDescription:
              id: externalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersPassword:
              id: externalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersSendCommunity:
              id: externalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopSelf:
              id: externalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersMaxRoutes:
              id: externalBgpPeersMaxRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWarningLimitRoutes:
              id: externalBgpPeersWarningLimitRoutes
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersMaxRoutesGroup:
              id: externalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersMaxRoutes
                    - externalBgpPeersWarningLimitRoutes
            externalBgpPeersUpdateSource:
              id: externalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: Name of source interface
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersEbgpMultihop:
              id: externalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWeight:
              id: externalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersRouteMapIn:
              id: externalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapOut:
              id: externalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapGroup:
              id: externalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: Enter the name of the route map to configure in/out for the peer.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersRouteMapIn
                    - externalBgpPeersRouteMapOut
            ebgpPeerDefaultOriginateEnable:
              id: ebgpPeerDefaultOriginateEnable
              name: ebgpPeerDefaultOriginateEnable
              label: Enable
              description: Enable default-originate for the peer.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginateAlways:
              id: externalBgpPeersDefaultOriginateAlways
              name: always
              label: Always
              description: The always option can be used to always artificially generate a default route and send this artificially generated default route to the neighbor irrespective of another default route being present in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            externalBgpPeersDefaultOriginate:
              id: externalBgpPeersDefaultOriginate
              name: defaultOriginate
              label: Default Originate
              description: The default-originate feature is used to advertise a default route to the neighbor even when a default route is not present in the BGP RIB. If a default route is present in the BGP RIB, this route will be advertised to the neighbor. When a default route is not present in the BGP RIB, one will be artificially generated and advertised to the neighbor for which this feature is configured. This artificially generated default route will not be installed in the BGP RIB.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ebgpPeerDefaultOriginateEnable
                    - externalBgpPeersDefaultOriginateAlways
            externalBgpPeersNextHopIpv4:
              id: externalBgpPeersNextHopIpv4
              name: iPv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopIpv6:
              id: externalBgpPeersNextHopIpv6
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopGroup:
              id: externalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by a uniquely generated route-map per neighbor. Next hop takes precedence over route_map_out.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNextHopIpv4
                    - externalBgpPeersNextHopIpv6
            externalBgpPeersApply:
              id: externalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            externalBgpPeersHostname:
              id: externalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            externalBgpPeersDevicesGroup:
              id: externalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersHostname
            externalBgpPeersDevicesResolver:
              id: externalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the BGP neighbor on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            externalBgpPeersLocalAs:
              id: externalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeeringName:
              id: externalBgpPeeringName
              name: bgpPeeringName
              label: Name
              description: Name of the BGP peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersDetails:
              id: externalBgpPeersDetails
              name: bgpPeerDetails
              label: BGP Peer Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNeighborIpAddress
                    - externalBgpPeersRemoteAs
                    - externalBgpPeersDescription
                    - externalBgpPeersPassword
                    - externalBgpPeersSendCommunity
                    - externalBgpPeersNextHopSelf
                    - externalBgpPeersMaxRoutesGroup
                    - externalBgpPeersUpdateSource
                    - externalBgpPeersEbgpMultihop
                    - externalBgpPeersWeight
                    - externalBgpPeersRouteMapGroup
                    - externalBgpPeersDefaultOriginate
                    - externalBgpPeersNextHopGroup
                    - externalBgpPeersDevicesResolver
                    - externalBgpPeersLocalAs
                    - externalBgpPeeringName
            externalBgpPeers:
              id: externalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: This will configure BGP neighbors inside the tenant VRF for peering with external devices. The configured peer will automatically be activated for ipv4 or ipv6 address family based on the ip address
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: externalBgpPeersDetails
                key: externalBgpPeeringName
            staticRoutesDescription:
              id: staticRoutesDescription
              name: description
              label: Description
              description: Unique description for the static route.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesApply:
              id: staticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            staticRoutesHostname:
              id: staticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            staticRoutesDevicesGroup:
              id: staticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesHostname
            staticRoutesDevicesResolver:
              id: staticRoutesDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to configure the static route on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            staticRoutesDestinationAddressPrefix:
              id: staticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesGateway:
              id: staticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesInterface:
              id: staticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesDistance:
              id: staticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesTag:
              id: staticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesMetric:
              id: staticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesDetails:
              id: staticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDestinationAddressPrefix
                    - staticRoutesGateway
                    - staticRoutesInterface
                    - staticRoutesDistance
                    - staticRoutesTag
                    - staticRoutesMetric
            staticRoutesGroup:
              id: staticRoutesGroup
              name: value
              label: Static Routes Group
              description: Group of members for Static Routes
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDescription
                    - staticRoutesDevicesResolver
                    - staticRoutesDetails
            staticRoutesCollection:
              id: staticRoutesCollection
              name: staticRoutes
              label: Static Routes
              description: This will create static routes inside the VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: staticRoutesGroup
                key: staticRoutesDescription
            vrfAssignApply:
              id: vrfAssignApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfAssignHostname:
              id: vrfAssignHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfAssignDevicesGroup:
              id: vrfAssignDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfAssignHostname
            vrfAssignDevicesResolver:
              id: vrfAssignDevicesResolver
              name: devices
              label: Devices
              description: Select the devices to apply this VRF to where the VRF won't be automatically applied from VLAN association, static routes, external BGP peerings, or additional route-targets.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfGroup:
              id: vrfGroup
              name: vrfGroup
              label: VRF Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - iBgpDetails
                    - natSourceDetails
                    - vrfOverrideVariables
                    - vrfOverrideVNI
                    - vrfL3InterfacesDevice
                    - vrfRedistributeStaticRoutesToggle
                    - additionalRouteTargets
                    - externalBgpPeers
                    - staticRoutesCollection
                    - vrfAssignDevicesResolver
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: Define L3 network services organized by vrf.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfGroup
                key: vrfName
            vlanAwareBundleVlanRange:
              id: vlanAwareBundleVlanRange
              name: vlanRange
              label: VLAN Range
              description: Assign VLANs to this bundle with their VLAN IDs. Specify separate VLANs with a comma and series with a hyphen (e.g 1-9, 14, 23-40).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleName:
              id: vlanAwareBundleName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteDistinguisher:
              id: vlanAwareBundleOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteTarget:
              id: vlanAwareBundleOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideVariables:
              id: vlanAwareBundleOverrideVariables
              name: overrideVariables
              label: Overide MAC-VRF Attributes
              description: Enter values specific to this VRF to overide the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleOverrideRouteDistinguisher
                    - vlanAwareBundleOverrideRouteTarget
            vlanAwareBundleGroup:
              id: vlanAwareBundleGroup
              name: vlanGroup
              label: VLAN Bundle Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleVlanRange
                    - vlanAwareBundleName
                    - vlanAwareBundleOverrideVariables
            vlanAwareBundles:
              id: vlanAwareBundles
              name: vlanAwareBundles
              label: VLAN Aware Bundles
              description: Configure a bundle of VLANs that share the same MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanAwareBundleGroup
                key: vlanAwareBundleName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: VLAN ID
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanBasedVlanName:
              id: vlanBasedVlanName
              name: name
              label: Name
              description: Enter a one-word name for the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanMemberSwitchApply:
              id: vlanMemberSwitchApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanMemberSwitchHostname:
              id: vlanMemberSwitchHostname
              name: hostname
              label: Hostname
              description: The service will not be configured unless Apply is selected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitchApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vlanMemberSwitch:
              id: vlanMemberSwitch
              name: switch
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanMemberSwitchHostname
            vlanMemberSwitches:
              id: vlanMemberSwitches
              name: switches
              label: VTEPs
              description: Select the devices to assign the VLAN to.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitch
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanDhcpServers:
              id: vlanDhcpServers
              name: dhcpServer
              label: DHCP Server
              description: Enter the FQDN or the IP address of the DHCP server.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelperSourceInterface:
              id: vlanDhcpHelperSourceInterface
              name: sourceInterface
              label: Source Interface
              description: Enter an interface to source DHCP relays from
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpServerDetail:
              id: vlanDhcpServerDetail
              name: dhcpServerDetail
              label: DHCP Server Detail
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpServers
                    - vlanDhcpHelperSourceInterface
            vlanDhcpServerDetails:
              id: vlanDhcpServerDetails
              name: dhcpServerDetails
              label: DHCP Helper Details
              description: Specify the location of the DHCP server for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpServerDetail
                key: vlanDhcpServers
            vlanL3OrL2:
              id: vlanL3OrL2
              name: l3OrL2
              label: Routed or Bridged
              description: If set to 'Routed', both the L3 SVI and L2 VLAN will be configured on a selected L3 device. If set to 'Bridged', only the L2 VLAN will be configured on a selected L3 device. Only the L2 VLAN will be configured on any L2 devices downstream of the selected L3 device.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSviVirtualIpAddress:
              id: vlanSviVirtualIpAddress
              name: sviVirtualIpAddress
              label: SVI Virtual IP Address
              description: Assign a virtual IP address to be used on the VLAN's SVI. This will be the default gateway for devices behind this VTEP on this VLAN. If the address type is 'ip address virtual' use CIDR notation (i.e. 192.168.0.1/24). If the address type is 'ip virtual-router address', enter either just an IP address (i.e. 192.168.0.1) or an IP address in CIDR notation (192.168.0.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanVirtualAddressConfigType:
              id: vlanVirtualAddressConfigType
              name: virtualAddressConfigType
              label: Virtual Address Config Type
              description: Set the virtual address type to be used to implement VARP.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSVIIpAddresses:
              id: vlanSVIIpAddresses
              name: sviIpAddresses
              label: SVI Addressing
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviVirtualIpAddress
                    - vlanVirtualAddressConfigType
            vlanOverrideVni:
              id: vlanOverrideVni
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanOverrideRouteDistinguisher:
              id: vlanOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideRouteTarget:
              id: vlanOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideVariables:
              id: vlanOverrideVariables
              name: overrideVariables
              label: Override Attributes
              description: Enter values specific to this VLAN and VRF to override the default generated attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanOverrideVni
                    - vlanOverrideRouteDistinguisher
                    - vlanOverrideRouteTarget
            vlanSviMtu:
              id: vlanSviMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '9214'
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpAgingTimeout:
              id: vlanSviArpAgingTimeout
              name: arpAgingTimeout
              label: ARP Aging Timeout
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpDetails:
              id: vlanSviArpDetails
              name: arp
              label: ARP
              description: Set the ARP aging timeout (seconds) for ARP entries for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviArpAgingTimeout
            vlanSviCliStatement:
              id: vlanSviCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCliStatements:
              id: vlanSviEosCliStatements
              name: eosCli
              label: EOS CLI
              description: Raw EOS CLI statements to be configured under the VLAN interface.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviCliStatement
                key: ''
            vlanVrf:
              id: vlanVrf
              name: vrf
              label: VRF
              description: Select a VRF for this VLAN to be a member of.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            etreeRole:
              id: etreeRole
              name: role
              label: Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Root
                format: null
                length: null
                pattern: null
                dynamic_options: null
            etreeRootSwitches:
              id: etreeRootSwitches
              name: eTreeRootSwitches
              label: E Tree Root Switches
              description: Specify which switches are Etree Root for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: etreeRole
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: ''
                tag_filter_query: null
            vlanVxlanToggle:
              id: vlanVxlanToggle
              name: vxlan
              label: VXLAN
              description: Extend this VLAN over the VXLAN overlay. If not extending, SVI parameters are defined under VTEPs resolver.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            nodeSviIpAddress:
              id: nodeSviIpAddress
              name: ipAddress
              label: IP Address
              description: Enter an IP address and subnet mask in CIDR notation for the SVI (i.e. 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            nodeVirtualSviIpAddress:
              id: nodeVirtualSviIpAddress
              name: virtualIpAddress
              label: Virtual IP Address
              description: Enter an IP address and optionally a subnet mask for the SVI (i.e. 1.1.1.1 or 1.1.1.1/24).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            nodeSviIpInfo:
              id: nodeSviIpInfo
              name: sviIpInfo
              label: SVI IP Info
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - nodeSviIpAddress
                    - nodeVirtualSviIpAddress
            nodeVlanDetails:
              id: nodeVlanDetails
              name: nodes
              label: SVI Addressing
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: nodeSviIpInfo
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            etreeEnable:
              id: etreeEnable
              name: etreeEnable
              label: Enable
              description: Enable Etree for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            leafExportRouteTargetOffset:
              id: leafExportRouteTargetOffset
              name: leafExportRouteTargetOffset
              label: Leaf Export Route Target Offset
              description: This number is added to the second half of the leaf export route target.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            eTreeDetails:
              id: eTreeDetails
              name: eTreeDetails
              label: Etree
              description: Enable Etree for this VLAN. All VTEPs will be a Leaf node by default. Root switches are specified below.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - etreeEnable
                    - leafExportRouteTargetOffset
            vlanBasedVlans:
              id: vlanBasedVlans
              name: vlanBasedVlaNs
              label: VLAN Definitions
              description: VLAN based VLANs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanBasedVlanName
                    - vlanMemberSwitches
                    - vlanDhcpServerDetails
                    - vlanL3OrL2
                    - vlanSVIIpAddresses
                    - vlanOverrideVariables
                    - vlanSviMtu
                    - vlanSviArpDetails
                    - vlanSviEosCliStatements
                    - vlanVrf
                    - vlanVxlanToggle
                    - nodeVlanDetails
                    - eTreeDetails
                    - etreeRootSwitches
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: Define L2 network services organized by VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanBasedVlans
                key: vlanId
            macVrfVniBase:
              id: macVrfVniBase
              name: macVrfVniBase
              label: MAC-VRF VNI Base
              description: Set the default number that generates each Virtual Network Identifier by adding it to the specific VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            tenantDefinition:
              id: tenantDefinition
              name: tenantDefinition
              label: Tenant Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantName
                    - vrfs
                    - vlanAwareBundles
                    - vlans
                    - macVrfVniBase
            tenants:
              id: tenants
              name: tenants
              label: Tenants
              description: Network services are grouped by tenants. Tenants can be organizations or departments. The filtering model allows for granular deployment of network service to the fabric leveraging the tenant name and tags applied to the service definition.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantDefinition
                key: tenantName
            vrfRouteDistinguisherFormat:
              id: vrfRouteDistinguisherFormat
              name: vrfRouteDistinguisherFormat
              label: VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfRouteTargetFormat:
              id: vrfRouteTargetFormat
              name: vrfRouteTargetFormat
              label: VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfAttributeFormats:
              id: vrfAttributeFormats
              name: vrfAttributeFormats
              label: VRF Attributes
              description: Set the default format for how VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfRouteDistinguisherFormat
                    - vrfRouteTargetFormat
            vlanBasedMacVrfRouteDistinguisherFormat:
              id: vlanBasedMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - Router-ID:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfRouteTargetFormat:
              id: vlanBasedMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                    - VLAN:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfAttributeFormats:
              id: vlanBasedMacVrfAttributeFormats
              name: vlanBasedMacVrfAttributeFormats
              label: VLAN Based MAC-VRF Attributes
              description: Set the default format for how VLAN based MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBasedMacVrfRouteDistinguisherFormat
                    - vlanBasedMacVrfRouteTargetFormat
            vlanBundleMacVrfRouteDistinguisherFormat:
              id: vlanBundleMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:First-VLAN
                static_options:
                  values:
                    - Router-ID:First-VLAN
                    - Router-ID:First-VNI
                    - Router-ID:Last-VLAN
                    - Router-ID:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfRouteTargetFormat:
              id: vlanBundleMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: First-VNI:Last-VNI
                static_options:
                  values:
                    - First-VLAN:First-VLAN
                    - First-VNI:First-VNI
                    - Last-VLAN:Last-VLAN
                    - Last-VNI:Last-VNI
                    - First-VLAN:Last-VLAN
                    - First-VNI:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfAttributeFormats:
              id: vlanBundleMacVrfAttributeFormats
              name: vlanBundleMacVrfAttributeFormats
              label: VLAN Bundle MAC-VRF Attributes
              description: Set the default format for how VLAN bundled MAC-VRF attributes are generated.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBundleMacVrfRouteDistinguisherFormat
                    - vlanBundleMacVrfRouteTargetFormat
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenants
                    - vrfAttributeFormats
                    - vlanBasedMacVrfAttributeFormats
                    - vlanBundleMacVrfAttributeFormats
        layout:
          value: |
            {
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "tenants":{
                "key":"tenants",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanBasedVlans":{
                "key":"vlanBasedVlans",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlanMemberSwitches",
                  "vlanBasedVlanName",
                  "vlanVxlanToggle",
                  "vlanL3OrL2",
                  "vlanVrf",
                  "vlanSVIIpAddresses",
                  "nodeVlanDetails",
                  "vlanDhcpServerDetails",
                  "vlanSviMtu",
                  "vlanSviArpDetails",
                  "eTreeDetails",
                  "etreeRootSwitches",
                  "vlanSviEosCliStatements",
                  "vlanOverrideVariables"
                ]
              },
              "vrfGroup":{
                "key":"vrfGroup",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfOverrideVNI",
                  "iBgpDetails",
                  "natSourceDetails",
                  "vrfL3InterfacesDevice",
                  "staticRoutesCollection",
                  "vrfRedistributeStaticRoutesToggle",
                  "externalBgpPeers",
                  "additionalRouteTargets",
                  "vrfAssignDevicesResolver",
                  "vrfOverrideVariables"
                ]
              },
              "vlanL3OrL2":{
                "key":"vlanL3OrL2",
                "valueToLabelMap":{
                  "True":"Routed",
                  "False":"Bridged"
                },
                "type":"INPUT"
              },
              "vlanSviVirtualIpAddress":{
                "key":"vlanSviVirtualIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vlanSviSecondaryIpAddress":{
                "key":"vlanSviSecondaryIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "tenantDefinition":{
                "key":"tenantDefinition",
                "type":"INPUT",
                "order":[
                  "tenantName",
                  "vrfs",
                  "macVrfVniBase",
                  "vlans",
                  "vlanAwareBundles"
                ]
              },
              "iBgpDetails":{
                "key":"iBgpDetails",
                "type":"INPUT",
                "order":[
                  "iBgpVlanId",
                  "iBgpSubnet",
                  "iBgpSubnetMask"
                ]
              },
              "vlanDhcpServerVrf":{
                "key":"vlanDhcpServerVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanDhcpServers":{
                "key":"vlanDhcpServers",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareBundleGroup":{
                "key":"vlanAwareBundleGroup",
                "type":"INPUT",
                "order":[
                  "vlanAwareBundleName",
                  "vlanAwareBundleVlanRange",
                  "vlanAwareBundleOverrideVariables"
                ]
              },
              "vlanAwareBundles":{
                "key":"vlanAwareBundles",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanMemberSwitches":{
                "key":"vlanMemberSwitches",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vlanVrf":{
                "key":"vlanVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfOverrideVariables":{
                "key":"vrfOverrideVariables",
                "type":"INPUT",
                "order":[
                  "vrfOverrideRouteDistinguisher",
                  "vrfOverrideRouteTarget"
                ]
              },
              "vlanMemberSwitchApply":{
                "key":"vlanMemberSwitchApply",
                "dependency":{
                  "vlanMemberSwitchApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSVIIpAddresses":{
                "key":"vlanSVIIpAddresses",
                "type":"INPUT",
                "order":[
                  "vlanSviVirtualIpAddress",
                  "vlanVirtualAddressConfigType"
                ]
              },
              "vlanVirtualAddressConfigType":{
                "key":"vlanVirtualAddressConfigType",
                "valueToLabelMap":{
                  "True":"ip address virtual",
                  "False":"ip virtual-router address"
                },
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vlanVxlanToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "natSourceDetails":{
                "key":"natSourceDetails",
                "type":"INPUT",
                "order":[
                  "sourceNatDataCenterResolver",
                  "sourceNatCampusResolver",
                  "natInterface"
                ]
              },
              "campusSite":{
                "key":"campusSite",
                "type":"INPUT",
                "isPageLayout":false
              },
              "vlanSviMtu":{
                "key":"vlanSviMtu",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSviArpAgingTimeout":{
                "key":"vlanSviArpAgingTimeout",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfacesDevice":{
                "key":"vrfL3InterfacesDevice",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfacesCollection"
                ]
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeers":{
                "key":"externalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeersDetails":{
                "key":"externalBgpPeersDetails",
                "type":"INPUT",
                "order":[
                  "externalBgpPeeringName",
                  "externalBgpPeersDevicesResolver",
                  "externalBgpPeersNeighborIpAddress",
                  "externalBgpPeersRemoteAs",
                  "externalBgpPeersDescription",
                  "externalBgpPeersPassword",
                  "externalBgpPeersSendCommunity",
                  "externalBgpPeersNextHopSelf",
                  "externalBgpPeersMaxRoutesGroup",
                  "externalBgpPeersUpdateSource",
                  "externalBgpPeersEbgpMultihop",
                  "externalBgpPeersWeight",
                  "externalBgpPeersNextHopGroup",
                  "externalBgpPeersRouteMapGroup",
                  "externalBgpPeersDefaultOriginate",
                  "externalBgpPeersLocalAs"
                ]
              },
              "staticRoutesCollection":{
                "key":"staticRoutesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSviCliStatement":{
                "key":"vlanSviCliStatement",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfAssignDevicesGroup":{
                "key":"vrfAssignDevicesGroup",
                "type":"INPUT",
                "order":[
                  "vrfAssignHostname",
                  "vrfDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "vlanMemberSwitch":{
                "key":"vlanMemberSwitch",
                "type":"INPUT",
                "order":[
                  "vlanMemberSwitchHostname",
                  "vlanDeviceAssignmentSwitchFactsTagger"
                ]
              },
              "additionalRouteTargetsApply":{
                "key":"additionalRouteTargetsApply",
                "dependency":{
                  "additionalRouteTargetsApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "externalBgpPeersApply":{
                "key":"externalBgpPeersApply",
                "dependency":{
                  "externalBgpPeersApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "staticRoutesApply":{
                "key":"staticRoutesApply",
                "dependency":{
                  "staticRoutesApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfAssignApply":{
                "key":"vrfAssignApply",
                "type":"INPUT",
                "dependency":{
                  "vrfAssignApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "staticRoutesNetworkServicesTagger":{
                "type":"TAGGER",
                "parentKey":"staticRoutesDevicesGroup",
                "key":"staticRoutesNetworkServicesTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  }
                ]
              },
              "vlanDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vlanMemberSwitch",
                "key":"vlanDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagFilterQuery":"Vtep:True ",
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "externalBgpPeersSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"externalBgpPeersDevicesGroup",
                "key":"externalBgpPeersSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "additionalRouteTargetsSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"additionalRouteTargetsDevicesGroup",
                "key":"additionalRouteTargetsSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "vrfDeviceAssignmentSwitchFactsTagger":{
                "type":"TAGGER",
                "parentKey":"vrfAssignDevicesGroup",
                "key":"vrfDeviceAssignmentSwitchFactsTagger",
                "name":"Switch Facts",
                "assignmentType":"MULTIPLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"Used to set switch properties necessary for VTEPs.",
                "columns":[
                  {
                    "tagLabel":"Vtep",
                    "suggestedValues":[
                      "True",
                      "False"
                    ]
                  },
                  {
                    "tagLabel":"NetworkServices",
                    "suggestedValues":[
                      "L2",
                      "L3"
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                    ]
                  }
                ]
              },
              "nodeVirtualSviIpAddress":{
                "key":"nodeVirtualSviIpAddress",
                "dependency":{
                  "vlanVxlanToggle":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "nodeSviIpAddress":{
                "key":"nodeSviIpAddress",
                "dependency":{
                  "vlanVxlanToggle":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "nodeVlanDetails":{
                "key":"nodeVlanDetails",
                "type":"INPUT",
                "fieldOverrides":{
                  "label":"Device",
                  "description":"Add switches to set SVI IP addresses for.",
                  "addButtonLabel":"Device"
                }
              },
              "externalBgpPeersDefaultOriginate":{
                "key":"externalBgpPeersDefaultOriginate",
                "type":"INPUT",
                "order":[
                  "ebgpPeerDefaultOriginateEnable",
                  "externalBgpPeersDefaultOriginateAlways"
                ]
              },
              "externalBgpPeersDefaultOriginateAlways":{
                "key":"externalBgpPeersDefaultOriginateAlways",
                "type":"INPUT",
                "dependency":{
                  "ebgpPeerDefaultOriginateEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "etreeRootSwitches":{
                "key":"etreeRootSwitches",
                "type":"INPUT",
                "isPageLayout":false,
                "showDefaultRow":false
              },
              "etreeEnable":{
                "key":"etreeEnable",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "etreeRole":{
                "key":"etreeRole",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafExportRouteTargetOffset":{
                "key":"leafExportRouteTargetOffset",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  },
                  "etreeEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              }
            }
