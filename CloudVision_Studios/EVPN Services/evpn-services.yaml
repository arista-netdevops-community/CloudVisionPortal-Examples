- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: studio-evpn-services
        workspace_id: &workspace_id ws-evpn-services
      display_name: EVPN Services
      description: Define and configure EVPN services for an L3 network fabric, including configuration of VRFs, VNIs, VLANs and associated IP addressing
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          from collections import OrderedDict
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          veos_regex = r'(v|c)EOS(-)*(Lab)*'

          def convert(text):
              return int(text) if text.isdigit() else text.lower()

          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]

          def natural_sort(iterable):
              if iterable is None:
                  return list()
              return sorted(iterable, key=alphanum_key)

          def string_to_list(string_to_convert):
              numbers = []
              segments = [ segment.strip() for segment in string_to_convert.split(",") ]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          numbers.append(i)
                  else:
                      numbers.append(int(segment))    
              return numbers

          from itertools import count, groupby
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))

          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None

          def check_vni_overlap(vrfs, vlans):
              '''
              Summary:
                  Asserts errors if vlans or vnis use overlapping vni numbers
              Returns
                  None
              '''
              vnis_seen = {}
              for vlan, vlan_details in vlans.items():
                  assert vnis_seen.get(vlan_details["vni"]) is None, "VNI {} found in multiple places -> {} in tenant {} and {} in tenant {}. Please correct the VNI conflict before moving forward.".format(
                      vlan_details["vni"],  vnis_seen[vlan_details["vni"]]["error_name"], vnis_seen[vlan_details["vni"]]["tenant"],
                      vlan_details["error_name"], vlan_details["tenant"]
                  )
                  vnis_seen[vlan_details["vni"]] = vlan_details
              for vrf, vrf_details in vrfs.items():
                  assert vnis_seen.get(vrf_details["vni"]) is None, "VNI {} found in multiple places -> {} in tenant {} and {} in tenant {}. Please correct the VNI conflict before moving forward.".format(
                      vrf_details["vni"],  vnis_seen[vrf_details["vni"]]["error_name"], vnis_seen[vrf_details["vni"]]["tenant"],
                      vrf_details["error_name"], vrf_details["tenant"]
                  )
                  vnis_seen[vrf_details["vni"]] = vrf_details

          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, "MLAG Subnet mask length must be longer than the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[int(switch_facts["mlag_primary_id"]) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return

          def normalize_tenant_info(switch_facts, switch_vrfs, switch_vlans, switch_vlan_bundles):
              switch_facts["tenants"] = {}
              # Normalize VRFs
              for vrf, info in switch_vrfs.items():        
                  # If tenant not already created in tenants, create it
                  if not switch_facts["tenants"].get(info["tenant"]):
                      switch_facts["tenants"][info["tenant"]] = {
                          "vrfs": {
                              "default":{
                                  "svis": {},
                                  "vrf_vni": None,
                                  "l3_interfaces": [],
                                  "static_routes": [],
                                  "redistribute_static": None,
                                  "bgp_peers": {},
                                  "additional_route_targets": []
                              }
                          },
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  switch_facts["tenants"][info["tenant"]]["vrfs"][vrf] = {
                      "svis": {},
                      "vrf_vni": info["vni"],
                      "l3_interfaces": [],
                      "static_routes": [],
                      "redistribute_static": None,
                      "bgp_peers": {},
                      "additional_route_targets": []
                  }
                  # normalize mlag ibgp details
                  if info.get("ibgp_details") and info["ibgp_details"].get("iBgpSubnet") and switch_facts.get("mlag"):
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["enable_mlag_ibgp_peering_vrfs"] = True
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["mlag_ibgp_peering_vlan"] = info["ibgp_details"]["iBgpVlanId"]
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["mlag_ibgp_peering_subnet"] = info["ibgp_details"]["iBgpSubnet"]
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"] = info["ibgp_details"]["iBgpSubnetMask"]
                  # normalize source nat details
                  if info["nat_source_details"].get("natInterface"):
                      nat_subnet = info["nat_source_details"]["campus"].resolve(device=switch_facts["serial_number"])["site"].resolve(device=switch_facts["serial_number"])["subnet"]
                      if nat_subnet is None or nat_subnet.strip() == "":
                          nat_subnet = info["nat_source_details"]["dataCenter"].resolve(device=switch_facts["serial_number"])["dcPoD"].resolve(device=switch_facts["serial_number"])["subnet"]
                      if nat_subnet is not None and nat_subnet.strip() != "":
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["vtep_diagnostic"] = {
                              "loopback": "".join(re.findall(r'\d', info["nat_source_details"]["natInterface"])),
                              "loopback_ip_range": nat_subnet
                          }

                  # normalize l3 interfaces
                  for iface in info.get("l3_interfaces").resolve(device=switch_facts["serial_number"])["interfaces"]:
                      l3_interface = {}
                      l3_interface["interfaces"] = [iface["name"]]
                      l3_interface["ip_addresses"] = [iface["ipAddress"]]
                      l3_interface["nodes"] = [switch_facts["serial_number"]]
                      l3_interface["description"] = iface["description"]
                      l3_interface["enabled"] = iface["enabled"]
                      l3_interface["mtu"] = iface["mtu"]
                      l3_interface["encapsulation_dot1q_vlan"] = None
                      l3_interface["eos_cli"] = iface["eosCli"]
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["l3_interfaces"].append(l3_interface)

                  # normalize static routes
                  for sr in info.get("static_routes"):
                      # if static route is to be configured on switch
                      if sr["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          static_route = {}
                          static_route["destination_address_prefix"] = sr["routeDetails"].get("destinationAddressPrefix")
                          static_route["gateway"] = sr["routeDetails"].get("gateway")
                          static_route["distance"] = sr["routeDetails"].get("distance")
                          static_route["tag"] = sr["routeDetails"].get("tag")
                          static_route["name"] = sr["description"].replace(" ", "_")
                          static_route["metric"] = sr["routeDetails"].get("metric")
                          static_route["interface"] = sr["routeDetails"].get("interface")
                          static_route["nodes"] = [switch_facts["serial_number"]]
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["static_routes"].append(static_route)
                  
                  # normalize redistribute routes
                  switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["redistribute_static"] = info.get("redistribute_static_routes")
                  
                  # normalize external bgp peers
                  for bgp_peer in info.get("external_bgp_peers"):
                      # if bgp peer is to be configured on switch
                      if bgp_peer["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          peer_info = {}
                          peer_info["remote_as"] = bgp_peer["remoteAs"]
                          if bgp_peer.get("description") and bgp_peer["description"].strip() != "":
                              peer_info["description"] = bgp_peer["description"]
                          if bgp_peer.get("password") and bgp_peer["password"].strip() != "":
                              peer_info["password"] = bgp_peer["password"]
                          if bgp_peer.get("sendCommunity") and bgp_peer["sendCommunity"].strip() != "":
                              peer_info["send_community"] = bgp_peer["sendCommunity"]
                          if bgp_peer.get("nextHopSelf") and bgp_peer["nextHopSelf"].strip() != "":
                              peer_info["next_hop_self"] = bgp_peer["nextHopSelf"]
                          if bgp_peer["maxRoutes"].get("maximumRoutes"):
                              peer_info["maximum_routes"] = bgp_peer["maxRoutes"].get("maximumRoutes")
                          if bgp_peer["maxRoutes"].get("warningLimit"):
                              peer_info["warning_limit_routes"] = bgp_peer["maxRoutes"].get("warningLimit")
                          if bgp_peer["defaultOriginate"].get("always") and bgp_peer["defaultOriginate"]["always"].strip() != "":
                              peer_info["default_originate"] = {
                                  "always": bgp_peer["defaultOriginate"].get("always")
                              }
                          if bgp_peer.get("updateSource") and bgp_peer["updateSource"].strip() != "":
                              peer_info["update_source"] = bgp_peer["updateSource"]
                          if bgp_peer.get("ebgpMultihop"):
                              peer_info["ebgp_multihop"] = bgp_peer["ebgpMultihop"]

                          peer_info["nodes"] = [switch_facts["serial_number"]]
                          
                          if bgp_peer["nextHop"].get("iPv4NextHop") and bgp_peer["nextHop"]["iPv4NextHop"].strip() != "":
                              peer_info["set_ipv4_next_hop"] = bgp_peer["nextHop"]["iPv4NextHop"]
                          if bgp_peer["nextHop"].get("iPv6NextHop") and bgp_peer["nextHop"]["iPv6NextHop"].strip() != "":
                              peer_info["set_ipv6_next_hop"] = bgp_peer["nextHop"]["iPv6NextHop"]
                          if bgp_peer["routeMap"].get("routeMapOut") and bgp_peer["routeMap"]["routeMapOut"].strip() != "":
                              peer_info["route_map_out"] = bgp_peer["routeMap"]["routeMapOut"] 
                          if bgp_peer["routeMap"].get("routeMapIn") and bgp_peer["routeMap"]["routeMapIn"].strip() != "":
                              peer_info["route_map_in"] = bgp_peer["routeMap"]["routeMapIn"]
                          if bgp_peer.get("weight"):
                              peer_info["weight"] = bgp_peer["weight"]
                          if bgp_peer.get("localAs"):
                              peer_info["local_as"] = bgp_peer["localAs"]
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["bgp_peers"][bgp_peer["neighborIpAddress"]] = peer_info
                      
                  # normalize additional route targets
                  for rt in info.get("additional_route_targets"):
                      # if additional route target is to be configured on switch
                      if rt["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          route_target = {}
                          route_target["type"] = rt["type"]
                          route_target["address_family"] = rt["addressFamily"]
                          route_target["route_target"] = rt["routeTarget"]
                          route_target["nodes"] = [switch_facts["serial_number"]]
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["additional_route_targets"].append(route_target)

                  # normalize rd and rt
                  switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["route_distinguisher"] = info["route_distinguisher"]
                  switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["route_target"] = info["route_target"]

              # Normalize VLANs
              for vlan, info in switch_vlans.items():
                  # If tenant not already created in tenants, create it
                  if not switch_facts["tenants"].get(info["tenant"]):
                      switch_facts["tenants"][info["tenant"]] = {
                          "vrfs": {
                              "default":{
                                  "svis": {},
                                  "vrf_vni": None,
                                  "l3_interfaces": [],
                                  "static_routes": [],
                                  "redistribute_static": None,
                                  "bgp_peers": {},
                                  "additional_route_targets": []
                              }
                          },
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  # Check if VLAN is L2 or L3
                  # If this is an L3 VLAN
                  if info.get("svi_ip_addresses"):
                      if info["svi_ip_addresses"].get("vrf") and info["svi_ip_addresses"]["vrf"].strip() != "None":
                          vrf = info["svi_ip_addresses"].get("vrf")
                      else:
                          vrf = "default"
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)] = {
                          "enabled": True,
                          "vni": info["vni"],
                          "eos_cli": info["eos_cli"]
                      }
                      #normalize name 
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["name"] = info["name"] if info["name"].strip() != "" else None
                      # Set vip
                      svi_vip = info["svi_ip_addresses"]["sviVirtualIpAddress"]
                      if info["svi_ip_addresses"]["virtualAddressConfigType"] == True:
                          # configure ip address virtual
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"]\
                              [int(vlan)]["ip_address_virtual"] = svi_vip
                      else:
                          # configure ip virtual-router address and real ip address
                          svi_network = ipaddress.ip_interface(svi_vip).network
                          first_host = list(svi_network.hosts())[0]
                          last_host = list(svi_network.hosts())[-1]
                          if str(first_host) == svi_vip.split("/")[0]:
                              position = "start"
                          elif str(last_host) == svi_vip.split("/")[0]:
                              position = "end"
                          else:
                              assert False, "Error: {}'s virtual IP address must be either the " \
                              "first or last host address in the subnet if 'ip virtual-router address'"\
                              " config type is set".format(vlan)
                          if switch_facts.get("mlag_role") and switch_facts["mlag_role"] == "secondary":
                              # take higher host address closest to vip
                              if position == "start":
                                  svi_ip = list(svi_network.hosts())[2]
                              else:
                                  svi_ip = list(svi_network.hosts())[-2]
                          else:
                              # take lower host address closest to vip
                              if position == "start":
                                  svi_ip = list(svi_network.hosts())[1]
                              else:
                                  svi_ip = list(svi_network.hosts())[-3]
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"]\
                              [int(vlan)]["ip_virtual_router_addresses"] = [svi_vip]
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"]\
                              [int(vlan)]["ip_address"] = "{}/{}".format(svi_ip, svi_network.prefixlen)
                      # normalize ip helper info
                      if len(info["dhcp_server_details"]) > 0:
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["ip_helpers"] = {}
                          for dhcp_info in info["dhcp_server_details"]:
                              switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]\
                              ["svis"][int(vlan)]["ip_helpers"][dhcp_info["dhcpServer"]] = {}
                              if dhcp_info.get("sourceInterface") and dhcp_info.get("sourceInterface").strip() != "":
                                  # set source interface associated with vrf
                                  switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]\
                                  ["svis"][int(vlan)]["ip_helpers"][dhcp_info["dhcpServer"]]["source_interface"] = dhcp_info["sourceInterface"]

                      # normalize mtu
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["mtu"] = info["mtu"]
                      # normalize arp
                      if info.get("arp"):
                          switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["arp"] = {}
                          if info["arp"].get("arpAgingTimeout"):
                              switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["arp"]["aging_timeout"] = info["arp"]["arpAgingTimeout"]
                      
                      # normalize vni, rd, rt
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["vni_override"] = info.get("vni_override")
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["route_distinguisher"] = info.get("route_distinguisher")
                      switch_facts["tenants"][info["tenant"]]["vrfs"][vrf]["svis"][int(vlan)]["route_target"] = info.get("route_target")
                  else:
                      # If this is an L2 VLAN
                      switch_facts["tenants"][info["tenant"]]["l2vlans"][int(vlan)] = {
                          "vxlan": True,
                          "vni": info["vni"],
                          "vni_override": info.get("vni_override")
                      }
                      #normalize name 
                      switch_facts["tenants"][info["tenant"]]["l2vlans"][int(vlan)]["name"] = info["name"] if info["name"].strip() != "" else None
                      
                      switch_facts["tenants"][info["tenant"]]["l2vlans"][int(vlan)]["route_distinguisher"] = info["route_distinguisher"]
                      switch_facts["tenants"][info["tenant"]]["l2vlans"][int(vlan)]["route_target"] = info["route_target"]
              # Normalize vlan_aware_bundles
              for vlan_aware_bundle, info in switch_vlan_bundles.items():
                  # If tenant not already created in tenants, create it
                  if not switch_facts["tenants"].get(info["tenant"]):
                      switch_facts["tenants"][info["tenant"]] = {
                          "vrfs": {},
                          "l2vlans": {},
                          "vlan_aware_bundles": {}
                      }
                  switch_facts["tenants"][info["tenant"]]["vlan_aware_bundles"][vlan_aware_bundle] = {
                      "vlan_range": info["vlan_range"],
                      "route_distinguisher": info["route_distinguisher"],
                      "route_target": info["route_target"]
                  }

              return switch_facts

          def set_base_config(config, switch_facts):    
              # Set router-bgp
              if switch_facts["network_services"].get("l3"):
                  config["ip_routing"] = True
                  config["router_bgp"]["as"] = switch_facts["bgp_as"]
                  config["router_bgp"]["router_id"] = switch_facts["router_id"]
              return config

          def set_network_services_config(config, switch_facts):
              # Configure vlans
              if switch_facts["network_services"].get("l2"):
                  # Enable dhcp smart relay
                  config["ip_dhcp_relay"] = {
                      "information_option": True
                  }
                  # Enable dhcp snooping
                  config["ip_dhcp_snooping"] = {
                      "information_option": True,
                      "vlans": []
                  }
                  for tenant in switch_facts["tenants"].keys():
                      # Set l3 vlan config
                      for vrf in switch_facts["tenants"][tenant]["vrfs"].keys():
                          # Create vlans
                          for svi in switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"].keys():
                              #Create L3 vlans
                              config["vlans"][svi] = {
                                  "tenant": tenant,
                                  "name": switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"][svi]["name"]
                              }
                              # Create L3 SVI with helper address pointing towards CVP
                              config["vlan_interfaces"]["Vlan{}".format(svi)] = {}
                              if vrf == "default":
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                                      "127.0.0.1": {}
                                  }
                                  # enable snooping on that vlan
                                  config["ip_dhcp_snooping"]["vlans"].append(svi)

                          # Set vrf ibgp peering vlan params
                          if switch_facts.get("mlag") and switch_facts["network_services"].get("l3") \
                              and switch_facts["tenants"][tenant]["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                              ibgp_vlan = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                              config["vlans"][ibgp_vlan] = {
                                  "tenant": tenant,
                                  "name": "MLAG_iBGP_{}".format(vrf),
                                  "trunk_groups": ["MLAG_VRF_PEER"]
                              }
                          
                      # Set l2 vlan config
                      for vlan, info in switch_facts["tenants"][tenant]["l2vlans"].items():
                          config["vlans"][vlan] = {
                              "tenant": tenant,
                              "name": info["name"]
                          }
                          # Create L2 SVI with helper address pointing towards CVP
                          config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                              "127.0.0.1": {}
                          }
                          # enable snooping on the vlan
                          config["ip_dhcp_snooping"]["vlans"].append(vlan)

              if switch_facts["network_services"].get("l3"):
                  for tenant in switch_facts["tenants"].keys():
                      for vrf, info in switch_facts["tenants"][tenant]["vrfs"].items():
                          # configure vrfs
                          config["vrfs"][vrf] = {
                              "tenant": tenant,
                              "ip_routing": True
                          }
                          # configure static routes
                          if info.get("static_routes") is not None:
                              for static_route in info["static_routes"]:
                                  sr = {
                                      "destination_address_prefix": static_route["destination_address_prefix"],
                                      "vrf": vrf
                                  }
                                  if static_route.get("gateway") and static_route["gateway"].strip() != "":
                                      sr["gateway"] = static_route["gateway"]
                                  if static_route.get("distance") and static_route["distance"].strip() != "":
                                      sr["distance"] = static_route["distance"]
                                  if static_route.get("tag") and static_route["tag"].strip() != "":
                                      sr["tag"] = static_route["tag"]
                                  if static_route.get("name") and static_route["name"].strip() != "":
                                      sr["name"] = static_route["name"]
                                  if static_route.get("metric") and static_route["metric"].strip() != "":
                                      sr["metric"] = static_route["metric"]
                                  if static_route.get("interface") and static_route["interface"].strip() != "":
                                      sr["interface"] = static_route["interface"]
                                  config["static_routes"].append(sr)
                                  
                          # configure ethernet interfaces
                          if info.get("l3_interfaces") is not None:
                              l3_interface_subif_parents = []
                              for l3_iface in info["l3_interfaces"]:
                                  eth_iface = {}
                                  l3_interface_subif_id = None
                                  if "." in l3_iface["interfaces"][0]:
                                      if l3_iface.get("encapsulation_dot1q_vlan"):
                                          l3_interface_subif_id = l3_iface["encapsulation_dot1q_vlan"]
                                      else:
                                          l3_interface_subif_id = l3_iface["interfaces"][0].split('.')[1]
                                      l3_interface_subif_parents.append(l3_iface["interfaces"][0].split('.')[0])
                                  if l3_interface_subif_id is not None:
                                      eth_iface["type"] = "l3dot1q"
                                      eth_iface["encapsulation_dot1q_vlan"] = l3_interface_subif_id
                                  else:
                                      eth_iface["type"] = "routed"
                                  eth_iface["peer_type"] = "l3_interface"
                                  eth_iface["vrf"] = vrf
                                  eth_iface["ip_address"] = l3_iface["ip_addresses"][0]
                                  if l3_iface.get("mtu"):
                                      eth_iface["mtu"] = l3_iface["mtu"]
                                  if l3_iface.get("enabled"):
                                      eth_iface["shutdown"] = False
                                  else:
                                      eth_iface["shutdown"] = True
                                  if l3_iface.get("description") and l3_iface["description"].strip() != "":
                                      eth_iface["description"] = l3_iface["description"]
                                  if l3_iface.get("eos_cli"):
                                      eth_iface["eos_cli"] = l3_iface["eos_cli"]
                                  config["ethernet_interfaces"][l3_iface["interfaces"][0]] = eth_iface
                              for parent_iface in l3_interface_subif_parents:
                                  config["ethernet_interfaces"][parent_iface] = {
                                      "type": "routed",
                                      "peer_type": "l3_interface",
                                      "shutdown": False
                                  }

                          # configure route maps
                          if info.get("bgp_peers"):
                              for peer, peer_info in info["bgp_peers"].items():
                                  if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                      config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)] = {
                                          "sequence_numbers": {
                                              10: {
                                                  "type": "permit",
                                                  "set": []
                                              }
                                          }
                                      }
                                      if peer_info.get("set_ipv4_next_hop"):
                                          config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                          ["sequence_numbers"][10]["set"].append(peer_info["set_ipv4_next_hop"])
                                      elif peer_info.get("set_ipv6_next_hop"):
                                          config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                          ["sequence_numbers"][10]["set"].append("set_ipv6_next_hop")

              # Assume this is a VTEP if below criteria is met
              if switch_facts.get("vtep"):
                  # if mlag is enabled
                  if switch_facts.get("mlag"):
                      # Get mlag_peer_switch facts
                      mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts["mlag_peer_serial_number"])
                      mlag_peer_switch_facts = set_switch_facts(mlag_peer_switch_facts)
                      # Initialize mlag port-channel interface for ibgp trunk groups
                      config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])] = {"trunk_groups": []}

                  # configure interfaces
                  for tenant in switch_facts["tenants"].keys():
                      for vrf in switch_facts["tenants"][tenant]["vrfs"].keys():
                          # set and configure vtep diagnostic loopback interfaces
                          if switch_facts["tenants"][tenant]["vrfs"][vrf].get("vtep_diagnostic"):
                              loopback_id = switch_facts["tenants"][tenant]["vrfs"][vrf]["vtep_diagnostic"]["loopback"]
                              loopback_description = "{}_VTEP_DIAGNOSTICS".format(vrf)
                              loopback_ipv4_pool = switch_facts["tenants"][tenant]["vrfs"][vrf]["vtep_diagnostic"]["loopback_ip_range"]
                              loopback_ip_host_addresses = list(ipaddress.ip_network(loopback_ipv4_pool).hosts())
                              loopback_ip = str(loopback_ip_host_addresses[int(switch_facts["id"]) - 1])
                              config["loopback_interfaces"]["Loopback{}".format(loopback_id)] = {
                                  "description": loopback_description,
                                  "shutdown": False,
                                  "vrf": vrf,
                                  "ip_address": "{}/32".format(loopback_ip)
                              }
                              # Set virtual-source-nat-vrfs
                              config["virtual_source_nat_vrfs"][vrf] = {
                                  "ip_address": loopback_ip
                              }


                          if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3"):
                              # configure svis
                              for svi, info in switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"].items():
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["tenant"] = tenant
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["vrf"] = vrf

                                  # Configure VIP and IP
                                  if info.get("ip_address_virtual"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                      ["ip_address_virtual"] = info["ip_address_virtual"]
                                  if info.get("ip_virtual_router_addresses"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                      ["ip_virtual_router_addresses"] = info["ip_virtual_router_addresses"]
                                  if info.get("ip_address"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                      ["ip_address"] = info["ip_address"]

                                  if info.get("ip_helpers"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {}
                                      for helper_address, dhcp_info in info["ip_helpers"].items():
                                          config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"][helper_address] = {
                                              "source_interface": dhcp_info.get("source_interface")
                                          }
                                  # if mtu
                                  if info.get("mtu"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["mtu"] = info["mtu"]
                                  # if arp aging timeout
                                  if info.get("arp"):
                                      if info["arp"].get("aging_timeout"):
                                          config["vlan_interfaces"]["Vlan{}".format(svi)]["arp_aging_timeout"] = info["arp"]["aging_timeout"]
                                  # configure eos_cli statements
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["eos_cli"] = info["eos_cli"]                        

                          # configure vrf ibgp mlag peer interface
                          if switch_facts.get("mlag") \
                              and switch_facts["tenants"][tenant]["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                              ibgp_vlan = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                              ibgp_peering_subnet = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_subnet"]
                              ibgp_peering_subnet_mask = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"]
                              mlag_ip = str(get_mlag_ip(
                                      switch_facts, 
                                      ibgp_peering_subnet, 
                                      ibgp_peering_subnet_mask,
                                      switch_facts["mlag_role"]
                                      )
                                  )
                              config["vlan_interfaces"]["Vlan{}".format(ibgp_vlan)] = {
                                  "tenant": tenant,
                                  "type": "underlay_peering",
                                  "shutdown": False,
                                  "description": "MLAG_PEER_L3_iBGP:{}".format(vrf),
                                  "vrf": vrf,
                                  "ip_address": "{}/{}".format(mlag_ip, ibgp_peering_subnet_mask)
                              }
                              if "MLAG_VRF_PEER" not in config["port_channel_interfaces"]\
                                  ["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"]:
                                  config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]\
                                      ["trunk_groups"].append("MLAG_VRF_PEER")

                  # Perform vtep logic (set rds and rts)
                  ip_vrf_admin_field_key_words = {
                      "VNI": "vrf_info['vrf_vni']",
                      "Router-ID": "switch_facts['router_id']"
                  }
                  vlan_based_mac_vrf_admin_field_key_words = {
                      "VNI": "vlan_info['vni']",
                      "VLAN": "vlan",
                      "Router-ID": "switch_facts['router_id']"
                  }
                  for tenant in switch_facts["tenants"].keys():
                      # Set vrfs
                      for vrf, vrf_info in switch_facts["tenants"][tenant]["vrfs"].items():
                          if vrf != "default":
                              # Set vrf rd
                              switch_rd = []
                              for rd_segment in vrf_info["route_distinguisher"].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rd_segment):
                                      switch_rd.append(str(eval(ip_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vrf_info["route_distinguisher"] = ":".join(switch_rd)
                              # Set vrf rt
                              switch_rt = []
                              for rt_segment in vrf_info["route_target"].split(":"):
                                  if ip_vrf_admin_field_key_words.get(rt_segment):
                                      switch_rt.append(str(eval(ip_vrf_admin_field_key_words[rt_segment])))
                                  else:
                                      switch_rt.append(rt_segment)
                              vrf_info["route_target"] = ":".join(switch_rt)
                          # Set L3 vlans
                          for svi, vlan_info in switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"].items():
                              # Set vlan rd
                              switch_rd = []
                              for rd_segment in vlan_info["route_distinguisher"].split(":"):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                      switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                                  else:
                                      switch_rd.append(rd_segment)
                              vlan_info["route_distinguisher"] = ":".join(switch_rd)
                              # Set vlan rt
                              switch_rt = []
                              for rt_segment in vlan_info["route_target"].split(":"):
                                  if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                      switch_rt.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment])))
                                  else:
                                      switch_rt.append(rt_segment)
                              vlan_info["route_target"]  = ":".join(switch_rt)
                      # Set l2 vlans
                      for vlan, vlan_info in switch_facts["tenants"][tenant]["l2vlans"].items():
                          # Set vlan rd
                          switch_rd = []
                          for rd_segment in vlan_info["route_distinguisher"].split(":"):
                              if vlan_based_mac_vrf_admin_field_key_words.get(rd_segment) is not None:
                                  switch_rd.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rd_segment])))
                              else:
                                  switch_rd.append(rd_segment)
                          vlan_info["route_distinguisher"] = ":".join(switch_rd)
                          # Set vlan rt
                          switch_rt = []
                          for rt_segment in vlan_info["route_target"].split(":"):
                              if vlan_based_mac_vrf_admin_field_key_words.get(rt_segment) is not None:
                                  switch_rt.append(str(eval(vlan_based_mac_vrf_admin_field_key_words[rt_segment])))
                              else:
                                  switch_rt.append(rt_segment)
                          vlan_info["route_target"]  = ":".join(switch_rt)

                  # Set bgp
                  if switch_facts["network_services"].get("l3"):
                      config["router_bgp"]["vrfs"] = {}
                      config["router_bgp"]["vlans"] = {}
                      for tenant in switch_facts["tenants"].keys():
                          # Set vrfs
                          for vrf, vrf_info in switch_facts["tenants"][tenant]["vrfs"].items():
                              address_family_ipv4_neighbors = [] 
                              address_family_ipv6_neighbors = []
                              try:
                                  if vrf == "default":
                                      route_distinguisher = None
                                      route_targets = None
                                  else:
                                      route_distinguisher = vrf_info["route_distinguisher"]
                                      route_targets = {
                                          "import": {
                                              "evpn": [vrf_info["route_target"]]
                                          },
                                          "export": {
                                              "evpn": [vrf_info["route_target"]]
                                          }
                                      }
                                      # additional route targets
                                      if vrf_info.get("additional_route_targets"):
                                          for rt in natural_sort(vrf_info["additional_route_targets"]):
                                              if rt.get("address_family") and \
                                                  rt.get("route_target") and rt.get("type"):
                                                  if rt["address_family"] in route_targets[rt["type"]].keys(): 
                                                      route_targets[rt["type"]][rt["address_family"]].append(rt["route_target"])
                                                  else:
                                                      route_targets[rt["type"]].update({rt["address_family"]: rt["route_target"]})
                              except Exception as e:
                                  assert False, "{} is having an issue with {} vrf: {}".format(switch_facts["hostname"], vrf, e)
                              # initialize vrf
                              config["router_bgp"]["vrfs"][vrf] = {
                                  "router_id": switch_facts["router_id"],
                                  "rd": route_distinguisher,
                                  "route_targets": route_targets,
                                  "neighbors": {},
                                  "redistribute_routes": {
                                      "connected": {}
                                      # "attached-host": {}
                                  },
                                  "address_families": {
                                      "ipv4": {"neighbors": {}, "networks":{}},
                                      "ipv6": {"neighbors": {}, "networks":{}}
                                  }
                              }
                              # get and set mlag peer config
                              if switch_facts.get("mlag") \
                              and switch_facts["tenants"][tenant]["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                                  ibgp_vlan = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                                  ibgp_peering_subnet = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_subnet"]
                                  ibgp_peering_subnet_mask = switch_facts["tenants"][tenant]["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"]
                                  mlag_peer_ip = str(get_mlag_ip(
                                          switch_facts, 
                                          ibgp_peering_subnet, 
                                          ibgp_peering_subnet_mask,
                                          mlag_peer_switch_facts["mlag_role"]
                                          )
                                      )
                                  # Add mlag_ip to nieghbors and address family
                                  config["router_bgp"]["vrfs"][vrf]["neighbors"][mlag_peer_ip] = {
                                      "remote_as": switch_facts["bgp_as"],
                                      "description": mlag_peer_switch_facts["hostname"]
                                  }
                                  address_family_ipv4_neighbors.append(mlag_peer_ip)
                              # set external bgp peers
                              if vrf_info.get("bgp_peers"):
                                  for peer, peer_info in vrf_info["bgp_peers"].items():
                                      if validIPAddress(peer) == True:
                                          address_family_ipv4_neighbors.append(peer)
                                      elif validIPAddress(peer) == False:
                                          address_family_ipv6_neighbors.append(peer)
                                      else:
                                          continue
                                      if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                          peer_info.update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                          if peer_info.get("default_originate"):
                                              if not peer_info["default_originate"].get("route_map"):
                                                  peer_info["default_originate"].update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                          if peer_info.get("set_ipv4_next_hop"):
                                              peer_info.pop("set_ipv4_next_hop")
                                          if peer_info.get("set_ipv6_next_hop"):
                                              peer_info.pop("set_ipv6_next_hop")
                                      config["router_bgp"]["vrfs"][vrf]["neighbors"][peer] = peer_info
                              # redistribute static routes
                              if vrf_info.get("redistribute_static"):
                                  config["router_bgp"]["vrfs"][vrf]["redistribute_routes"]["static"] = {}
                              # activate neighbors for ipv4 address family
                              if len(address_family_ipv4_neighbors) > 0:
                                  for neighbor in address_family_ipv4_neighbors:
                                      config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"]["neighbors"][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"])
                              # activate neighbors for ipv6 address family
                              if len(address_family_ipv6_neighbors) > 0:
                                  for neighbor in address_family_ipv6_neighbors:
                                      config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"]["neighbors"][neighbor] = {
                                          "activate": True
                                      }
                              else:
                                  del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"])

                              # Set l3 vlans
                              for vlan, vlan_info in vrf_info["svis"].items():
                                  config["router_bgp"]["vlans"][vlan] = {
                                      "tenant": tenant,
                                      "rd": vlan_info["route_distinguisher"],
                                      "route_targets": {
                                          "both": [vlan_info["route_target"]]
                                      },
                                      "redistribute_routes": {
                                          "learned":{}
                                      }
                                  }
                          # Set l2 vlans
                          for vlan, vlan_info in switch_facts["tenants"][tenant]["l2vlans"].items():
                              config["router_bgp"]["vlans"][vlan] = {
                                  "tenant": tenant,
                                  "rd": vlan_info["route_distinguisher"],
                                  "route_targets": {
                                      "both": [vlan_info["route_target"]]
                                  },
                                  "redistribute_routes": {
                                      "learned":{}
                                  }
                              }

                  # Set vxlan interface
                  config["vxlan_interface"] = {"Vxlan1":{"vxlan": {"vrfs":{}, "vlans": {}}}}
                  for tenant in switch_facts["tenants"].keys():
                      for vrf in switch_facts["tenants"][tenant]["vrfs"].keys():
                          if vrf == "default":
                              continue
                          # map vrfs to vnis
                          config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf] = {
                              "vni": switch_facts["tenants"][tenant]["vrfs"][vrf]["vrf_vni"]
                          }

                          # map l3vlans to vnis
                          for svi, info in switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"].items():
                              if info.get("vni") is None:
                                  continue
                              if info.get("vni_override") is not None:
                                  info["vni"] = info["vni_override"]
                              config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][svi] = {
                                  "vni": info["vni"]
                              }

                      # map l2vlans to vnis
                      for l2vlan, info in switch_facts["tenants"][tenant]["l2vlans"].items():
                          if l2vlan.get("vni") is None:
                              continue
                          config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][l2vlan] = {
                              "vni": info["vni"]
                          }
              # clean up unnecessary config elements
              if switch_facts.get("mlag") and \
                  config["port_channel_interfaces"].get("Port-Channel{}".format(switch_facts["mlag_port_channel_id"])) and \
                  len(config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"]) == 0:
                  del(config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])])

              # Clear dhcp snooping config if veos
              if re.match(veos_regex, switch_facts["platform"]) and config.get("ip_dhcp_snooping"):
                  del config["ip_dhcp_snooping"]

              return config

          def get_tag_values_applied_to_device(tag_assignment_key):
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                  tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)
                          
              return matching_tags

          def get_tag_value(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return tag_values[0].value

          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [ tag_value.value for tag_value in tag_values ]

          def check_config_parameters(switch_facts):
              assert switch_facts["bgp_as"] is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                      "BGP ASN", "router_bgp.as", switch_facts["hostname"]
                  )
              assert switch_facts["router_id"] is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                      "BGP Router ID", "router_bgp.router_id", switch_facts["hostname"]
                  )
              if switch_facts.get("mlag") is not None:
                  assert switch_facts["mlag_port_channel_id"] is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                          "MLAG Peer Link", "mlag_configuration.peer_link", switch_facts["hostname"]
                      )

          def get_interfaces_info(switch_facts):
              device_id = switch_facts["serial_number"]
              interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None:
                      interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
              return interfaces

          def get_mlag_peer(switch_facts):
              mlag_peer_switch_serial_number = None
              if switch_facts["network_services"].get("l2"):
                  if switch_facts["network_services"].get("l3"):
                      # VTEP
                      if switch_facts.get("mlag"):
                          # Get MLAG peer from interface details
                          # Assumption is that this switch's MLAG peer should be the only neighbor switch with 
                          # both L2 and L3 network services enabled
                          for info in switch_facts["interfaces"].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                              if neighbor_switch_facts["network_services"].get("l2") \
                                  and neighbor_switch_facts["network_services"].get("l3"):
                                  mlag_peer_switch_serial_number = neighbor_switch_facts["serial_number"]
                                  break
                  else:
                      # Layer 2 switch
                      if switch_facts.get("mlag"):
                          # Get MLAG peer from neighbor details
                          # Assumption is that this switch has to be either a DC L2 Leaf or a Campus Pod L2 Primary/Secondary Leaf switch
                          # since L2/L3 switches hit above if statement and Campus Pod member switches shouldn't have MLAG enabled
                          for info in switch_facts["interfaces"].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                              if neighbor_switch_facts["network_services"].get("l2") \
                                  and not neighbor_switch_facts["network_services"].get("l3"):
                                  # Check to see if neighbor has mlag enabled as well
                                  if neighbor_switch_facts.get("mlag"):
                                      mlag_peer_switch_serial_number = neighbor_switch_facts["serial_number"]
                                      break
              return mlag_peer_switch_serial_number

          def get_gateway_switches(switch_facts):
              gateway_switches = []
              # Shouldn't have to worry about uplink switches on l3 switches
              if switch_facts["network_services"].get("l2"):
                  if switch_facts["network_services"].get("l3"):
                      gateway_switches = [switch_facts["serial_number"]]
                  else:
                      # Get uplink switches using neighbor details
                      uplink_switches = []
                      for info in switch_facts["interfaces"].values():
                          neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                          if neighbor_switch_facts["network_services"].get("l3"):
                              uplink_switches.append(neighbor_switch_facts)
                      # Assume switch is a campus pod member switch
                      if len(uplink_switches) == 0:
                          for info in switch_facts["interfaces"].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                              if neighbor_switch_facts["id"] in ["1", "2"]:
                                  uplink_switches.append(neighbor_switch_facts)
                      for uplink_switch_facts in uplink_switches:
                          if uplink_switch_facts["network_services"].get("l3"):
                              gateway_switches.append(uplink_switch_facts["serial_number"])
                          else:
                              uplink_switch_facts["interfaces"] = get_interfaces_info(uplink_switch_facts)
                              uplink_gateway_switches =  get_gateway_switches(uplink_switch_facts)
                              for switch_sn in uplink_gateway_switches:
                                  if switch_sn not in gateway_switches:
                                      gateway_switches.append(switch_sn)
              return gateway_switches

          def get_switch_basics_from_tags(device_id):
              switch_facts = {"serial_number": device_id}
              switch_facts["network_services"] = {}
              tags_to_facts = {
                  "hostname": "hostname",
                  "model": "platform",
                  "node_id": "id",
                  "router_bgp.as": "bgp_as",
                  "router_bgp.router_id": "router_id",
                  "mlag_configuration.peer_link": "mlag_port_channel_id",
                  "Campus-PoD": "group",
                  "Leaf-Domain": "group",
                  "group_id": "group_id",
                  "vtep": "vtep",
                  "Role": "type"
              }
              # Network services is a special case
              tags_to_facts["network_services"] = None

              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              for label in tags_to_facts.keys():
                  if label == "hostname":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.hostName:
                              switch_facts[tags_to_facts[label]] = dev.hostName
                      continue
                  elif label == "model":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.modelName:
                              switch_facts[tags_to_facts[label]] = dev.modelName
                      continue
                  elif label == "network_services":
                      tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                      for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                          try:
                              query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                          except:
                              continue
                          else:
                              for match in tagmresp.matches:
                                  if match.device.device_id == device_id:
                                      if tag.value.lower() == "l2":
                                          switch_facts["network_services"]["l2"] = True
                                      elif tag.value.lower() == "l3":
                                          switch_facts["network_services"]["l3"] = True
                  else:
                      tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                      for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                          try:
                              query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                          except:
                              continue
                          else:
                              for match in tagmresp.matches:
                                  if match.device.device_id == device_id:
                                      switch_facts[tags_to_facts[tag.label]] = tag.value
                                      break

              # If node_id tag isn't set, check for old leaf-number or spine-number tags
              if switch_facts.get("id") is None and switch_facts.get("type") in ["Leaf", "Spine"]:
                  id_tag_type = {"Leaf": "Leaf-Number", "Spine": "Spine-Number"}
                  node_id  = get_tag_value(device_id=device_id, label=id_tag_type[switch_facts["type"]], workspace_id=workspace_id)
                  if node_id is not None:
                      switch_facts["id"] = int(node_id)

              # Set l2 and l3 network_services if they haven't been set
              if switch_facts["network_services"].get("l2") is None:
                  switch_facts["network_services"]["l2"] = False
              if switch_facts["network_services"].get("l3") is None:
                  switch_facts["network_services"]["l3"] = False

              # Set l3 network services if not already set
              if not switch_facts["network_services"].get("l3") and switch_facts.get("type"):
                  if switch_facts["type"] in ["Leaf", "Spine", "Super-Spine"]:
                      switch_facts["network_services"]["l3"] = True
                  else:
                      switch_facts["network_services"]["l3"] = False
              # Set l2 network services if not already set
              if not switch_facts["network_services"].get("l2") and switch_facts.get("type"):
                  if switch_facts["type"] in ["Leaf", "L2-Leaf"]:
                      switch_facts["network_services"]["l2"] = True
                  else:
                      switch_facts["network_services"]["l2"] = False

              # normalize vtep
              if switch_facts.get("vtep"):
                  if re.match(r'true', switch_facts["vtep"], flags=re.IGNORECASE):
                      switch_facts["vtep"] = True
                  else:
                      switch_facts["vtep"] = False
              else:
                  switch_facts["vtep"] = False

              # Set vtep if not already set
              if not switch_facts.get("vtep") and switch_facts.get("type"):
                  if switch_facts["type"] in ["Leaf"]:
                      switch_facts["vtep"] = True
                  else:
                      switch_facts["vtep"] = False

              # normalize mlag_port_channel_id
              if switch_facts.get("mlag_port_channel_id"):
                  switch_facts["mlag_port_channel_id"] = "".join(re.findall(r'\d', switch_facts["mlag_port_channel_id"]))
                  switch_facts["mlag"] = True
              else:
                  switch_facts["mlag"] = False

              # Set other keys
              if switch_facts["network_services"].get("l3"):
                  switch_facts["uplink_type"] = "p2p"
              else:
                  switch_facts["uplink_type"] = "port-channel"

              return switch_facts

          def set_switch_facts(switch_facts):
              device_id = switch_facts["serial_number"]
              # Get interface info from studio topology tags
              switch_facts["interfaces"] = get_interfaces_info(switch_facts)

              # Get gateway details
              switch_facts["gateway_switches"] = get_gateway_switches(my_switch_facts)

              # Get mlag peer and mlag details
              switch_facts["mlag_peer_serial_number"] = get_mlag_peer(switch_facts)
              # Set mlag relevant facts
              if switch_facts.get("mlag_peer_serial_number"):
                  mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts["mlag_peer_serial_number"])
                  switch_facts["mlag"] = True
                  if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                      switch_facts["mlag_role"] = "primary"
                      switch_facts["mlag_primary_id"] = int(switch_facts["id"])
                  else:
                      switch_facts["mlag_role"] = "secondary"
                      switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])
              else:
                  switch_facts["mlag_role"] = None
              return switch_facts

          def clean_config(config_dict):
              # remove default vrf dictionary
              if config_dict.get("vrfs") and config_dict["vrfs"].get("default"):
                  del config_dict["vrfs"]["default"]
              # remove any empty SVIs

              # remove default vrf from L3 vrfs in bgp config
              if config_dict.get("router_bgp") and config_dict["router_bgp"].get("vrfs") and config_dict["router_bgp"]["vrfs"].get("default"):
                  del config_dict["router_bgp"]["vrfs"]["default"]

              return config_dict

          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False

          workspace_id = ctx.studio.workspaceId
          my_device = ctx.getDevice()
          my_device_id = my_device.id

          if not tenants:
              return

          config = {}

          my_switch_facts = get_switch_basics_from_tags(my_device_id)
          my_switch_facts = set_switch_facts(my_switch_facts)

          vlan_based_mac_vrf_attribute_formats = vlanBasedMacVrfAttributeFormats
          vlan_bundle_mac_vrf_attribute_formats = vlanBundleMacVrfAttributeFormats
          vrf_attribute_formats = vrfAttributeFormats

          vrfs = {}
          vrfs_seen = {}
          vlans = {}
          vlans_seen = {}
          vlan_aware_bundles = {}

          # Get VLANs and VRFs from input
          for tenant in tenants:
              for vrf in tenant["vrfs"]:
                  #Check to see if vrf already exists in a previously traversed tenant
                  assert vrfs_seen.get(vrf["name"]) is None, "{} found in multiple Tenants -> {} and {}. Please remove the VRF {} definition from one of the previously listed tenants.".format(
                      vrf["name"], vrfs_seen[vrf["name"]], tenant["name"],  vrf["name"]
                  )
                  vrfs_seen[vrf["name"]] = tenant["name"]
                  vrfs[vrf["name"]] = {
                      "tenant": tenant["name"], # Set for error asserting purposes
                      "nat_source_details": vrf["natSourceDetails"],
                      "ibgp_details": vrf["iBgpDetails"],
                      "vni": vrf["vni"],
                      "l3_interfaces": vrf["l3Interfaces"],
                      "static_routes": vrf["staticRoutes"],
                      "redistribute_static_routes": vrf["redistributeStaticRoutes"],
                      "external_bgp_peers": vrf["externalBgpPeers"],
                      "additional_route_targets": vrf["additionalRouteTargets"],
                      "route_distinguisher": vrf_attribute_formats["vrfRouteDistinguisherFormat"],
                      "route_target": vrf_attribute_formats["vrfRouteTargetFormat"],
                      "devices": vrf["devices"],
                      "error_name": "VRF {}".format(vrf["name"]) # Set for error asserting purposes
                  }
                  if vrf["overrideVariables"]["routeDistinguisher"] is not None and vrf["overrideVariables"]["routeDistinguisher"].strip() != "":
                      vrfs[vrf["name"]]["route_distinguisher"] = vrf["overrideVariables"]["routeDistinguisher"]
                  if vrf["overrideVariables"]["routeTarget"] is not None and vrf["overrideVariables"]["routeTarget"].strip() != "":
                      vrfs[vrf["name"]]["route_target"] = vrf["overrideVariables"]["routeTarget"]

              for vlan in tenant["vlans"]:
                  #Check to see if vlan already exists in a previously traversed tenant
                  assert vlans_seen.get(vlan["vlanId"]) is None, "{} found in multiple Tenants -> {} and {}. Please remove the VLAN {} definition from one of the previously listed tenants.".format(
                      vlan["vlanId"], vlans_seen[vlan["vlanId"]], tenant["name"],  vlan["vlanId"]
                  )
                  vlans_seen[vlan["vlanId"]] = tenant["name"]
                  vlans[vlan["vlanId"]] = {
                      "name": vlan["name"],
                      "svi_ip_addresses": vlan["sviIpAddresses"],
                      "dhcp_server_details": vlan["dhcpServerDetails"],
                      "vni": int(vlan["vlanId"]) + int(tenant["macVrfVniBase"]),
                      "member_switches": vlan["switches"],
                      "arp": vlan["arp"],
                      "mtu": vlan["mtu"],
                      "eos_cli": vlan["eosCli"],
                      "route_distinguisher": vlan_based_mac_vrf_attribute_formats["macVrfRouteDistinguisherFormat"],
                      "route_target": vlan_based_mac_vrf_attribute_formats["macVrfRouteTargetFormat"],
                      "tenant": tenant["name"], # Set for error asserting purposes
                      "error_name": "Vlan{}".format(vlan["vlanId"]) # Set for error asserting purposes
                  }
                  if vlan.get("overrideVariables"):
                      if vlan["overrideVariables"]["vni"] is not None:
                          vlans[vlan["vlanId"]]["vni_override"] = int(vlan["overrideVariables"]["vni"])
                      else:
                          vlans[vlan["vlanId"]]["vni_override"] = None
                      if vlan["overrideVariables"]["routeDistinguisher"] is not None and vlan["overrideVariables"]["routeDistinguisher"].strip() != "":
                          vlans[vlan["vlanId"]]["route_distinguisher"] = vlan["overrideVariables"]["routeDistinguisher"]
                      if vlan["overrideVariables"]["routeTarget"] is not None and vlan["overrideVariables"]["routeTarget"].strip() != "":
                          vlans[vlan["vlanId"]]["route_target"] = vlan["overrideVariables"]["routeTarget"]

              for vlan_aware_bundle in tenant["vlanAwareBundles"]:
                  vlan_range = string_to_list(vlan_aware_bundle["vlanRange"])
                  vlan_range = list_compress(vlan_range)
                  vlan_aware_bundles[ vlan_aware_bundle["name"] ] = {
                      "vlan_range": vlan_range,
                      "route_distinguisher": vlan_bundle_mac_vrf_attribute_formats["macVrfRouteDistinguisherFormat"],
                      "route_target": vlan_bundle_mac_vrf_attribute_formats["macVrfRouteTargetFormat"],
                      "tenant": tenant["name"]
                  }
                  if vlan_aware_bundle["overrideVariables"]["routeDistinguisher"] is not None and vlan_aware_bundle["overrideVariables"]["routeDistinguisher"].strip() != "":
                      vlan_aware_bundles[ vlan_aware_bundle["name"] ]["route_distinguisher"] = vlan_aware_bundle["overrideVariables"]["routeDistinguisher"]
                  if vlan_aware_bundle["overrideVariables"]["routeTarget"] is not None and vlan_aware_bundle["overrideVariables"]["routeTarget"].strip() != "":
                      vlan_aware_bundles[ vlan_aware_bundle["name"] ]["route_target"] = vlan_aware_bundle["overrideVariables"]["routeTarget"]

          # Check for duplicate VNIs
          check_vni_overlap(vrfs, vlans)

          # Check which VRFs, VLANs, and VLAN Aware Bundles have been applied to my_switch
          my_switch_vrfs = {}
          my_switch_vlans = {}
          my_switch_vlan_bundles = {}

          # Get VLANs that should be configured on this switch
          for vlan, vlan_details in vlans.items():
              for gateway_id in my_switch_facts["gateway_switches"]:
                  if device_matches_resolver_query(vlan_details["member_switches"].resolve(device=gateway_id)["switch"]["hostname"], gateway_id) == True:
                      my_switch_vlans[vlan] = vlan_details
                      if vlan_details["svi_ip_addresses"].get("vrf") is not None and vlan_details["svi_ip_addresses"]["vrf"].strip() not in ["", "None"]:
                          my_switch_vrfs[vlan_details["svi_ip_addresses"]["vrf"]] = vrfs[vlan_details["svi_ip_addresses"]["vrf"]]
                      for bundle, bundle_details in vlan_aware_bundles.items():
                          if vlan in string_to_list(bundle_details["vlan_range"]):
                              my_switch_vlan_bundles[bundle] = bundle_details
                              break
                      break

          # Get VRFs that should be configured on the switch
          for vrf, info in vrfs.items():
              # check if device is specified in Applied Devices 
              if device_matches_resolver_query(info["devices"].resolve(device=my_switch_facts["serial_number"])["devices"]["hostname"], my_switch_facts["serial_number"]):
                  my_switch_vrfs[vrf] = info
                  continue

              # check if any l3 interfaces resolve
              if len(info.get("l3_interfaces").resolve(device=my_switch_facts["serial_number"])["interfaces"]) > 0:
                  my_switch_vrfs[vrf] = info
                  continue        

              # check if apply column resolves for any static routes
              for sr in info.get("static_routes"):
                  # if static route is to be configured on switch
                  if sr["devices"].resolve(device=my_switch_facts["serial_number"])["devices"]["hostname"].resolve(device=my_switch_facts["serial_number"]).get("apply"):
                      my_switch_vrfs[vrf] = info
                      break
              if my_switch_vrfs.get(vrf):
                  continue
              # check if apply column resolves for external bgp neighbors
              for bgp_peer in info.get("external_bgp_peers"):
                  # if bgp peer is to be configured on switch
                  if bgp_peer["devices"].resolve(device=my_switch_facts["serial_number"])["devices"]["hostname"].resolve(device=my_switch_facts["serial_number"]).get("apply"):
                      my_switch_vrfs[vrf] = info
                      break
              if my_switch_vrfs.get(vrf):
                  continue
              # check if apply column resolves for additional route targets
              for rt in info.get("additional_route_targets"):
                  # if additional route target is to be configured on switch
                  if rt["devices"].resolve(device=my_switch_facts["serial_number"])["devices"]["hostname"].resolve(device=my_switch_facts["serial_number"]).get("apply"):
                      my_switch_vrfs[vrf] = info
                      break

          my_switch_facts = normalize_tenant_info(my_switch_facts, my_switch_vrfs, my_switch_vlans, my_switch_vlan_bundles)

          if len(my_switch_facts["tenants"].keys()) > 0:
              my_config = {
                  "vrfs": {},
                  "vlans": {},
                  "vlan_interfaces": {},
                  "port_channel_interfaces": {},
                  "ethernet_interfaces": {},
                  "loopback_interfaces": {},
                  "virtual_source_nat_vrfs": {},
                  "static_routes": [],
                  "route_maps": {},
                  "router_bgp": {
                      "peer_groups": {},
                  }
              }
              my_config = set_base_config(my_config, my_switch_facts)
              my_config = set_network_services_config(my_config, my_switch_facts)
              my_config = clean_config(my_config)
          else:
              my_config = {}
          config = my_config
          switch_facts = my_switch_facts
          %>
          ## ${json.dumps(switch_facts, indent=2)}
          ## -------------------------------------
          ## ${json.dumps(config, indent=2)}
          ## eos - ip dhcp relay
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - ip dhcp snooping
          %if config.get("ip_dhcp_snooping"):
          ip dhcp snooping
          !
          %   if config["ip_dhcp_snooping"].get("information_option"):
          ip dhcp snooping information option
          %   endif
          %   if config["ip_dhcp_snooping"].get("vlans"):
          %       for vlan in config["ip_dhcp_snooping"]["vlans"]:
          ip dhcp snooping vlan ${vlan}
          %       endfor
          %   endif
          !
          %endif
          ## eos - IP IGMP Snooping
          % if config.get("ip_igmp_snooping"):
          %    if not config["ip_igmp_snooping"].get("globally_enabled"):
          no ip igmp snooping
          %    elif config["ip_igmp_snooping"].get("vlans"):
          %      for vlan in natural_sort(config["ip_igmp_snooping"]["vlans"].keys()):
          %          if config["ip_igmp_snooping"]["vlans"]["enabled"]["querier"] == False:
          no ip igmp snooping vlan ${ vlan } querier
          %          endif %}
          !
          %      endfor %}
          !
          %    endif
          %endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
          name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
          state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
          trunk group ${ trunk_group }
          %               endfor
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
          description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          %   endfor
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
          description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
          shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
          mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
          no switchport
          %     else:
          switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
          switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
          switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
          switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
          description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
          channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
          mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
          no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface]["type"] == "l3dot1q" and config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
          encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %         else:
          switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
          switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
          switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
          switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
          vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
          ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
              ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
              ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
              pim ipv4 sparse-mode
          %           endif
          %         endif
          %    if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %       for statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
          ${statement}
          %       endfor
          %    endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
          description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
          shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
          no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
          vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
          ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          !
          %   endfor
          %endif
          ## vlan-interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
          description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
          shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
          mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
          no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface]["vrf"] != "default":
          vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
          ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config["vlan_interfaces"][vlan_interface]["ip_address_secondaries"]:
          ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses") is not None:
          %         for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface]["ip_virtual_router_addresses"]:
          ip virtual-router address ${ ip_virtual_router_address }
          %         endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
          ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config["vlan_interfaces"][vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
          ${ ip_helper_cli }
          %       endfor
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("arp_aging_timeout") is not None:
          arp aging timeout ${ config.get("vlan_interfaces")[vlan_interface]["arp_aging_timeout"] }
          %    endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("igmp"):
          ip igmp
          %       if config.get("vlan_interfaces")[vlan_interface]["igmp"].get("query_interval"):
          ip igmp query-interval ${config.get("vlan_interfaces")[vlan_interface]["igmp"]["query_interval"]}
          %       endif
          %     endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("multicast"):
          %       if config.get("vlan_interfaces")[vlan_interface]["multicast"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("static"):
          multicast ipv4 static
          %           endif
          %       endif
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("pim"):
          %       if config.get("vlan_interfaces")[vlan_interface]["pim"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("local_interface"):
          pim ipv4 local-interface ${config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"]["local_interface"]}
          %           endif
          %       endif
          %    endif
          %    if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %       for statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
          ${statement}
          %       endfor
          %    endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("source_interface"):
          vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["source_interface"] }
          %     endif
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
          vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
          vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
          vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan].get("multicast"):
          vxlan vlan ${ vlan } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["multicast"]["group"]}
          %               endif
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
          vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf].get("multicast"):
          vxlan vlan ${ vrf } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["multicast"]["group"]}
          %               endif
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - IP Routing 
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          %   for vrf in config.get("vrfs"):
          %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % if config.get("static_routes"):
          %     for static_route in config["static_routes"]:
          <%         static_route_cli = "ip route" %>
          %         if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%             static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %         endif
          %         if static_route.get("destination_address_prefix"):
          <%             static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %         endif
          %         if static_route.get("interface"):
          <%             static_route_cli = static_route_cli + " " + static_route["interface"].upper() %>
          %         endif
          %         if static_route.get("gateway"):
          <%             static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %         endif
          %         if static_route.get("distance"):
          <%             static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %         endif
          %         if static_route.get("tag"):
          <%             static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %         endif
          %         if static_route.get("name"):
          <%             static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %         endif
          %         if static_route.get("metric"):
          <%             static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %         endif
          ${ static_route_cli }
          !
          %    endfor %}
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## router-bgp
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
          router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
          ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
          bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
          neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
          neighbor ${ peer_group } shutdown
          %         endif
          neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
          neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
          neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
          neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
          neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
          neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
          neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
          neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
          neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
          neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
          neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
          neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
          neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
          neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in config["router_bgp"]["neighbors"].keys():
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
          neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
          neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor].remote_as }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
          neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
          neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
          neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
          neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
          neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
          neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
          neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
          neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
          neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
          ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
          vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].get("rd") is not None:
              rd ${ config["router_bgp"]["vlans"][vlan]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
          !
          vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
              rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
              vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
          !
          address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
              no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
              host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
              host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
              domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
          !
          address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
              neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
              no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
          !
          vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
              rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
              route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
              route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
              router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast"):
              evpn multicast
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
              timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
              neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
              neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
              neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
              neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
              neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
              ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
              neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
              neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
              neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
              neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
              neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
              neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
              ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
              ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                  neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                  ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
      input_schema:
        fields:
          values:
            tenantName:
              id: tenantName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfName:
              id: vrfName
              name: name
              label: Name
              description: ''
              required: true
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            iBgpSubnet:
              id: iBgpSubnet
              name: iBgpSubnet
              label: Peering Subnet
              description: Define the subnet of the host IP address for the iBGP peering of SVIs with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            iBgpVlanId:
              id: iBgpVlanId
              name: iBgpVlanId
              label: Peering VLAN
              description: Determine the VLAN used for iBGP peering with an MLAG peer (if an MLAG peer exists).
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            iBgpSubnetMask:
              id: iBgpSubnetMask
              name: iBgpSubnetMask
              label: Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            iBgpDetails:
              id: iBgpDetails
              name: iBgpDetails
              label: MLAG L3 Peering
              description: Enable iBGP overlay by configuring values.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - iBgpSubnet
                    - iBgpVlanId
                    - iBgpSubnetMask
            natInterface:
              id: natInterface
              name: natInterface
              label: Source NAT Loopback ID
              description: Define the loopback interface used for sourcing pings within this VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSourceNatSubnet:
              id: campusSourceNatSubnet
              name: subnet
              label: Subnet
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusSite:
              id: campusSite
              name: site
              label: Site
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            sourceNatCampusResolver:
              id: sourceNatCampusResolver
              name: campus
              label: Campus Source NAT Subnets
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusSite
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            dataCenterSourceNatSubnet:
              id: dataCenterSourceNatSubnet
              name: subnet
              label: Subnet
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            dataCenterPod:
              id: dataCenterPod
              name: dcPoD
              label: DC PoD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterSourceNatSubnet
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC-Pod
                tag_filter_query: null
            sourceNatDataCenterResolver:
              id: sourceNatDataCenterResolver
              name: dataCenter
              label: Data Center Source NAT Subnets
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: dataCenterPod
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: DC
                tag_filter_query: null
            natSourceDetails:
              id: natSourceDetails
              name: natSourceDetails
              label: Virtual Source NAT
              description: Enable NAT by configuring values.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - natInterface
                    - sourceNatCampusResolver
                    - sourceNatDataCenterResolver
            vrfOverrideRouteDistinguisher:
              id: vrfOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideRouteTarget:
              id: vrfOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOverrideVariables:
              id: vrfOverrideVariables
              name: overrideVariables
              label: Override VRF Attributes
              description: Enter values specific to this VRF to override the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOverrideRouteDistinguisher
                    - vrfOverrideRouteTarget
            vrfOverrideVNI:
              id: vrfOverrideVNI
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay.
              required: true
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: Non-selectively redistributes static routes
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            additionalRouteTargetsRouteTarget:
              id: additionalRouteTargetsRouteTarget
              name: routeTarget
              label: Route Target
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsType:
              id: additionalRouteTargetsType
              name: type
              label: Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - import
                    - export
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsAddressFamily:
              id: additionalRouteTargetsAddressFamily
              name: addressFamily
              label: Address Family
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            additionalRouteTargetsApply:
              id: additionalRouteTargetsApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            additionalRouteTargetsHostname:
              id: additionalRouteTargetsHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            additionalRouteTargetsDevicesGroup:
              id: additionalRouteTargetsDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsHostname
            additionalRouteTargetsDevicesResolver:
              id: additionalRouteTargetsDevicesResolver
              name: devices
              label: Devices
              description: Devices to configure route targets on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: additionalRouteTargetsDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            additionalRouteTargetsDetails:
              id: additionalRouteTargetsDetails
              name: routeTargetDetails
              label: Route Target Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - additionalRouteTargetsRouteTarget
                    - additionalRouteTargetsType
                    - additionalRouteTargetsAddressFamily
                    - additionalRouteTargetsDevicesResolver
            additionalRouteTargets:
              id: additionalRouteTargets
              name: additionalRouteTargets
              label: Additional Route Targets
              description: Configure extra route-targets for this VRF. Useful for route-leaking or gateway between address families.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: additionalRouteTargetsDetails
                key: ''
            externalBgpPeersNeighborIpAddress:
              id: externalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRemoteAs:
              id: externalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersDescription:
              id: externalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersPassword:
              id: externalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersSendCommunity:
              id: externalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopSelf:
              id: externalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersMaxRoutes:
              id: externalBgpPeersMaxRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWarningLimitRoutes:
              id: externalBgpPeersWarningLimitRoutes
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersMaxRoutesGroup:
              id: externalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersMaxRoutes
                    - externalBgpPeersWarningLimitRoutes
            externalBgpPeersUpdateSource:
              id: externalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: Name of source interface
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersEbgpMultihop:
              id: externalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersWeight:
              id: externalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersRouteMapIn:
              id: externalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapOut:
              id: externalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersRouteMapGroup:
              id: externalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersRouteMapIn
                    - externalBgpPeersRouteMapOut
            externalBgpPeersDefaultOriginateAlways:
              id: externalBgpPeersDefaultOriginateAlways
              name: always
              label: Always
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersDefaultOriginate:
              id: externalBgpPeersDefaultOriginate
              name: defaultOriginate
              label: Default Originate
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersDefaultOriginateAlways
            externalBgpPeersNextHopIpv4:
              id: externalBgpPeersNextHopIpv4
              name: iPv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopIpv6:
              id: externalBgpPeersNextHopIpv6
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            externalBgpPeersNextHopGroup:
              id: externalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: Next hop settings can be either ipv4 or ipv6 for one neighbor, this will be applied by a uniquely generated route-map per neighbor. Next hop takes precedence over route_map_out.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNextHopIpv4
                    - externalBgpPeersNextHopIpv6
            externalBgpPeersApply:
              id: externalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            externalBgpPeersHostname:
              id: externalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            externalBgpPeersDevicesGroup:
              id: externalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersHostname
            externalBgpPeersDevicesResolver:
              id: externalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: Devices to configure neighbor on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: externalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            externalBgpPeersLocalAs:
              id: externalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            externalBgpPeersDetails:
              id: externalBgpPeersDetails
              name: bgpPeerDetails
              label: BGP Peer Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - externalBgpPeersNeighborIpAddress
                    - externalBgpPeersRemoteAs
                    - externalBgpPeersDescription
                    - externalBgpPeersPassword
                    - externalBgpPeersSendCommunity
                    - externalBgpPeersNextHopSelf
                    - externalBgpPeersMaxRoutesGroup
                    - externalBgpPeersUpdateSource
                    - externalBgpPeersEbgpMultihop
                    - externalBgpPeersWeight
                    - externalBgpPeersRouteMapGroup
                    - externalBgpPeersDefaultOriginate
                    - externalBgpPeersNextHopGroup
                    - externalBgpPeersDevicesResolver
                    - externalBgpPeersLocalAs
            externalBgpPeers:
              id: externalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: This will configure BGP neighbors inside the tenant VRF for peering with external devices. The configured peer will automatically be activated for ipv4 or ipv6 address family based on the ip address
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: externalBgpPeersDetails
                key: externalBgpPeersNeighborIpAddress
            staticRoutesDescription:
              id: staticRoutesDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesApply:
              id: staticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            staticRoutesHostname:
              id: staticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            staticRoutesDevicesGroup:
              id: staticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesHostname
            staticRoutesDevicesResolver:
              id: staticRoutesDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: staticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            staticRoutesDestinationAddressPrefix:
              id: staticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesGateway:
              id: staticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesInterface:
              id: staticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            staticRoutesDistance:
              id: staticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesTag:
              id: staticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesMetric:
              id: staticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            staticRoutesDetails:
              id: staticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDestinationAddressPrefix
                    - staticRoutesGateway
                    - staticRoutesInterface
                    - staticRoutesDistance
                    - staticRoutesTag
                    - staticRoutesMetric
            staticRoutesGroup:
              id: staticRoutesGroup
              name: value
              label: Static Routes Group
              description: Group of members for Static Routes
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - staticRoutesDescription
                    - staticRoutesDevicesResolver
                    - staticRoutesDetails
            staticRoutesCollection:
              id: staticRoutesCollection
              name: staticRoutes
              label: Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: staticRoutesGroup
                key: staticRoutesDescription
            vrfAssignApply:
              id: vrfAssignApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            vrfAssignHostname:
              id: vrfAssignHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfAssignDevicesGroup:
              id: vrfAssignDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfAssignHostname
            vrfAssignDevicesResolver:
              id: vrfAssignDevicesResolver
              name: devices
              label: Devices
              description: Devices to apply this VRF to where the VRF won't be automatically applied from VLAN association, static route redistribution, external BGP peerings, or additional route-targets.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfAssignDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfGroup:
              id: vrfGroup
              name: vrfGroup
              label: VRF Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - iBgpDetails
                    - natSourceDetails
                    - vrfOverrideVariables
                    - vrfOverrideVNI
                    - vrfL3InterfacesDevice
                    - vrfRedistributeStaticRoutesToggle
                    - additionalRouteTargets
                    - externalBgpPeers
                    - staticRoutesCollection
                    - vrfAssignDevicesResolver
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfGroup
                key: vrfName
            vlanAwareBundleVlanRange:
              id: vlanAwareBundleVlanRange
              name: vlanRange
              label: VLAN Range
              description: Assign VLANS to this bundle with their VLAN IDs. Specify separate VLANs with a comma and series with a hyphen (e.g 1-9, 14, 23-40).
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleName:
              id: vlanAwareBundleName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteDistinguisher:
              id: vlanAwareBundleOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideRouteTarget:
              id: vlanAwareBundleOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanAwareBundleOverrideVariables:
              id: vlanAwareBundleOverrideVariables
              name: overrideVariables
              label: Overide MAC-VRF Attributes
              description: Enter values specific to this VRF to overide the default MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleOverrideRouteDistinguisher
                    - vlanAwareBundleOverrideRouteTarget
            vlanAwareBundleGroup:
              id: vlanAwareBundleGroup
              name: vlanGroup
              label: VLAN Bundle Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanAwareBundleVlanRange
                    - vlanAwareBundleName
                    - vlanAwareBundleOverrideVariables
            vlanAwareBundles:
              id: vlanAwareBundles
              name: vlanAwareBundles
              label: VLAN Aware Bundles
              description: Configure a bundle of VLANs that share the same MAC-VRF attributes.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanAwareBundleGroup
                key: vlanAwareBundleName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanBasedVlanName:
              id: vlanBasedVlanName
              name: name
              label: Name
              description: Enter a one-word name for the VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanMemberSwitchApply:
              id: vlanMemberSwitchApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanMemberSwitchHostname:
              id: vlanMemberSwitchHostname
              name: hostname
              label: Hostname
              description: The service will not be configured unless Apply is selected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitchApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vlanMemberSwitch:
              id: vlanMemberSwitch
              name: switch
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanMemberSwitchHostname
            vlanMemberSwitches:
              id: vlanMemberSwitches
              name: switches
              label: VTEPs
              description: Assign a VLAN to devices.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlanMemberSwitch
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vlanDhcpServers:
              id: vlanDhcpServers
              name: dhcpServer
              label: DHCP Server
              description: Enter the FQDN or the IP address of the DHCP server.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelperSourceInterface:
              id: vlanDhcpHelperSourceInterface
              name: sourceInterface
              label: Source Interface
              description: Enter an interface to source DHCP relays from
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpServerDetail:
              id: vlanDhcpServerDetail
              name: dhcpServerDetail
              label: DHCP Server Detail
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpServers
                    - vlanDhcpHelperSourceInterface
            vlanDhcpServerDetails:
              id: vlanDhcpServerDetails
              name: dhcpServerDetails
              label: DHCP Helper Details
              description: Specify the location of the DHCP server for this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpServerDetail
                key: vlanDhcpServers
            vlanL3OrL2:
              id: vlanL3OrL2
              name: l3OrL2
              label: Routed or Bridged
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanSviVirtualIpAddress:
              id: vlanSviVirtualIpAddress
              name: sviVirtualIpAddress
              label: SVI Virtual IP Address
              description: Assign a virtual IP address to be used on the VLAN's SVI. This will be the default gateway for devices behind this VTEP on this VLAN.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanVirtualAddressConfigType:
              id: vlanVirtualAddressConfigType
              name: virtualAddressConfigType
              label: Virtual Address Config Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vlanVrf:
              id: vlanVrf
              name: vrf
              label: VRF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: None
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            vlanSVIIpAddresses:
              id: vlanSVIIpAddresses
              name: sviIpAddresses
              label: SVI Addressing
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviVirtualIpAddress
                    - vlanVirtualAddressConfigType
                    - vlanVrf
            vlanOverrideVni:
              id: vlanOverrideVni
              name: vni
              label: VNI
              description: Enter a Virtual Network Identifier to identify networks in the overlay
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanOverrideRouteDistinguisher:
              id: vlanOverrideRouteDistinguisher
              name: routeDistinguisher
              label: Route Distinguisher
              description: 'Assign a route value to this VRF. Use the format Router-ID: integer (eg. 67: 5013).'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideRouteTarget:
              id: vlanOverrideRouteTarget
              name: routeTarget
              label: Route Target
              description: 'Set a target to import routes from, and to enable other switches to determine if they need to import route updates from this VRF. Use the format integer: VNI or VLAN ID (e.g. 12: 5131)'
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanOverrideVariables:
              id: vlanOverrideVariables
              name: overrideVariables
              label: Override Attributes
              description: Enter values specific to this VLAN and VRF to override the default generated attributes.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanOverrideVni
                    - vlanOverrideRouteDistinguisher
                    - vlanOverrideRouteTarget
            vlanSviMtu:
              id: vlanSviMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '9214'
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpAgingTimeout:
              id: vlanSviArpAgingTimeout
              name: arpAgingTimeout
              label: ARP Aging Timeout
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSviArpDetails:
              id: vlanSviArpDetails
              name: arp
              label: ARP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanSviArpAgingTimeout
            vlanSviCliStatement:
              id: vlanSviCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCliStatements:
              id: vlanSviEosCliStatements
              name: eosCli
              label: EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviCliStatement
                key: ''
            vlanBasedVlans:
              id: vlanBasedVlans
              name: vlanBasedVlaNs
              label: VLAN Definitions
              description: VLAN based VLANs
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanBasedVlanName
                    - vlanMemberSwitches
                    - vlanDhcpServerDetails
                    - vlanL3OrL2
                    - vlanSVIIpAddresses
                    - vlanOverrideVariables
                    - vlanSviMtu
                    - vlanSviArpDetails
                    - vlanSviEosCliStatements
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanBasedVlans
                key: vlanId
            macVrfVniBase:
              id: macVrfVniBase
              name: macVrfVniBase
              label: MAC-VRF VNI Base
              description: Set the default number that generates each Virtual Network Identifier by adding it to the specific VLAN ID.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '10000'
                range: null
                static_options: null
                dynamic_options: null
            tenantDefinition:
              id: tenantDefinition
              name: tenantDefinition
              label: Tenant Definition
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenantName
                    - vrfs
                    - vlanAwareBundles
                    - vlans
                    - macVrfVniBase
            tenants:
              id: tenants
              name: tenants
              label: Tenants
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: tenantDefinition
                key: tenantName
            vrfRouteDistinguisherFormat:
              id: vrfRouteDistinguisherFormat
              name: vrfRouteDistinguisherFormat
              label: VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfRouteTargetFormat:
              id: vrfRouteTargetFormat
              name: vrfRouteTargetFormat
              label: VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfAttributeFormats:
              id: vrfAttributeFormats
              name: vrfAttributeFormats
              label: VRF Attributes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfRouteDistinguisherFormat
                    - vrfRouteTargetFormat
            vlanBasedMacVrfRouteDistinguisherFormat:
              id: vlanBasedMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:VNI
                static_options:
                  values:
                    - Router-ID:VNI
                    - Router-ID:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfRouteTargetFormat:
              id: vlanBasedMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: VNI:VNI
                static_options:
                  values:
                    - VNI:VNI
                    - VLAN:VLAN
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBasedMacVrfAttributeFormats:
              id: vlanBasedMacVrfAttributeFormats
              name: vlanBasedMacVrfAttributeFormats
              label: VLAN Based MAC-VRF Attributes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBasedMacVrfRouteDistinguisherFormat
                    - vlanBasedMacVrfRouteTargetFormat
            vlanBundleMacVrfRouteDistinguisherFormat:
              id: vlanBundleMacVrfRouteDistinguisherFormat
              name: macVrfRouteDistinguisherFormat
              label: MAC-VRF Route Distinguisher Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: Router-ID:First-VLAN
                static_options:
                  values:
                    - Router-ID:First-VLAN
                    - Router-ID:First-VNI
                    - Router-ID:Last-VLAN
                    - Router-ID:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfRouteTargetFormat:
              id: vlanBundleMacVrfRouteTargetFormat
              name: macVrfRouteTargetFormat
              label: MAC-VRF Route Target Format
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: First-VNI:Last-VNI
                static_options:
                  values:
                    - First-VLAN:First-VLAN
                    - First-VNI:First-VNI
                    - Last-VLAN:Last-VLAN
                    - Last-VNI:Last-VNI
                    - First-VLAN:Last-VLAN
                    - First-VNI:Last-VNI
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanBundleMacVrfAttributeFormats:
              id: vlanBundleMacVrfAttributeFormats
              name: vlanBundleMacVrfAttributeFormats
              label: VLAN Bundle MAC-VRF Attributes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanBundleMacVrfRouteDistinguisherFormat
                    - vlanBundleMacVrfRouteTargetFormat
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - tenants
                    - vrfAttributeFormats
                    - vlanBasedMacVrfAttributeFormats
                    - vlanBundleMacVrfAttributeFormats
        layout:
          value: |
            {
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "tenants":{
                "key":"tenants",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanBasedVlans":{
                "key":"vlanBasedVlans",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlanMemberSwitches",
                  "vlanBasedVlanName",
                  "vlanL3OrL2",
                  "vlanSVIIpAddresses",
                  "vlanDhcpServerDetails",
                  "vlanSviMtu",
                  "vlanSviArpDetails",
                  "vlanSviEosCliStatements",
                  "vlanOverrideVariables"
                ]
              },
              "vrfGroup":{
                "key":"vrfGroup",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfOverrideVNI",
                  "iBgpDetails",
                  "natSourceDetails",
                  "vrfL3InterfacesDevice",
                  "staticRoutesCollection",
                  "vrfRedistributeStaticRoutesToggle",
                  "externalBgpPeers",
                  "additionalRouteTargets",
                  "vrfAssignDevicesResolver",
                  "vrfOverrideVariables"
                ]
              },
              "vlanL3OrL2":{
                "key":"vlanL3OrL2",
                "valueToLabelMap":{
                  "True":"Routed",
                  "False":"Bridged"
                },
                "type":"INPUT"
              },
              "vlanSviVirtualIpAddress":{
                "key":"vlanSviVirtualIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSviSecondaryIpAddress":{
                "key":"vlanSviSecondaryIpAddress",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "tenantDefinition":{
                "key":"tenantDefinition",
                "type":"INPUT",
                "order":[
                  "tenantName",
                  "vrfs",
                  "macVrfVniBase",
                  "vlans",
                  "vlanAwareBundles"
                ]
              },
              "iBgpDetails":{
                "key":"iBgpDetails",
                "type":"INPUT",
                "order":[
                  "iBgpVlanId",
                  "iBgpSubnet",
                  "iBgpSubnetMask"
                ]
              },
              "vlanDhcpServerVrf":{
                "key":"vlanDhcpServerVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanDhcpServers":{
                "key":"vlanDhcpServers",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanAwareBundleGroup":{
                "key":"vlanAwareBundleGroup",
                "type":"INPUT",
                "order":[
                  "vlanAwareBundleName",
                  "vlanAwareBundleVlanRange",
                  "vlanAwareBundleOverrideVariables"
                ]
              },
              "vlanAwareBundles":{
                "key":"vlanAwareBundles",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanMemberSwitches":{
                "key":"vlanMemberSwitches",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vlanVrf":{
                "key":"vlanVrf",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfOverrideVariables":{
                "key":"vrfOverrideVariables",
                "type":"INPUT",
                "order":[
                  "vrfOverrideRouteDistinguisher",
                  "vrfOverrideRouteTarget"
                ]
              },
              "vlanMemberSwitchApply":{
                "key":"vlanMemberSwitchApply",
                "dependency":{
                  "vlanMemberSwitchApply":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSVIIpAddresses":{
                "key":"vlanSVIIpAddresses",
                "type":"INPUT",
                "order":[
                  "vlanVrf",
                  "vlanSviVirtualIpAddress",
                  "vlanVirtualAddressConfigType"
                ]
              },
              "vlanVirtualAddressConfigType":{
                "key":"vlanVirtualAddressConfigType",
                "type":"INPUT",
                "valueToLabelMap":{
                  "True":"ip address virtual",
                  "False":"ip virtual-router address"
                }
              },
              "natSourceDetails":{
                "key":"natSourceDetails",
                "type":"INPUT",
                "order":[
                  "sourceNatDataCenterResolver",
                  "sourceNatCampusResolver",
                  "natInterface"
                ]
              },
              "campusSite":{
                "key":"campusSite",
                "type":"INPUT",
                "isPageLayout":false
              },
              "vlanSviMtu":{
                "key":"vlanSviMtu",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlanSviArpAgingTimeout":{
                "key":"vlanSviArpAgingTimeout",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfacesDevice":{
                "key":"vrfL3InterfacesDevice",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfacesCollection"
                ]
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeers":{
                "key":"externalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "externalBgpPeersDetails":{
                "key":"externalBgpPeersDetails",
                "type":"INPUT",
                "order":[
                  "externalBgpPeersNeighborIpAddress",
                  "externalBgpPeersDevicesResolver",
                  "externalBgpPeersRemoteAs",
                  "externalBgpPeersDescription",
                  "externalBgpPeersPassword",
                  "externalBgpPeersSendCommunity",
                  "externalBgpPeersNextHopSelf",
                  "externalBgpPeersMaxRoutesGroup",
                  "externalBgpPeersUpdateSource",
                  "externalBgpPeersEbgpMultihop",
                  "externalBgpPeersWeight",
                  "externalBgpPeersNextHopGroup",
                  "externalBgpPeersRouteMapGroup",
                  "externalBgpPeersDefaultOriginate",
                  "externalBgpPeersLocalAs"
                ]
              },
              "staticRoutesCollection":{
                "key":"staticRoutesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSviCliStatement":{
                "key":"vlanSviCliStatement",
                "type":"INPUT",
                "dependency":{
                  "vlanL3OrL2":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "VlanAssignmentBgpTagger":{
                "type":"TAGGER",
                "parentKey":"vlanMemberSwitch",
                "key":"VlanAssignmentBgpTagger",
                "name":"BGP Tags",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"network_services:L2 AND network_services:L3 ",
                "tagType":"DEVICE",
                "description":"Necessary BGP Tags",
                "columns":[
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                      
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "VrfAssignmentBgpTagger":{
                "type":"TAGGER",
                "parentKey":"vrfAssignHostname",
                "key":"VrfAssignmentBgpTagger",
                "name":"BGP Tags",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"network_services:L3 ",
                "tagType":"DEVICE",
                "description":"",
                "columns":[
                  {
                    "tagLabel":"router_bgp.as",
                    "suggestedValues":[
                      
                    ]
                  },
                  {
                    "tagLabel":"router_bgp.router_id",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "vrfAssignDevicesGroup":{
                "key":"vrfAssignDevicesGroup",
                "type":"INPUT",
                "order":[
                  "vrfAssignHostname"
                ]
              },
              "vlanMemberSwitch":{
                "key":"vlanMemberSwitch",
                "type":"INPUT",
                "order":[
                  "vlanMemberSwitchHostname",
                  "VlanAssignmentBgpTagger"
                ]
              }
            }